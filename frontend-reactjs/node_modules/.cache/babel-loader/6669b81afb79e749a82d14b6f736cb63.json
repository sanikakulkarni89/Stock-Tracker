{"ast":null,"code":"/*\n Highcharts JS v11.1.0 (2023-06-05)\n\n (c) 2009-2021 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n'use strict';\n\nvar _slicedToArray = require(\"/Users/sohambhure/Desktop/Stocks App/frontend-react/stocks-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar _get = require(\"/Users/sohambhure/Desktop/Stocks App/frontend-react/stocks-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\nvar _toConsumableArray = require(\"/Users/sohambhure/Desktop/Stocks App/frontend-react/stocks-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _possibleConstructorReturn = require(\"/Users/sohambhure/Desktop/Stocks App/frontend-react/stocks-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/Users/sohambhure/Desktop/Stocks App/frontend-react/stocks-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/sohambhure/Desktop/Stocks App/frontend-react/stocks-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _classCallCheck = require(\"/Users/sohambhure/Desktop/Stocks App/frontend-react/stocks-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/sohambhure/Desktop/Stocks App/frontend-react/stocks-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _defineProperty = require(\"/Users/sohambhure/Desktop/Stocks App/frontend-react/stocks-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e8) { throw _e8; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e9) { didErr = true; err = _e9; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n(function (U, M) {\n  \"object\" === typeof module && module.exports ? (M[\"default\"] = M, module.exports = U.document ? M(U) : M) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts\", function () {\n    return M(U);\n  }) : (U.Highcharts && U.Highcharts.error(16, !0), U.Highcharts = M(U));\n})(\"undefined\" !== typeof window ? window : this, function (U) {\n  function M(a, y, I, L) {\n    a.hasOwnProperty(y) || (a[y] = L.apply(null, I), \"function\" === typeof CustomEvent && U.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: y,\n        module: a[y]\n      }\n    })));\n  }\n  var a = {};\n  M(a, \"Core/Globals.js\", [], function () {\n    var a;\n    (function (a) {\n      a.SVG_NS = \"http://www.w3.org/2000/svg\";\n      a.product = \"Highcharts\";\n      a.version = \"11.1.0\";\n      a.win = \"undefined\" !== typeof U ? U : {};\n      a.doc = a.win.document;\n      a.svg = a.doc && a.doc.createElementNS && !!a.doc.createElementNS(a.SVG_NS, \"svg\").createSVGRect;\n      a.userAgent = a.win.navigator && a.win.navigator.userAgent || \"\";\n      a.isChrome = -1 !== a.userAgent.indexOf(\"Chrome\");\n      a.isFirefox = -1 !== a.userAgent.indexOf(\"Firefox\");\n      a.isMS = /(edge|msie|trident)/i.test(a.userAgent) && !a.win.opera;\n      a.isSafari = !a.isChrome && -1 !== a.userAgent.indexOf(\"Safari\");\n      a.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a.userAgent);\n      a.isWebKit = -1 !== a.userAgent.indexOf(\"AppleWebKit\");\n      a.deg2rad = 2 * Math.PI / 360;\n      a.hasBidiBug = a.isFirefox && 4 > parseInt(a.userAgent.split(\"Firefox/\")[1], 10);\n      a.hasTouch = !!a.win.TouchEvent;\n      a.marginNames = [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"];\n      a.noop = function () {};\n      a.supportsPassiveEvents = function () {\n        var x = !1;\n        if (!a.isMS) {\n          var y = Object.defineProperty({}, \"passive\", {\n            get: function get() {\n              x = !0;\n            }\n          });\n          a.win.addEventListener && a.win.removeEventListener && (a.win.addEventListener(\"testPassive\", a.noop, y), a.win.removeEventListener(\"testPassive\", a.noop, y));\n        }\n        return x;\n      }();\n      a.charts = [];\n      a.dateFormats = {};\n      a.seriesTypes = {};\n      a.symbolSizes = {};\n      a.chartCount = 0;\n    })(a || (a = {}));\n    \"\";\n    return a;\n  });\n  M(a, \"Core/Utilities.js\", [a[\"Core/Globals.js\"]], function (a) {\n    function x(c, b, f, k) {\n      var n = b ? \"Highcharts error\" : \"Highcharts warning\";\n      32 === c && (c = \"\".concat(n, \": Deprecated member\"));\n      var r = u(c);\n      var e = r ? \"\".concat(n, \" #\").concat(c, \": www.highcharts.com/errors/\").concat(c, \"/\") : c.toString();\n      if (\"undefined\" !== typeof k) {\n        var _c = \"\";\n        r && (e += \"?\");\n        E(k, function (b, n) {\n          _c += \"\\n - \".concat(n, \": \").concat(b);\n          r && (e += encodeURI(n) + \"=\" + encodeURI(b));\n        });\n        e += _c;\n      }\n      d(a, \"displayError\", {\n        chart: f,\n        code: c,\n        message: e,\n        params: k\n      }, function () {\n        if (b) throw Error(e);\n        q.console && -1 === x.messages.indexOf(e) && console.warn(e);\n      });\n      x.messages.push(e);\n    }\n    function I(c, b) {\n      return parseInt(c, b || 10);\n    }\n    function L(c) {\n      return \"string\" === typeof c;\n    }\n    function C(c) {\n      c = Object.prototype.toString.call(c);\n      return \"[object Array]\" === c || \"[object Array Iterator]\" === c;\n    }\n    function z(c, b) {\n      return !!c && \"object\" === typeof c && (!b || !C(c));\n    }\n    function H(c) {\n      return z(c) && \"number\" === typeof c.nodeType;\n    }\n    function B(c) {\n      var b = c && c.constructor;\n      return !(!z(c, !0) || H(c) || !b || !b.name || \"Object\" === b.name);\n    }\n    function u(c) {\n      return \"number\" === typeof c && !isNaN(c) && Infinity > c && -Infinity < c;\n    }\n    function v(c) {\n      return \"undefined\" !== typeof c && null !== c;\n    }\n    function l(c, b, f) {\n      var n = L(b) && !v(f);\n      var d;\n      var k = function k(b, f) {\n        v(b) ? c.setAttribute(f, b) : n ? (d = c.getAttribute(f)) || \"class\" !== f || (d = c.getAttribute(f + \"Name\")) : c.removeAttribute(f);\n      };\n      L(b) ? k(f, b) : E(b, k);\n      return d;\n    }\n    function p(c) {\n      return C(c) ? c : [c];\n    }\n    function t(c, b) {\n      var n;\n      c || (c = {});\n      for (n in b) c[n] = b[n];\n      return c;\n    }\n    function m() {\n      var c = arguments,\n        b = c.length;\n      for (var n = 0; n < b; n++) {\n        var _b = c[n];\n        if (\"undefined\" !== typeof _b && null !== _b) return _b;\n      }\n    }\n    function h(c, b) {\n      a.isMS && !a.svg && b && v(b.opacity) && (b.filter = \"alpha(opacity=\".concat(100 * b.opacity, \")\"));\n      t(c.style, b);\n    }\n    function g(c) {\n      return Math.pow(10, Math.floor(Math.log(c) / Math.LN10));\n    }\n    function e(c, b) {\n      return 1E14 < c ? c : parseFloat(c.toPrecision(b || 14));\n    }\n    function w(c, b, f) {\n      var n;\n      if (\"width\" === b) return b = Math.min(c.offsetWidth, c.scrollWidth), f = c.getBoundingClientRect && c.getBoundingClientRect().width, f < b && f >= b - 1 && (b = Math.floor(f)), Math.max(0, b - (w(c, \"padding-left\", !0) || 0) - (w(c, \"padding-right\", !0) || 0));\n      if (\"height\" === b) return Math.max(0, Math.min(c.offsetHeight, c.scrollHeight) - (w(c, \"padding-top\", !0) || 0) - (w(c, \"padding-bottom\", !0) || 0));\n      if (c = q.getComputedStyle(c, void 0)) n = c.getPropertyValue(b), m(f, \"opacity\" !== b) && (n = I(n));\n      return n;\n    }\n    function E(c, b, f) {\n      for (var n in c) Object.hasOwnProperty.call(c, n) && b.call(f || c[n], c[n], n, c);\n    }\n    function F(c, b, f) {\n      function n(b, n) {\n        var f = c.removeEventListener;\n        f && f.call(c, b, n, !1);\n      }\n      function d(f) {\n        var d, K;\n        c.nodeName && (b ? (d = {}, d[b] = !0) : d = f, E(d, function (c, b) {\n          if (f[b]) for (K = f[b].length; K--;) n(b, f[b][K].fn);\n        }));\n      }\n      var k = \"function\" === typeof c && c.prototype || c;\n      if (Object.hasOwnProperty.call(k, \"hcEvents\")) {\n        var _c2 = k.hcEvents;\n        b ? (k = _c2[b] || [], f ? (_c2[b] = k.filter(function (c) {\n          return f !== c.fn;\n        }), n(b, f)) : (d(_c2), _c2[b] = [])) : (d(_c2), delete k.hcEvents);\n      }\n    }\n    function d(c, b, f, d) {\n      f = f || {};\n      if (r.createEvent && (c.dispatchEvent || c.fireEvent && c !== a)) {\n        var n = r.createEvent(\"Events\");\n        n.initEvent(b, !0, !0);\n        f = t(n, f);\n        c.dispatchEvent ? c.dispatchEvent(f) : c.fireEvent(b, f);\n      } else if (c.hcEvents) {\n        f.target || t(f, {\n          preventDefault: function preventDefault() {\n            f.defaultPrevented = !0;\n          },\n          target: c,\n          type: b\n        });\n        n = [];\n        var _d = c,\n          K = !1;\n        for (; _d.hcEvents;) Object.hasOwnProperty.call(_d, \"hcEvents\") && _d.hcEvents[b] && (n.length && (K = !0), n.unshift.apply(n, _d.hcEvents[b])), _d = Object.getPrototypeOf(_d);\n        K && n.sort(function (c, b) {\n          return c.order - b.order;\n        });\n        n.forEach(function (b) {\n          !1 === b.fn.call(c, f) && f.preventDefault();\n        });\n      }\n      d && !f.defaultPrevented && d.call(c, f);\n    }\n    var k = a.charts,\n      r = a.doc,\n      q = a.win;\n    (x || (x = {})).messages = [];\n    Math.easeInOutSine = function (c) {\n      return -.5 * (Math.cos(Math.PI * c) - 1);\n    };\n    var G = Array.prototype.find ? function (c, b) {\n      return c.find(b);\n    } : function (c, b) {\n      var f;\n      var n = c.length;\n      for (f = 0; f < n; f++) if (b(c[f], f)) return c[f];\n    };\n    E({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (c, b) {\n      a[b] = function (f) {\n        x(32, !1, void 0, _defineProperty({}, \"Highcharts.\".concat(b), \"use Array.\".concat(c)));\n        return Array.prototype[c].apply(f, [].slice.call(arguments, 1));\n      };\n    });\n    var b;\n    var f = function () {\n      var c = Math.random().toString(36).substring(2, 9) + \"-\";\n      var f = 0;\n      return function () {\n        return \"highcharts-\" + (b ? \"\" : c) + f++;\n      };\n    }();\n    q.jQuery && (q.jQuery.fn.highcharts = function () {\n      var c = [].slice.call(arguments);\n      if (this[0]) return c[0] ? (new a[L(c[0]) ? c.shift() : \"Chart\"](this[0], c[0], c[1]), this) : k[l(this[0], \"data-highcharts-chart\")];\n    });\n    G = {\n      addEvent: function addEvent(c, b, f) {\n        var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        var n = \"function\" === typeof c && c.prototype || c;\n        Object.hasOwnProperty.call(n, \"hcEvents\") || (n.hcEvents = {});\n        n = n.hcEvents;\n        a.Point && c instanceof a.Point && c.series && c.series.chart && (c.series.chart.runTrackerClick = !0);\n        var k = c.addEventListener;\n        k && k.call(c, b, f, a.supportsPassiveEvents ? {\n          passive: void 0 === d.passive ? -1 !== b.indexOf(\"touch\") : d.passive,\n          capture: !1\n        } : !1);\n        n[b] || (n[b] = []);\n        n[b].push({\n          fn: f,\n          order: \"number\" === typeof d.order ? d.order : Infinity\n        });\n        n[b].sort(function (c, b) {\n          return c.order - b.order;\n        });\n        return function () {\n          F(c, b, f);\n        };\n      },\n      arrayMax: function arrayMax(c) {\n        var b = c.length,\n          f = c[0];\n        for (; b--;) c[b] > f && (f = c[b]);\n        return f;\n      },\n      arrayMin: function arrayMin(c) {\n        var b = c.length,\n          f = c[0];\n        for (; b--;) c[b] < f && (f = c[b]);\n        return f;\n      },\n      attr: l,\n      clamp: function clamp(c, b, f) {\n        return c > b ? c < f ? c : f : b;\n      },\n      clearTimeout: function (_clearTimeout) {\n        function clearTimeout(_x2) {\n          return _clearTimeout.apply(this, arguments);\n        }\n        clearTimeout.toString = function () {\n          return _clearTimeout.toString();\n        };\n        return clearTimeout;\n      }(function (c) {\n        v(c) && clearTimeout(c);\n      }),\n      correctFloat: e,\n      createElement: function createElement(c, b, f, d, K) {\n        c = r.createElement(c);\n        b && t(c, b);\n        K && h(c, {\n          padding: \"0\",\n          border: \"none\",\n          margin: \"0\"\n        });\n        f && h(c, f);\n        d && d.appendChild(c);\n        return c;\n      },\n      css: h,\n      defined: v,\n      destroyObjectProperties: function destroyObjectProperties(c, b) {\n        E(c, function (f, n) {\n          f && f !== b && f.destroy && f.destroy();\n          delete c[n];\n        });\n      },\n      diffObjects: function diffObjects(c, b, f, d) {\n        function n(b, c, K, k) {\n          var A = f ? c : b;\n          E(b, function (f, q) {\n            if (!k && d && -1 < d.indexOf(q) && c[q]) {\n              f = p(f);\n              K[q] = [];\n              for (var _b2 = 0; _b2 < Math.max(f.length, c[q].length); _b2++) c[q][_b2] && (void 0 === f[_b2] ? K[q][_b2] = c[q][_b2] : (K[q][_b2] = {}, n(f[_b2], c[q][_b2], K[q][_b2], k + 1)));\n            } else if (z(f, !0) && !f.nodeType) K[q] = C(f) ? [] : {}, n(f, c[q] || {}, K[q], k + 1), 0 !== Object.keys(K[q]).length || \"colorAxis\" === q && 0 === k || delete K[q];else if (b[q] !== c[q] || q in b && !(q in c)) K[q] = A[q];\n          });\n        }\n        var k = {};\n        n(c, b, k, 0);\n        return k;\n      },\n      discardElement: function discardElement(b) {\n        b && b.parentElement && b.parentElement.removeChild(b);\n      },\n      erase: function erase(b, f) {\n        var c = b.length;\n        for (; c--;) if (b[c] === f) {\n          b.splice(c, 1);\n          break;\n        }\n      },\n      error: x,\n      extend: t,\n      extendClass: function extendClass(b, f) {\n        var c = function c() {};\n        c.prototype = new b();\n        t(c.prototype, f);\n        return c;\n      },\n      find: G,\n      fireEvent: d,\n      getClosestDistance: function getClosestDistance(b, f) {\n        var c = !f;\n        var d, n, k, q;\n        b.forEach(function (b) {\n          if (1 < b.length) for (q = n = b.length - 1; 0 < q; q--) k = b[q] - b[q - 1], 0 > k && !c ? (null === f || void 0 === f ? void 0 : f(), f = void 0) : k && (\"undefined\" === typeof d || k < d) && (d = k);\n        });\n        return d;\n      },\n      getMagnitude: g,\n      getNestedProperty: function getNestedProperty(b, f) {\n        for (b = b.split(\".\"); b.length && v(f);) {\n          var c = b.shift();\n          if (\"undefined\" === typeof c || \"__proto__\" === c) return;\n          if (\"this\" === c) {\n            var _b3 = void 0;\n            z(f) && (_b3 = f[\"@this\"]);\n            return null !== _b3 && void 0 !== _b3 ? _b3 : f;\n          }\n          f = f[c];\n          if (!v(f) || \"function\" === typeof f || \"number\" === typeof f.nodeType || f === q) return;\n        }\n        return f;\n      },\n      getStyle: w,\n      inArray: function inArray(b, f, d) {\n        x(32, !1, void 0, {\n          \"Highcharts.inArray\": \"use Array.indexOf\"\n        });\n        return f.indexOf(b, d);\n      },\n      insertItem: function insertItem(b, f) {\n        var c = b.options.index,\n          d = f.length;\n        var n;\n        for (n = b.options.isInternal ? d : 0; n < d + 1; n++) if (!f[n] || u(c) && c < m(f[n].options.index, f[n]._i) || f[n].options.isInternal) {\n          f.splice(n, 0, b);\n          break;\n        }\n        return n;\n      },\n      isArray: C,\n      isClass: B,\n      isDOMElement: H,\n      isFunction: function isFunction(b) {\n        return \"function\" === typeof b;\n      },\n      isNumber: u,\n      isObject: z,\n      isString: L,\n      keys: function keys(b) {\n        x(32, !1, void 0, {\n          \"Highcharts.keys\": \"use Object.keys\"\n        });\n        return Object.keys(b);\n      },\n      merge: function merge() {\n        var b,\n          f = arguments,\n          d = {};\n        var k = function k(b, c) {\n          \"object\" !== typeof b && (b = {});\n          E(c, function (f, d) {\n            \"__proto__\" !== d && \"constructor\" !== d && (!z(f, !0) || B(f) || H(f) ? b[d] = c[d] : b[d] = k(b[d] || {}, f));\n          });\n          return b;\n        };\n        !0 === f[0] && (d = f[1], f = Array.prototype.slice.call(f, 2));\n        var K = f.length;\n        for (b = 0; b < K; b++) d = k(d, f[b]);\n        return d;\n      },\n      normalizeTickInterval: function normalizeTickInterval(b, f, d, k, K) {\n        var c = b;\n        d = m(d, g(b));\n        var n = b / d;\n        f || (f = K ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === k && (1 === d ? f = f.filter(function (b) {\n          return 0 === b % 1;\n        }) : .1 >= d && (f = [1 / d])));\n        for (k = 0; k < f.length && !(c = f[k], K && c * d >= b || !K && n <= (f[k] + (f[k + 1] || f[k])) / 2); k++);\n        return c = e(c * d, -Math.round(Math.log(.001) / Math.LN10));\n      },\n      objectEach: E,\n      offset: function offset(b) {\n        var c = r.documentElement;\n        b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {\n          top: 0,\n          left: 0,\n          width: 0,\n          height: 0\n        };\n        return {\n          top: b.top + (q.pageYOffset || c.scrollTop) - (c.clientTop || 0),\n          left: b.left + (q.pageXOffset || c.scrollLeft) - (c.clientLeft || 0),\n          width: b.width,\n          height: b.height\n        };\n      },\n      pad: function pad(b, f, d) {\n        return Array((f || 2) + 1 - String(b).replace(\"-\", \"\").length).join(d || \"0\") + b;\n      },\n      pick: m,\n      pInt: I,\n      pushUnique: function pushUnique(b, f) {\n        return 0 > b.indexOf(f) && !!b.push(f);\n      },\n      relativeLength: function relativeLength(b, f, d) {\n        return /%$/.test(b) ? f * parseFloat(b) / 100 + (d || 0) : parseFloat(b);\n      },\n      removeEvent: F,\n      splat: p,\n      stableSort: function stableSort(b, f) {\n        var c = b.length;\n        var d, k;\n        for (k = 0; k < c; k++) b[k].safeI = k;\n        b.sort(function (b, c) {\n          d = f(b, c);\n          return 0 === d ? b.safeI - c.safeI : d;\n        });\n        for (k = 0; k < c; k++) delete b[k].safeI;\n      },\n      syncTimeout: function syncTimeout(b, f, d) {\n        if (0 < f) return setTimeout(b, f, d);\n        b.call(0, d);\n        return -1;\n      },\n      timeUnits: {\n        millisecond: 1,\n        second: 1E3,\n        minute: 6E4,\n        hour: 36E5,\n        day: 864E5,\n        week: 6048E5,\n        month: 24192E5,\n        year: 314496E5\n      },\n      uniqueKey: f,\n      useSerialIds: function useSerialIds(c) {\n        return b = m(c, b);\n      },\n      wrap: function wrap(b, f, d) {\n        var c = b[f];\n        b[f] = function () {\n          var b = arguments,\n            f = this;\n          return d.apply(this, [function () {\n            return c.apply(f, arguments.length ? arguments : b);\n          }].concat([].slice.call(arguments)));\n        };\n      }\n    };\n    \"\";\n    return G;\n  });\n  M(a, \"Core/Chart/ChartDefaults.js\", [], function () {\n    return {\n      alignThresholds: !1,\n      panning: {\n        enabled: !1,\n        type: \"x\"\n      },\n      styledMode: !1,\n      borderRadius: 0,\n      colorCount: 10,\n      allowMutatingData: !0,\n      ignoreHiddenSeries: !0,\n      spacing: [10, 10, 15, 10],\n      resetZoomButton: {\n        theme: {\n          zIndex: 6\n        },\n        position: {\n          align: \"right\",\n          x: -10,\n          y: 10\n        }\n      },\n      reflow: !0,\n      type: \"line\",\n      zooming: {\n        singleTouch: !1,\n        resetButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        }\n      },\n      width: null,\n      height: null,\n      borderColor: \"#334eff\",\n      backgroundColor: \"#ffffff\",\n      plotBorderColor: \"#cccccc\"\n    };\n  });\n  M(a, \"Core/Color/Color.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    var x = y.isNumber,\n      L = y.merge,\n      C = y.pInt;\n    var z = /*#__PURE__*/function () {\n      _createClass(z, null, [{\n        key: \"parse\",\n        value: function parse(a) {\n          return a ? new z(a) : z.None;\n        }\n      }]);\n      function z(x) {\n        _classCallCheck(this, z);\n        this.rgba = [NaN, NaN, NaN, NaN];\n        this.input = x;\n        var B = a.Color;\n        if (B && B !== z) return new B(x);\n        this.init(x);\n      }\n      _createClass(z, [{\n        key: \"init\",\n        value: function init(a) {\n          var B;\n          var u;\n          if (\"object\" === typeof a && \"undefined\" !== typeof a.stops) this.stops = a.stops.map(function (l) {\n            return new z(l[1]);\n          });else if (\"string\" === typeof a) {\n            this.input = a = z.names[a.toLowerCase()] || a;\n            if (\"#\" === a.charAt(0)) {\n              var v = a.length;\n              var l = parseInt(a.substr(1), 16);\n              7 === v ? B = [(l & 16711680) >> 16, (l & 65280) >> 8, l & 255, 1] : 4 === v && (B = [(l & 3840) >> 4 | (l & 3840) >> 8, (l & 240) >> 4 | l & 240, (l & 15) << 4 | l & 15, 1]);\n            }\n            if (!B) for (l = z.parsers.length; l-- && !B;) u = z.parsers[l], (v = u.regex.exec(a)) && (B = u.parse(v));\n          }\n          B && (this.rgba = B);\n        }\n      }, {\n        key: \"get\",\n        value: function get(a) {\n          var B = this.input,\n            u = this.rgba;\n          if (\"object\" === typeof B && \"undefined\" !== typeof this.stops) {\n            var v = L(B);\n            v.stops = [].slice.call(v.stops);\n            this.stops.forEach(function (l, p) {\n              v.stops[p] = [v.stops[p][0], l.get(a)];\n            });\n            return v;\n          }\n          return u && x(u[0]) ? \"rgb\" === a || !a && 1 === u[3] ? \"rgb(\" + u[0] + \",\" + u[1] + \",\" + u[2] + \")\" : \"a\" === a ? \"\".concat(u[3]) : \"rgba(\" + u.join(\",\") + \")\" : B;\n        }\n      }, {\n        key: \"brighten\",\n        value: function brighten(a) {\n          var B = this.rgba;\n          if (this.stops) this.stops.forEach(function (u) {\n            u.brighten(a);\n          });else if (x(a) && 0 !== a) for (var u = 0; 3 > u; u++) B[u] += C(255 * a), 0 > B[u] && (B[u] = 0), 255 < B[u] && (B[u] = 255);\n          return this;\n        }\n      }, {\n        key: \"setOpacity\",\n        value: function setOpacity(a) {\n          this.rgba[3] = a;\n          return this;\n        }\n      }, {\n        key: \"tweenTo\",\n        value: function tweenTo(a, B) {\n          var u = this.rgba,\n            v = a.rgba;\n          if (!x(u[0]) || !x(v[0])) return a.input || \"none\";\n          a = 1 !== v[3] || 1 !== u[3];\n          return (a ? \"rgba(\" : \"rgb(\") + Math.round(v[0] + (u[0] - v[0]) * (1 - B)) + \",\" + Math.round(v[1] + (u[1] - v[1]) * (1 - B)) + \",\" + Math.round(v[2] + (u[2] - v[2]) * (1 - B)) + (a ? \",\" + (v[3] + (u[3] - v[3]) * (1 - B)) : \"\") + \")\";\n        }\n      }]);\n      return z;\n    }();\n    z.names = {\n      white: \"#ffffff\",\n      black: \"#000000\"\n    };\n    z.parsers = [{\n      regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n      parse: function parse(a) {\n        return [C(a[1]), C(a[2]), C(a[3]), parseFloat(a[4], 10)];\n      }\n    }, {\n      regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n      parse: function parse(a) {\n        return [C(a[1]), C(a[2]), C(a[3]), 1];\n      }\n    }];\n    z.None = new z(\"\");\n    \"\";\n    return z;\n  });\n  M(a, \"Core/Color/Palettes.js\", [], function () {\n    return {\n      colors: \"#2caffe #544fc5 #00e272 #fe6a35 #6b8abc #d568fb #2ee0ca #fa4b42 #feb56a #91e8e1\".split(\" \")\n    };\n  });\n  M(a, \"Core/Time.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    var x = a.win,\n      L = y.defined,\n      C = y.error,\n      z = y.extend,\n      H = y.isObject,\n      B = y.merge,\n      u = y.objectEach,\n      v = y.pad,\n      l = y.pick,\n      p = y.splat,\n      t = y.timeUnits,\n      m = a.isSafari && x.Intl && x.Intl.DateTimeFormat.prototype.formatRange,\n      h = a.isSafari && x.Intl && !x.Intl.DateTimeFormat.prototype.formatRange;\n    var g = /*#__PURE__*/function () {\n      function g(e) {\n        _classCallCheck(this, g);\n        this.options = {};\n        this.variableTimezone = this.useUTC = !1;\n        this.Date = x.Date;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.update(e);\n      }\n      _createClass(g, [{\n        key: \"get\",\n        value: function get(e, g) {\n          if (this.variableTimezone || this.timezoneOffset) {\n            var _h = g.getTime(),\n              _m = _h - this.getTimezoneOffset(g);\n            g.setTime(_m);\n            e = g[\"getUTC\" + e]();\n            g.setTime(_h);\n            return e;\n          }\n          return this.useUTC ? g[\"getUTC\" + e]() : g[\"get\" + e]();\n        }\n      }, {\n        key: \"set\",\n        value: function set(e, g, h) {\n          if (this.variableTimezone || this.timezoneOffset) {\n            if (\"Milliseconds\" === e || \"Seconds\" === e || \"Minutes\" === e && 0 === this.getTimezoneOffset(g) % 36E5) return g[\"setUTC\" + e](h);\n            var w = this.getTimezoneOffset(g);\n            w = g.getTime() - w;\n            g.setTime(w);\n            g[\"setUTC\" + e](h);\n            e = this.getTimezoneOffset(g);\n            w = g.getTime() + e;\n            return g.setTime(w);\n          }\n          return this.useUTC || m && \"FullYear\" === e ? g[\"setUTC\" + e](h) : g[\"set\" + e](h);\n        }\n      }, {\n        key: \"update\",\n        value: function update() {\n          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var g = l(e.useUTC, !0);\n          this.options = e = B(!0, this.options, e);\n          this.Date = e.Date || x.Date || Date;\n          this.timezoneOffset = (this.useUTC = g) && e.timezoneOffset || void 0;\n          this.getTimezoneOffset = this.timezoneOffsetFunction();\n          this.variableTimezone = g && !(!e.getTimezoneOffset && !e.timezone);\n        }\n      }, {\n        key: \"makeTime\",\n        value: function makeTime(e, g, m, p, d, k) {\n          var r, q, w;\n          this.useUTC ? (r = this.Date.UTC.apply(0, arguments), q = this.getTimezoneOffset(r), r += q, w = this.getTimezoneOffset(r), q !== w ? r += w - q : q - 36E5 !== this.getTimezoneOffset(r - 36E5) || h || (r -= 36E5)) : r = new this.Date(e, g, l(m, 1), l(p, 0), l(d, 0), l(k, 0)).getTime();\n          return r;\n        }\n      }, {\n        key: \"timezoneOffsetFunction\",\n        value: function timezoneOffsetFunction() {\n          var e = this,\n            g = this.options,\n            h = g.getTimezoneOffset,\n            m = g.moment || x.moment;\n          if (!this.useUTC) return function (d) {\n            return 6E4 * new Date(d.toString()).getTimezoneOffset();\n          };\n          if (g.timezone) {\n            if (m) return function (d) {\n              return 6E4 * -m.tz(d, g.timezone).utcOffset();\n            };\n            C(25);\n          }\n          return this.useUTC && h ? function (d) {\n            return 6E4 * h(d.valueOf());\n          } : function () {\n            return 6E4 * (e.timezoneOffset || 0);\n          };\n        }\n      }, {\n        key: \"dateFormat\",\n        value: function dateFormat(e, g, h) {\n          if (!L(g) || isNaN(g)) return a.defaultOptions.lang && a.defaultOptions.lang.invalidDate || \"\";\n          e = l(e, \"%Y-%m-%d %H:%M:%S\");\n          var m = this;\n          var d = new this.Date(g);\n          var k = this.get(\"Hours\", d),\n            r = this.get(\"Day\", d),\n            q = this.get(\"Date\", d),\n            w = this.get(\"Month\", d),\n            b = this.get(\"FullYear\", d),\n            f = a.defaultOptions.lang,\n            c = f && f.weekdays,\n            n = f && f.shortWeekdays;\n          d = z({\n            a: n ? n[r] : c[r].substr(0, 3),\n            A: c[r],\n            d: v(q),\n            e: v(q, 2, \" \"),\n            w: r,\n            b: f.shortMonths[w],\n            B: f.months[w],\n            m: v(w + 1),\n            o: w + 1,\n            y: b.toString().substr(2, 2),\n            Y: b,\n            H: v(k),\n            k: k,\n            I: v(k % 12 || 12),\n            l: k % 12 || 12,\n            M: v(this.get(\"Minutes\", d)),\n            p: 12 > k ? \"AM\" : \"PM\",\n            P: 12 > k ? \"am\" : \"pm\",\n            S: v(d.getSeconds()),\n            L: v(Math.floor(g % 1E3), 3)\n          }, a.dateFormats);\n          u(d, function (b, c) {\n            for (; -1 !== e.indexOf(\"%\" + c);) e = e.replace(\"%\" + c, \"function\" === typeof b ? b.call(m, g) : b);\n          });\n          return h ? e.substr(0, 1).toUpperCase() + e.substr(1) : e;\n        }\n      }, {\n        key: \"resolveDTLFormat\",\n        value: function resolveDTLFormat(e) {\n          return H(e, !0) ? e : (e = p(e), {\n            main: e[0],\n            from: e[1],\n            to: e[2]\n          });\n        }\n      }, {\n        key: \"getTimeTicks\",\n        value: function getTimeTicks(e, g, h, m) {\n          var d = this,\n            k = [],\n            r = {};\n          var q = new d.Date(g);\n          var w = e.unitRange,\n            b = e.count || 1;\n          var f;\n          m = l(m, 1);\n          if (L(g)) {\n            d.set(\"Milliseconds\", q, w >= t.second ? 0 : b * Math.floor(d.get(\"Milliseconds\", q) / b));\n            w >= t.second && d.set(\"Seconds\", q, w >= t.minute ? 0 : b * Math.floor(d.get(\"Seconds\", q) / b));\n            w >= t.minute && d.set(\"Minutes\", q, w >= t.hour ? 0 : b * Math.floor(d.get(\"Minutes\", q) / b));\n            w >= t.hour && d.set(\"Hours\", q, w >= t.day ? 0 : b * Math.floor(d.get(\"Hours\", q) / b));\n            w >= t.day && d.set(\"Date\", q, w >= t.month ? 1 : Math.max(1, b * Math.floor(d.get(\"Date\", q) / b)));\n            if (w >= t.month) {\n              d.set(\"Month\", q, w >= t.year ? 0 : b * Math.floor(d.get(\"Month\", q) / b));\n              var c = d.get(\"FullYear\", q);\n            }\n            w >= t.year && d.set(\"FullYear\", q, c - c % b);\n            w === t.week && (c = d.get(\"Day\", q), d.set(\"Date\", q, d.get(\"Date\", q) - c + m + (c < m ? -7 : 0)));\n            c = d.get(\"FullYear\", q);\n            m = d.get(\"Month\", q);\n            var n = d.get(\"Date\", q),\n              _e = d.get(\"Hours\", q);\n            g = q.getTime();\n            !d.variableTimezone && d.useUTC || !L(h) || (f = h - g > 4 * t.month || d.getTimezoneOffset(g) !== d.getTimezoneOffset(h));\n            g = q.getTime();\n            for (q = 1; g < h;) k.push(g), g = w === t.year ? d.makeTime(c + q * b, 0) : w === t.month ? d.makeTime(c, m + q * b) : !f || w !== t.day && w !== t.week ? f && w === t.hour && 1 < b ? d.makeTime(c, m, n, _e + q * b) : g + w * b : d.makeTime(c, m, n + q * b * (w === t.day ? 1 : 7)), q++;\n            k.push(g);\n            w <= t.hour && 1E4 > k.length && k.forEach(function (b) {\n              0 === b % 18E5 && \"000000000\" === d.dateFormat(\"%H%M%S%L\", b) && (r[b] = \"day\");\n            });\n          }\n          k.info = z(e, {\n            higherRanks: r,\n            totalRange: w * b\n          });\n          return k;\n        }\n      }, {\n        key: \"getDateFormat\",\n        value: function getDateFormat(e, g, h, m) {\n          var d = this.dateFormat(\"%m-%d %H:%M:%S.%L\", g),\n            k = {\n              millisecond: 15,\n              second: 12,\n              minute: 9,\n              hour: 6,\n              day: 3\n            };\n          var r,\n            q = \"millisecond\";\n          for (r in t) {\n            if (e === t.week && +this.dateFormat(\"%w\", g) === h && \"00:00:00.000\" === d.substr(6)) {\n              r = \"week\";\n              break;\n            }\n            if (t[r] > e) {\n              r = q;\n              break;\n            }\n            if (k[r] && d.substr(k[r]) !== \"01-01 00:00:00.000\".substr(k[r])) break;\n            \"week\" !== r && (q = r);\n          }\n          return this.resolveDTLFormat(m[r]).main;\n        }\n      }]);\n      return g;\n    }();\n    \"\";\n    return g;\n  });\n  M(a, \"Core/Defaults.js\", [a[\"Core/Chart/ChartDefaults.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Color/Palettes.js\"], a[\"Core/Time.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z) {\n    var x = I.isTouchDevice,\n      B = I.svg,\n      u = z.merge,\n      v = {\n        colors: L.colors,\n        symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n        lang: {\n          loading: \"Loading...\",\n          months: \"January February March April May June July August September October November December\".split(\" \"),\n          shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n          weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n          decimalPoint: \".\",\n          numericSymbols: \"kMGTPE\".split(\"\"),\n          resetZoom: \"Reset zoom\",\n          resetZoomTitle: \"Reset zoom level 1:1\",\n          thousandsSep: \" \"\n        },\n        global: {},\n        time: {\n          Date: void 0,\n          getTimezoneOffset: void 0,\n          timezone: void 0,\n          timezoneOffset: 0,\n          useUTC: !0\n        },\n        chart: a,\n        title: {\n          style: {\n            color: \"#333333\",\n            fontWeight: \"bold\"\n          },\n          text: \"Chart title\",\n          align: \"center\",\n          margin: 15,\n          widthAdjust: -44\n        },\n        subtitle: {\n          style: {\n            color: \"#666666\",\n            fontSize: \"0.8em\"\n          },\n          text: \"\",\n          align: \"center\",\n          widthAdjust: -44\n        },\n        caption: {\n          margin: 15,\n          style: {\n            color: \"#666666\",\n            fontSize: \"0.8em\"\n          },\n          text: \"\",\n          align: \"left\",\n          verticalAlign: \"bottom\"\n        },\n        plotOptions: {},\n        legend: {\n          enabled: !0,\n          align: \"center\",\n          alignColumns: !0,\n          className: \"highcharts-no-tooltip\",\n          layout: \"horizontal\",\n          itemMarginBottom: 2,\n          itemMarginTop: 2,\n          labelFormatter: function labelFormatter() {\n            return this.name;\n          },\n          borderColor: \"#999999\",\n          borderRadius: 0,\n          navigation: {\n            style: {\n              fontSize: \"0.8em\"\n            },\n            activeColor: \"#0022ff\",\n            inactiveColor: \"#cccccc\"\n          },\n          itemStyle: {\n            color: \"#333333\",\n            cursor: \"pointer\",\n            fontSize: \"0.8em\",\n            textDecoration: \"none\",\n            textOverflow: \"ellipsis\"\n          },\n          itemHoverStyle: {\n            color: \"#000000\"\n          },\n          itemHiddenStyle: {\n            color: \"#666666\",\n            textDecoration: \"line-through\"\n          },\n          shadow: !1,\n          itemCheckboxStyle: {\n            position: \"absolute\",\n            width: \"13px\",\n            height: \"13px\"\n          },\n          squareSymbol: !0,\n          symbolPadding: 5,\n          verticalAlign: \"bottom\",\n          x: 0,\n          y: 0,\n          title: {\n            style: {\n              fontSize: \"0.8em\",\n              fontWeight: \"bold\"\n            }\n          }\n        },\n        loading: {\n          labelStyle: {\n            fontWeight: \"bold\",\n            position: \"relative\",\n            top: \"45%\"\n          },\n          style: {\n            position: \"absolute\",\n            backgroundColor: \"#ffffff\",\n            opacity: .5,\n            textAlign: \"center\"\n          }\n        },\n        tooltip: {\n          enabled: !0,\n          animation: B,\n          borderRadius: 3,\n          dateTimeLabelFormats: {\n            millisecond: \"%A, %e %b, %H:%M:%S.%L\",\n            second: \"%A, %e %b, %H:%M:%S\",\n            minute: \"%A, %e %b, %H:%M\",\n            hour: \"%A, %e %b, %H:%M\",\n            day: \"%A, %e %b %Y\",\n            week: \"Week from %A, %e %b %Y\",\n            month: \"%B %Y\",\n            year: \"%Y\"\n          },\n          footerFormat: \"\",\n          headerShape: \"callout\",\n          hideDelay: 500,\n          padding: 8,\n          shape: \"callout\",\n          shared: !1,\n          snap: x ? 25 : 10,\n          headerFormat: '<span style=\"font-size: 0.8em\">{point.key}</span><br/>',\n          pointFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> {series.name}: <b>{point.y}</b><br/>\",\n          backgroundColor: \"#ffffff\",\n          borderWidth: void 0,\n          shadow: !0,\n          stickOnContact: !1,\n          style: {\n            color: \"#333333\",\n            cursor: \"default\",\n            fontSize: \"0.8em\"\n          },\n          useHTML: !1\n        },\n        credits: {\n          enabled: !0,\n          href: \"https://www.highcharts.com?credits\",\n          position: {\n            align: \"right\",\n            x: -10,\n            verticalAlign: \"bottom\",\n            y: -5\n          },\n          style: {\n            cursor: \"pointer\",\n            color: \"#999999\",\n            fontSize: \"0.6em\"\n          },\n          text: \"Highcharts.com\"\n        }\n      };\n    v.chart.styledMode = !1;\n    \"\";\n    var l = new C(v.time);\n    a = {\n      defaultOptions: v,\n      defaultTime: l,\n      getOptions: function getOptions() {\n        return v;\n      },\n      setOptions: function setOptions(a) {\n        u(!0, v, a);\n        if (a.time || a.global) I.time ? I.time.update(u(v.global, v.time, a.global, a.time)) : I.time = l;\n        return v;\n      }\n    };\n    \"\";\n    return a;\n  });\n  M(a, \"Core/Animation/Fx.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    var x = a.parse,\n      C = y.win,\n      z = I.isNumber,\n      H = I.objectEach;\n    var B = /*#__PURE__*/function () {\n      function B(a, v, l) {\n        _classCallCheck(this, B);\n        this.pos = NaN;\n        this.options = v;\n        this.elem = a;\n        this.prop = l;\n      }\n      _createClass(B, [{\n        key: \"dSetter\",\n        value: function dSetter() {\n          var a = this.paths;\n          var v = a && a[0];\n          a = a && a[1];\n          var l = this.now || 0;\n          var p = [];\n          if (1 !== l && v && a) {\n            if (v.length === a.length && 1 > l) for (var t = 0; t < a.length; t++) {\n              var m = v[t],\n                h = a[t],\n                g = [];\n              for (var e = 0; e < h.length; e++) {\n                var w = m[e],\n                  _a = h[e];\n                z(w) && z(_a) && (\"A\" !== h[0] || 4 !== e && 5 !== e) ? g[e] = w + l * (_a - w) : g[e] = _a;\n              }\n              p.push(g);\n            } else p = a;\n          } else p = this.toD || [];\n          this.elem.attr(\"d\", p, void 0, !0);\n        }\n      }, {\n        key: \"update\",\n        value: function update() {\n          var a = this.elem,\n            v = this.prop,\n            l = this.now,\n            p = this.options.step;\n          if (this[v + \"Setter\"]) this[v + \"Setter\"]();else a.attr ? a.element && a.attr(v, l, null, !0) : a.style[v] = l + this.unit;\n          p && p.call(a, l, this);\n        }\n      }, {\n        key: \"run\",\n        value: function run(a, v, l) {\n          var p = this,\n            t = p.options,\n            m = function m(e) {\n              return m.stopped ? !1 : p.step(e);\n            },\n            h = C.requestAnimationFrame || function (e) {\n              setTimeout(e, 13);\n            },\n            g = function g() {\n              for (var e = 0; e < B.timers.length; e++) B.timers[e]() || B.timers.splice(e--, 1);\n              B.timers.length && h(g);\n            };\n          a !== v || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = a, this.end = v, this.unit = l, this.now = this.start, this.pos = 0, m.elem = this.elem, m.prop = this.prop, m() && 1 === B.timers.push(m) && h(g)) : (delete t.curAnim[this.prop], t.complete && 0 === Object.keys(t.curAnim).length && t.complete.call(this.elem));\n        }\n      }, {\n        key: \"step\",\n        value: function step(a) {\n          var v = +new Date(),\n            l = this.options,\n            p = this.elem,\n            t = l.complete,\n            m = l.duration,\n            h = l.curAnim;\n          var g;\n          p.attr && !p.element ? a = !1 : a || v >= m + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), g = h[this.prop] = !0, H(h, function (e) {\n            !0 !== e && (g = !1);\n          }), g && t && t.call(p), a = !1) : (this.pos = l.easing((v - this.startTime) / m), this.now = this.start + (this.end - this.start) * this.pos, this.update(), a = !0);\n          return a;\n        }\n      }, {\n        key: \"initPath\",\n        value: function initPath(a, v, l) {\n          function p(d, k) {\n            for (; d.length < E;) {\n              var r = d[0];\n              var q = k[E - d.length];\n              q && \"M\" === r[0] && (d[0] = \"C\" === q[0] ? [\"C\", r[1], r[2], r[1], r[2], r[1], r[2]] : [\"L\", r[1], r[2]]);\n              d.unshift(r);\n              g && (r = d.pop(), d.push(d[d.length - 1], r));\n            }\n          }\n          function t(d, k) {\n            for (; d.length < E;) if (k = d[Math.floor(d.length / e) - 1].slice(), \"C\" === k[0] && (k[1] = k[5], k[2] = k[6]), g) {\n              var r = d[Math.floor(d.length / e)].slice();\n              d.splice(d.length / 2, 0, k, r);\n            } else d.push(k);\n          }\n          var m = a.startX,\n            h = a.endX;\n          l = l.slice();\n          var g = a.isArea,\n            e = g ? 2 : 1;\n          var w, E, F;\n          v = v && v.slice();\n          if (!v) return [l, l];\n          if (m && h && h.length) {\n            for (a = 0; a < m.length; a++) if (m[a] === h[0]) {\n              w = a;\n              break;\n            } else if (m[0] === h[h.length - m.length + a]) {\n              w = a;\n              F = !0;\n              break;\n            } else if (m[m.length - 1] === h[h.length - m.length + a]) {\n              w = m.length - a;\n              break;\n            }\n            \"undefined\" === typeof w && (v = []);\n          }\n          v.length && z(w) && (E = l.length + w * e, F ? (p(v, l), t(l, v)) : (p(l, v), t(v, l)));\n          return [v, l];\n        }\n      }, {\n        key: \"fillSetter\",\n        value: function fillSetter() {\n          B.prototype.strokeSetter.apply(this, arguments);\n        }\n      }, {\n        key: \"strokeSetter\",\n        value: function strokeSetter() {\n          this.elem.attr(this.prop, x(this.start).tweenTo(x(this.end), this.pos), void 0, !0);\n        }\n      }]);\n      return B;\n    }();\n    B.timers = [];\n    return B;\n  });\n  M(a, \"Core/Animation/AnimationUtilities.js\", [a[\"Core/Animation/Fx.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    function x(a) {\n      return u(a) ? v({\n        duration: 500,\n        defer: 0\n      }, a) : {\n        duration: a ? 500 : 0,\n        defer: 0\n      };\n    }\n    function L(l, m) {\n      var h = a.timers.length;\n      for (; h--;) a.timers[h].elem !== l || m && m !== a.timers[h].prop || (a.timers[h].stopped = !0);\n    }\n    var C = y.defined,\n      z = y.getStyle,\n      H = y.isArray,\n      B = y.isNumber,\n      u = y.isObject,\n      v = y.merge,\n      l = y.objectEach,\n      p = y.pick;\n    return {\n      animate: function animate(p, m, h) {\n        var g,\n          e = \"\",\n          w,\n          E,\n          F;\n        u(h) || (F = arguments, h = {\n          duration: F[2],\n          easing: F[3],\n          complete: F[4]\n        });\n        B(h.duration) || (h.duration = 400);\n        h.easing = \"function\" === typeof h.easing ? h.easing : Math[h.easing] || Math.easeInOutSine;\n        h.curAnim = v(m);\n        l(m, function (d, k) {\n          L(p, k);\n          E = new a(p, h, k);\n          w = void 0;\n          \"d\" === k && H(m.d) ? (E.paths = E.initPath(p, p.pathArray, m.d), E.toD = m.d, g = 0, w = 1) : p.attr ? g = p.attr(k) : (g = parseFloat(z(p, k)) || 0, \"opacity\" !== k && (e = \"px\"));\n          w || (w = d);\n          \"string\" === typeof w && w.match(\"px\") && (w = w.replace(/px/g, \"\"));\n          E.run(g, w, e);\n        });\n      },\n      animObject: x,\n      getDeferredAnimation: function getDeferredAnimation(a, m, h) {\n        var g = x(m);\n        var e = 0,\n          w = 0;\n        (h ? [h] : a.series).forEach(function (h) {\n          h = x(h.options.animation);\n          e = m && C(m.defer) ? g.defer : Math.max(e, h.duration + h.defer);\n          w = Math.min(g.duration, h.duration);\n        });\n        a.renderer.forExport && (e = 0);\n        return {\n          defer: Math.max(0, e - w),\n          duration: Math.min(e, w)\n        };\n      },\n      setAnimation: function setAnimation(a, m) {\n        m.renderer.globalAnimation = p(a, m.options.chart.animation, !0);\n      },\n      stop: L\n    };\n  });\n  M(a, \"Core/Renderer/HTML/AST.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    var x = a.SVG_NS,\n      L = a.win,\n      _y = y,\n      C = _y.attr,\n      z = _y.createElement,\n      H = _y.css,\n      B = _y.error,\n      u = _y.isFunction,\n      v = _y.isString,\n      l = _y.objectEach,\n      p = _y.splat;\n    y = L.trustedTypes;\n    var t = y && u(y.createPolicy) && y.createPolicy(\"highcharts\", {\n      createHTML: function createHTML(e) {\n        return e;\n      }\n    });\n    y = t ? t.createHTML(\"\") : \"\";\n    try {\n      var m = !!new DOMParser().parseFromString(y, \"text/html\");\n    } catch (e) {\n      m = !1;\n    }\n    var h = m;\n    var g = /*#__PURE__*/function () {\n      _createClass(g, null, [{\n        key: \"filterUserAttributes\",\n        value: function filterUserAttributes(e) {\n          l(e, function (h, m) {\n            var a = !0;\n            -1 === g.allowedAttributes.indexOf(m) && (a = !1);\n            -1 !== [\"background\", \"dynsrc\", \"href\", \"lowsrc\", \"src\"].indexOf(m) && (a = v(h) && g.allowedReferences.some(function (d) {\n              return 0 === h.indexOf(d);\n            }));\n            a || (B(33, !1, void 0, {\n              \"Invalid attribute in config\": \"\".concat(m)\n            }), delete e[m]);\n            v(h) && e[m] && (e[m] = h.replace(/</g, \"&lt;\"));\n          });\n          return e;\n        }\n      }, {\n        key: \"parseStyle\",\n        value: function parseStyle(e) {\n          return e.split(\";\").reduce(function (e, g) {\n            g = g.split(\":\").map(function (d) {\n              return d.trim();\n            });\n            var h = g.shift();\n            h && g.length && (e[h.replace(/-([a-z])/g, function (d) {\n              return d[1].toUpperCase();\n            })] = g.join(\":\"));\n            return e;\n          }, {});\n        }\n      }, {\n        key: \"setElementHTML\",\n        value: function setElementHTML(e, h) {\n          e.innerHTML = g.emptyHTML;\n          h && new g(h).addToDOM(e);\n        }\n      }]);\n      function g(e) {\n        _classCallCheck(this, g);\n        this.nodes = \"string\" === typeof e ? this.parseMarkup(e) : e;\n      }\n      _createClass(g, [{\n        key: \"addToDOM\",\n        value: function addToDOM(e) {\n          function h(e, m) {\n            var d;\n            p(e).forEach(function (k) {\n              var e = k.tagName;\n              var q = k.textContent ? a.doc.createTextNode(k.textContent) : void 0,\n                w = g.bypassHTMLFiltering;\n              var b;\n              if (e) if (\"#text\" === e) b = q;else if (-1 !== g.allowedTags.indexOf(e) || w) {\n                e = a.doc.createElementNS(\"svg\" === e ? x : m.namespaceURI || x, e);\n                var f = k.attributes || {};\n                l(k, function (b, d) {\n                  \"tagName\" !== d && \"attributes\" !== d && \"children\" !== d && \"style\" !== d && \"textContent\" !== d && (f[d] = b);\n                });\n                C(e, w ? f : g.filterUserAttributes(f));\n                k.style && H(e, k.style);\n                q && e.appendChild(q);\n                h(k.children || [], e);\n                b = e;\n              } else B(33, !1, void 0, {\n                \"Invalid tagName in config\": e\n              });\n              b && m.appendChild(b);\n              d = b;\n            });\n            return d;\n          }\n          return h(this.nodes, e);\n        }\n      }, {\n        key: \"parseMarkup\",\n        value: function parseMarkup(e) {\n          var m = [];\n          e = e.trim().replace(/ style=([\"'])/g, \" data-style=$1\");\n          if (h) e = new DOMParser().parseFromString(t ? t.createHTML(e) : e, \"text/html\");else {\n            var _g = z(\"div\");\n            _g.innerHTML = e;\n            e = {\n              body: _g\n            };\n          }\n          var a = function a(e, d) {\n            var k = e.nodeName.toLowerCase();\n            var r = {\n              tagName: k\n            };\n            \"#text\" === k && (r.textContent = e.textContent || \"\");\n            if (k = e.attributes) {\n              var _d2 = {};\n              [].forEach.call(k, function (k) {\n                \"data-style\" === k.name ? r.style = g.parseStyle(k.value) : _d2[k.name] = k.value;\n              });\n              r.attributes = _d2;\n            }\n            if (e.childNodes.length) {\n              var _d3 = [];\n              [].forEach.call(e.childNodes, function (k) {\n                a(k, _d3);\n              });\n              _d3.length && (r.children = _d3);\n            }\n            d.push(r);\n          };\n          [].forEach.call(e.body.childNodes, function (e) {\n            return a(e, m);\n          });\n          return m;\n        }\n      }]);\n      return g;\n    }();\n    g.allowedAttributes = \"alt aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill flood-color flood-opacity height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align text-anchor textAnchor textLength title type valign width x x1 x2 xlink:href y y1 y2 zIndex\".split(\" \");\n    g.allowedReferences = \"https:// http:// mailto: / ../ ./ #\".split(\" \");\n    g.allowedTags = \"a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feDropShadow feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text textPath thead title tbody tspan td th tr u ul #text\".split(\" \");\n    g.emptyHTML = y;\n    g.bypassHTMLFiltering = !1;\n    \"\";\n    return g;\n  });\n  M(a, \"Core/Templating.js\", [a[\"Core/Defaults.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    function x() {\n      var h = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      var g = arguments.length > 1 ? arguments[1] : undefined;\n      var e = arguments.length > 2 ? arguments[2] : undefined;\n      var a = /\\{([a-zA-Z0-9:\\.,;\\-\\/<>%_@\"'= #\\(\\)]+)\\}/g,\n        l = /\\(([a-zA-Z0-9:\\.,;\\-\\/<>%_@\"'= ]+)\\)/g,\n        v = [],\n        d = /f$/,\n        k = /\\.([0-9])/,\n        r = C.lang,\n        q = e && e.time || z,\n        G = e && e.numberFormatter || L,\n        b = function b() {\n          var b = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n          var c;\n          return \"true\" === b ? !0 : \"false\" === b ? !1 : (c = Number(b)).toString() === b ? c : B(b, g);\n        };\n      var f,\n        c,\n        n = 0,\n        P;\n      for (; null !== (f = a.exec(h));) {\n        var _b4 = l.exec(f[1]);\n        _b4 && (f = _b4, P = !0);\n        c && c.isBlock || (c = {\n          ctx: g,\n          expression: f[1],\n          find: f[0],\n          isBlock: \"#\" === f[1].charAt(0),\n          start: f.index,\n          startInner: f.index + f[0].length,\n          length: f[0].length\n        });\n        var D = f[1].split(\" \")[0].replace(\"#\", \"\");\n        m[D] && (c.isBlock && D === c.fn && n++, c.fn || (c.fn = D));\n        D = \"else\" === f[1];\n        if (c.isBlock && c.fn && (f[1] === \"/\".concat(c.fn) || D)) {\n          if (n) D || n--;else {\n            var K = c.startInner;\n            K = h.substr(K, f.index - K);\n            void 0 === c.body ? (c.body = K, c.startInner = f.index + f[0].length) : c.elseBody = K;\n            c.find += K + f[0];\n            D || (v.push(c), c = void 0);\n          }\n        } else c.isBlock || v.push(c);\n        if (_b4 && (null === c || void 0 === c || !c.isBlock)) break;\n      }\n      v.forEach(function (c) {\n        var f = c.body,\n          n = c.elseBody,\n          K = c.expression,\n          e = c.fn;\n        var A;\n        if (e) {\n          var a = [c],\n            w = K.split(\" \");\n          for (A = m[e].length; A--;) a.unshift(b(w[A + 1]));\n          A = m[e].apply(g, a);\n          c.isBlock && \"boolean\" === typeof A && (A = x(A ? f : n, g));\n        } else a = K.split(\":\"), A = b(a.shift() || \"\"), a.length && \"number\" === typeof A && (a = a.join(\":\"), d.test(a) ? (w = parseInt((a.match(k) || [\"\", \"-1\"])[1], 10), null !== A && (A = G(A, w, r.decimalPoint, -1 < a.indexOf(\",\") ? r.thousandsSep : \"\"))) : A = q.dateFormat(a, A));\n        h = h.replace(c.find, p(A, \"\"));\n      });\n      return P ? x(h, g, e) : h;\n    }\n    function L(h, g, e, a) {\n      h = +h || 0;\n      g = +g;\n      var m = C.lang;\n      var w = (h.toString().split(\".\")[1] || \"\").split(\"e\")[0].length;\n      var d = h.toString().split(\"e\"),\n        k = g;\n      if (-1 === g) g = Math.min(w, 20);else if (!v(g)) g = 2;else if (g && d[1] && 0 > d[1]) {\n        var r = g + +d[1];\n        0 <= r ? (d[0] = (+d[0]).toExponential(r).split(\"e\")[0], g = r) : (d[0] = d[0].split(\".\")[0] || 0, h = 20 > g ? (d[0] * Math.pow(10, d[1])).toFixed(g) : 0, d[1] = 0);\n      }\n      r = (Math.abs(d[1] ? d[0] : h) + Math.pow(10, -Math.max(g, w) - 1)).toFixed(g);\n      w = String(t(r));\n      var q = 3 < w.length ? w.length % 3 : 0;\n      e = p(e, m.decimalPoint);\n      a = p(a, m.thousandsSep);\n      h = (0 > h ? \"-\" : \"\") + (q ? w.substr(0, q) + a : \"\");\n      h = 0 > +d[1] && !k ? \"0\" : h + w.substr(q).replace(/(\\d{3})(?=\\d)/g, \"$1\" + a);\n      g && (h += e + r.slice(-g));\n      d[1] && 0 !== +h && (h += \"e\" + d[1]);\n      return h;\n    }\n    var C = a.defaultOptions,\n      z = a.defaultTime,\n      H = y.extend,\n      B = y.getNestedProperty,\n      u = y.isArray,\n      v = y.isNumber,\n      l = y.isObject,\n      p = y.pick,\n      t = y.pInt,\n      m = {\n        add: function add(h, g) {\n          return h + g;\n        },\n        divide: function divide(h, g) {\n          return 0 !== g ? h / g : \"\";\n        },\n        eq: function eq(h, g) {\n          return h == g;\n        },\n        each: function each(h) {\n          var g = arguments[arguments.length - 1];\n          return u(h) ? h.map(function (e, a) {\n            return x(g.body, H(l(e) ? e : {\n              \"@this\": e\n            }, {\n              \"@index\": a,\n              \"@first\": 0 === a,\n              \"@last\": a === h.length - 1\n            }));\n          }).join(\"\") : !1;\n        },\n        ge: function ge(h, g) {\n          return h >= g;\n        },\n        gt: function gt(h, g) {\n          return h > g;\n        },\n        \"if\": function _if(h) {\n          return !!h;\n        },\n        le: function le(h, g) {\n          return h <= g;\n        },\n        lt: function lt(h, g) {\n          return h < g;\n        },\n        multiply: function multiply(h, g) {\n          return h * g;\n        },\n        ne: function ne(h, g) {\n          return h != g;\n        },\n        subtract: function subtract(h, g) {\n          return h - g;\n        },\n        unless: function unless(h) {\n          return !h;\n        }\n      };\n    return {\n      dateFormat: function dateFormat(h, g, e) {\n        return z.dateFormat(h, g, e);\n      },\n      format: x,\n      helpers: m,\n      numberFormat: L\n    };\n  });\n  M(a, \"Core/Renderer/RendererUtilities.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    var x = a.clamp,\n      I = a.pick,\n      L = a.stableSort;\n    var C;\n    (function (a) {\n      function y(a, u, v) {\n        var l = a;\n        var p = l.reducedLen || u,\n          t = function t(e, g) {\n            return (g.rank || 0) - (e.rank || 0);\n          };\n        var m = function m(e, g) {\n          return e.target - g.target;\n        };\n        var h,\n          g = !0,\n          e = [],\n          w = 0;\n        for (h = a.length; h--;) w += a[h].size;\n        if (w > p) {\n          L(a, t);\n          for (w = h = 0; w <= p;) w += a[h].size, h++;\n          e = a.splice(h - 1, a.length);\n        }\n        L(a, m);\n        for (a = a.map(function (e) {\n          return {\n            size: e.size,\n            targets: [e.target],\n            align: I(e.align, .5)\n          };\n        }); g;) {\n          for (h = a.length; h--;) p = a[h], t = (Math.min.apply(0, p.targets) + Math.max.apply(0, p.targets)) / 2, p.pos = x(t - p.size * p.align, 0, u - p.size);\n          h = a.length;\n          for (g = !1; h--;) 0 < h && a[h - 1].pos + a[h - 1].size > a[h].pos && (a[h - 1].size += a[h].size, a[h - 1].targets = a[h - 1].targets.concat(a[h].targets), a[h - 1].align = .5, a[h - 1].pos + a[h - 1].size > u && (a[h - 1].pos = u - a[h - 1].size), a.splice(h, 1), g = !0);\n        }\n        l.push.apply(l, e);\n        h = 0;\n        a.some(function (e) {\n          var g = 0;\n          return (e.targets || []).some(function () {\n            l[h].pos = e.pos + g;\n            if (\"undefined\" !== typeof v && Math.abs(l[h].pos - l[h].target) > v) return l.slice(0, h + 1).forEach(function (d) {\n              return delete d.pos;\n            }), l.reducedLen = (l.reducedLen || u) - .1 * u, l.reducedLen > .1 * u && y(l, u, v), !0;\n            g += l[h].size;\n            h++;\n            return !1;\n          });\n        });\n        L(l, m);\n        return l;\n      }\n      a.distribute = y;\n    })(C || (C = {}));\n    return C;\n  });\n  M(a, \"Core/Renderer/SVG/SVGElement.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L) {\n    var x = a.animate,\n      z = a.animObject,\n      H = a.stop,\n      B = I.deg2rad,\n      u = I.doc,\n      v = I.svg,\n      l = I.SVG_NS,\n      p = I.win,\n      t = L.addEvent,\n      m = L.attr,\n      h = L.createElement,\n      g = L.css,\n      e = L.defined,\n      w = L.erase,\n      E = L.extend,\n      F = L.fireEvent,\n      d = L.isArray,\n      k = L.isFunction,\n      r = L.isObject,\n      q = L.isString,\n      G = L.merge,\n      b = L.objectEach,\n      f = L.pick,\n      c = L.pInt,\n      n = L.syncTimeout,\n      P = L.uniqueKey;\n    var D = /*#__PURE__*/function () {\n      function D() {\n        _classCallCheck(this, D);\n        this.element = void 0;\n        this.onEvents = {};\n        this.opacity = 1;\n        this.renderer = void 0;\n        this.SVG_NS = l;\n      }\n      _createClass(D, [{\n        key: \"_defaultGetter\",\n        value: function _defaultGetter(b) {\n          b = f(this[b + \"Value\"], this[b], this.element ? this.element.getAttribute(b) : null, 0);\n          /^[\\-0-9\\.]+$/.test(b) && (b = parseFloat(b));\n          return b;\n        }\n      }, {\n        key: \"_defaultSetter\",\n        value: function _defaultSetter(b, c, f) {\n          f.setAttribute(c, b);\n        }\n      }, {\n        key: \"add\",\n        value: function add(b) {\n          var c = this.renderer,\n            f = this.element;\n          var d;\n          b && (this.parentGroup = b);\n          \"undefined\" !== typeof this.textStr && \"text\" === this.element.nodeName && c.buildText(this);\n          this.added = !0;\n          if (!b || b.handleZ || this.zIndex) d = this.zIndexSetter();\n          d || (b ? b.element : c.box).appendChild(f);\n          if (this.onAdd) this.onAdd();\n          return this;\n        }\n      }, {\n        key: \"addClass\",\n        value: function addClass(b, c) {\n          var f = c ? \"\" : this.attr(\"class\") || \"\";\n          b = (b || \"\").split(/ /g).reduce(function (b, c) {\n            -1 === f.indexOf(c) && b.push(c);\n            return b;\n          }, f ? [f] : []).join(\" \");\n          b !== f && this.attr(\"class\", b);\n          return this;\n        }\n      }, {\n        key: \"afterSetters\",\n        value: function afterSetters() {\n          this.doTransform && (this.updateTransform(), this.doTransform = !1);\n        }\n      }, {\n        key: \"align\",\n        value: function align(b, c, d) {\n          var k = {};\n          var n = this.renderer,\n            e = n.alignedObjects,\n            A;\n          var K, g;\n          if (b) {\n            if (this.alignOptions = b, this.alignByTranslate = c, !d || q(d)) this.alignTo = A = d || \"renderer\", w(e, this), e.push(this), d = void 0;\n          } else b = this.alignOptions, c = this.alignByTranslate, A = this.alignTo;\n          d = f(d, n[A], \"scrollablePlotBox\" === A ? n.plotBox : void 0, n);\n          A = b.align;\n          var a = b.verticalAlign;\n          n = (d.x || 0) + (b.x || 0);\n          e = (d.y || 0) + (b.y || 0);\n          \"right\" === A ? K = 1 : \"center\" === A && (K = 2);\n          K && (n += (d.width - (b.width || 0)) / K);\n          k[c ? \"translateX\" : \"x\"] = Math.round(n);\n          \"bottom\" === a ? g = 1 : \"middle\" === a && (g = 2);\n          g && (e += (d.height - (b.height || 0)) / g);\n          k[c ? \"translateY\" : \"y\"] = Math.round(e);\n          this[this.placed ? \"animate\" : \"attr\"](k);\n          this.placed = !0;\n          this.alignAttr = k;\n          return this;\n        }\n      }, {\n        key: \"alignSetter\",\n        value: function alignSetter(b) {\n          var c = {\n            left: \"start\",\n            center: \"middle\",\n            right: \"end\"\n          };\n          c[b] && (this.alignValue = b, this.element.setAttribute(\"text-anchor\", c[b]));\n        }\n      }, {\n        key: \"animate\",\n        value: function animate(c, d, k) {\n          var _this = this;\n          var e = z(f(d, this.renderer.globalAnimation, !0));\n          d = e.defer;\n          u.hidden && (e.duration = 0);\n          0 !== e.duration ? (k && (e.complete = k), n(function () {\n            _this.element && x(_this, c, e);\n          }, d)) : (this.attr(c, void 0, k || e.complete), b(c, function (b, c) {\n            e.step && e.step.call(this, b, {\n              prop: c,\n              pos: 1,\n              elem: this\n            });\n          }, this));\n          return this;\n        }\n      }, {\n        key: \"applyTextOutline\",\n        value: function applyTextOutline(b) {\n          var c = this.element;\n          -1 !== b.indexOf(\"contrast\") && (b = b.replace(/contrast/g, this.renderer.getContrast(c.style.fill)));\n          var f = b.split(\" \");\n          b = f[f.length - 1];\n          if ((f = f[0]) && \"none\" !== f && I.svg) {\n            this.fakeTS = !0;\n            f = f.replace(/(^[\\d\\.]+)(.*?)$/g, function (b, c, f) {\n              return 2 * Number(c) + f;\n            });\n            this.removeTextOutline();\n            var _d4 = u.createElementNS(l, \"tspan\");\n            m(_d4, {\n              \"class\": \"highcharts-text-outline\",\n              fill: b,\n              stroke: b,\n              \"stroke-width\": f,\n              \"stroke-linejoin\": \"round\"\n            });\n            b = c.querySelector(\"textPath\") || c;\n            [].forEach.call(b.childNodes, function (b) {\n              var c = b.cloneNode(!0);\n              c.removeAttribute && [\"fill\", \"stroke\", \"stroke-width\", \"stroke\"].forEach(function (b) {\n                return c.removeAttribute(b);\n              });\n              _d4.appendChild(c);\n            });\n            var _k = 0;\n            [].forEach.call(b.querySelectorAll(\"text tspan\"), function (b) {\n              _k += Number(b.getAttribute(\"dy\"));\n            });\n            f = u.createElementNS(l, \"tspan\");\n            f.textContent = \"\\u200B\";\n            m(f, {\n              x: Number(c.getAttribute(\"x\")),\n              dy: -_k\n            });\n            _d4.appendChild(f);\n            b.insertBefore(_d4, b.firstChild);\n          }\n        }\n      }, {\n        key: \"attr\",\n        value: function attr(c, f, d, k) {\n          var n = this.element,\n            e = D.symbolCustomAttribs;\n          var A,\n            q,\n            g = this,\n            a,\n            K;\n          \"string\" === typeof c && \"undefined\" !== typeof f && (A = c, c = {}, c[A] = f);\n          \"string\" === typeof c ? g = (this[c + \"Getter\"] || this._defaultGetter).call(this, c, n) : (b(c, function (b, f) {\n            a = !1;\n            k || H(this, f);\n            this.symbolName && -1 !== e.indexOf(f) && (q || (this.symbolAttr(c), q = !0), a = !0);\n            !this.rotation || \"x\" !== f && \"y\" !== f || (this.doTransform = !0);\n            a || (K = this[f + \"Setter\"] || this._defaultSetter, K.call(this, b, f, n));\n          }, this), this.afterSetters());\n          d && d.call(this);\n          return g;\n        }\n      }, {\n        key: \"clip\",\n        value: function clip(b) {\n          return this.attr(\"clip-path\", b ? \"url(\" + this.renderer.url + \"#\" + b.id + \")\" : \"none\");\n        }\n      }, {\n        key: \"crisp\",\n        value: function crisp(b, c) {\n          c = c || b.strokeWidth || 0;\n          var f = Math.round(c) % 2 / 2;\n          b.x = Math.floor(b.x || this.x || 0) + f;\n          b.y = Math.floor(b.y || this.y || 0) + f;\n          b.width = Math.floor((b.width || this.width || 0) - 2 * f);\n          b.height = Math.floor((b.height || this.height || 0) - 2 * f);\n          e(b.strokeWidth) && (b.strokeWidth = c);\n          return b;\n        }\n      }, {\n        key: \"complexColor\",\n        value: function complexColor(c, f, k) {\n          var n = this.renderer;\n          var q,\n            g,\n            A,\n            a,\n            r,\n            K,\n            h,\n            J,\n            m,\n            O,\n            w = [],\n            l;\n          F(this.renderer, \"complexColor\", {\n            args: arguments\n          }, function () {\n            c.radialGradient ? g = \"radialGradient\" : c.linearGradient && (g = \"linearGradient\");\n            if (g) {\n              A = c[g];\n              r = n.gradients;\n              K = c.stops;\n              m = k.radialReference;\n              d(A) && (c[g] = A = {\n                x1: A[0],\n                y1: A[1],\n                x2: A[2],\n                y2: A[3],\n                gradientUnits: \"userSpaceOnUse\"\n              });\n              \"radialGradient\" === g && m && !e(A.gradientUnits) && (a = A, A = G(A, n.getRadialAttr(m, a), {\n                gradientUnits: \"userSpaceOnUse\"\n              }));\n              b(A, function (b, c) {\n                \"id\" !== c && w.push(c, b);\n              });\n              b(K, function (b) {\n                w.push(b);\n              });\n              w = w.join(\",\");\n              if (r[w]) O = r[w].attr(\"id\");else {\n                A.id = O = P();\n                var _b5 = r[w] = n.createElement(g).attr(A).add(n.defs);\n                _b5.radAttr = a;\n                _b5.stops = [];\n                K.forEach(function (c) {\n                  0 === c[1].indexOf(\"rgba\") ? (q = y.parse(c[1]), h = q.get(\"rgb\"), J = q.get(\"a\")) : (h = c[1], J = 1);\n                  c = n.createElement(\"stop\").attr({\n                    offset: c[0],\n                    \"stop-color\": h,\n                    \"stop-opacity\": J\n                  }).add(_b5);\n                  _b5.stops.push(c);\n                });\n              }\n              l = \"url(\" + n.url + \"#\" + O + \")\";\n              k.setAttribute(f, l);\n              k.gradient = w;\n              c.toString = function () {\n                return l;\n              };\n            }\n          });\n        }\n      }, {\n        key: \"css\",\n        value: function css(f) {\n          var d = this.styles,\n            k = {},\n            n = this.element;\n          var e,\n            q = !d;\n          d && b(f, function (b, c) {\n            d && d[c] !== b && (k[c] = b, q = !0);\n          });\n          if (q) {\n            d && (f = E(d, k));\n            null === f.width || \"auto\" === f.width ? delete this.textWidth : \"text\" === n.nodeName.toLowerCase() && f.width && (e = this.textWidth = c(f.width));\n            this.styles = f;\n            e && !v && this.renderer.forExport && delete f.width;\n            var _b6 = G(f);\n            n.namespaceURI === this.SVG_NS && ([\"textOutline\", \"textOverflow\", \"width\"].forEach(function (c) {\n              return _b6 && delete _b6[c];\n            }), _b6.color && (_b6.fill = _b6.color));\n            g(n, _b6);\n          }\n          this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), f.textOutline && this.applyTextOutline(f.textOutline));\n          return this;\n        }\n      }, {\n        key: \"dashstyleSetter\",\n        value: function dashstyleSetter(b) {\n          var d = this[\"stroke-width\"];\n          \"inherit\" === d && (d = 1);\n          if (b = b && b.toLowerCase()) {\n            var _k2 = b.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n            for (b = _k2.length; b--;) _k2[b] = \"\" + c(_k2[b]) * f(d, NaN);\n            b = _k2.join(\",\").replace(/NaN/g, \"none\");\n            this.element.setAttribute(\"stroke-dasharray\", b);\n          }\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var c = this;\n          var f = c.element || {};\n          var d = c.renderer;\n          var k = f.ownerSVGElement;\n          var n = \"SPAN\" === f.nodeName && c.parentGroup || void 0;\n          f.onclick = f.onmouseout = f.onmouseover = f.onmousemove = f.point = null;\n          H(c);\n          if (c.clipPath && k) {\n            var _b7 = c.clipPath;\n            [].forEach.call(k.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (c) {\n              -1 < c.getAttribute(\"clip-path\").indexOf(_b7.element.id) && c.removeAttribute(\"clip-path\");\n            });\n            c.clipPath = _b7.destroy();\n          }\n          if (c.stops) {\n            for (k = 0; k < c.stops.length; k++) c.stops[k].destroy();\n            c.stops.length = 0;\n            c.stops = void 0;\n          }\n          for (c.safeRemoveChild(f); n && n.div && 0 === n.div.childNodes.length;) f = n.parentGroup, c.safeRemoveChild(n.div), delete n.div, n = f;\n          c.alignTo && w(d.alignedObjects, c);\n          b(c, function (b, f) {\n            c[f] && c[f].parentGroup === c && c[f].destroy && c[f].destroy();\n            delete c[f];\n          });\n        }\n      }, {\n        key: \"dSetter\",\n        value: function dSetter(b, c, f) {\n          d(b) && (\"string\" === typeof b[0] && (b = this.renderer.pathToSegments(b)), this.pathArray = b, b = b.reduce(function (b, c, f) {\n            return c && c.join ? (f ? b + \" \" : \"\") + c.join(\" \") : (c || \"\").toString();\n          }, \"\"));\n          /(NaN| {2}|^$)/.test(b) && (b = \"M 0 0\");\n          this[c] !== b && (f.setAttribute(c, b), this[c] = b);\n        }\n      }, {\n        key: \"fadeOut\",\n        value: function fadeOut(b) {\n          var c = this;\n          c.animate({\n            opacity: 0\n          }, {\n            duration: f(b, 150),\n            complete: function complete() {\n              c.hide();\n            }\n          });\n        }\n      }, {\n        key: \"fillSetter\",\n        value: function fillSetter(b, c, f) {\n          \"string\" === typeof b ? f.setAttribute(c, b) : b && this.complexColor(b, c, f);\n        }\n      }, {\n        key: \"getBBox\",\n        value: function getBBox(b, c) {\n          var d = this.alignValue,\n            n = this.element,\n            q = this.renderer,\n            a = this.styles,\n            A = this.textStr,\n            r = q.cache,\n            h = q.cacheKeys;\n          var m = n.namespaceURI === this.SVG_NS;\n          c = f(c, this.rotation, 0);\n          var K = q.styledMode ? n && D.prototype.getStyle.call(n, \"font-size\") : a && a.fontSize;\n          var J;\n          var N;\n          e(A) && (N = A.toString(), -1 === N.indexOf(\"<\") && (N = N.replace(/[0-9]/g, \"0\")), N += [\"\", q.rootFontSize, K, c, this.textWidth, d, a && a.textOverflow, a && a.fontWeight].join());\n          N && !b && (J = r[N]);\n          if (!J) {\n            if (m || q.forExport) {\n              try {\n                var O = this.fakeTS && function (b) {\n                  var c = n.querySelector(\".highcharts-text-outline\");\n                  c && g(c, {\n                    display: b\n                  });\n                };\n                k(O) && O(\"none\");\n                J = n.getBBox ? E({}, n.getBBox()) : {\n                  width: n.offsetWidth,\n                  height: n.offsetHeight,\n                  x: 0,\n                  y: 0\n                };\n                k(O) && O(\"\");\n              } catch (fa) {\n                \"\";\n              }\n              if (!J || 0 > J.width) J = {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0\n              };\n            } else J = this.htmlGetBBox();\n            O = J.width;\n            b = J.height;\n            m && (J.height = b = {\n              \"11px,17\": 14,\n              \"13px,20\": 16\n            }[\"\".concat(K || \"\", \",\").concat(Math.round(b))] || b);\n            if (c) {\n              m = Number(n.getAttribute(\"y\") || 0) - J.y;\n              K = {\n                right: 1,\n                center: .5\n              }[d || 0] || 0;\n              var w = c * B,\n                l = (c - 90) * B,\n                p = O * Math.cos(w);\n              c = O * Math.sin(w);\n              var G = Math.cos(l);\n              w = Math.sin(l);\n              O = J.x + K * (O - p) + m * G;\n              l = O + p;\n              G = l - b * G;\n              p = G - p;\n              m = J.y + m - K * c + m * w;\n              K = m + c;\n              b = K - b * w;\n              c = b - c;\n              J.x = Math.min(O, l, G, p);\n              J.y = Math.min(m, K, b, c);\n              J.width = Math.max(O, l, G, p) - J.x;\n              J.height = Math.max(m, K, b, c) - J.y;\n            }\n          }\n          if (N && (\"\" === A || 0 < J.height)) {\n            for (; 250 < h.length;) delete r[h.shift()];\n            r[N] || h.push(N);\n            r[N] = J;\n          }\n          return J;\n        }\n      }, {\n        key: \"getStyle\",\n        value: function getStyle(b) {\n          return p.getComputedStyle(this.element || this, \"\").getPropertyValue(b);\n        }\n      }, {\n        key: \"hasClass\",\n        value: function hasClass(b) {\n          return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(b);\n        }\n      }, {\n        key: \"hide\",\n        value: function hide() {\n          return this.attr({\n            visibility: \"hidden\"\n          });\n        }\n      }, {\n        key: \"htmlGetBBox\",\n        value: function htmlGetBBox() {\n          return {\n            height: 0,\n            width: 0,\n            x: 0,\n            y: 0\n          };\n        }\n      }, {\n        key: \"init\",\n        value: function init(b, c) {\n          this.element = \"span\" === c ? h(c) : u.createElementNS(this.SVG_NS, c);\n          this.renderer = b;\n          F(this, \"afterInit\");\n        }\n      }, {\n        key: \"on\",\n        value: function on(b, c) {\n          var f = this.onEvents;\n          if (f[b]) f[b]();\n          f[b] = t(this.element, b, c);\n          return this;\n        }\n      }, {\n        key: \"opacitySetter\",\n        value: function opacitySetter(b, c, f) {\n          this.opacity = b = Number(Number(b).toFixed(3));\n          f.setAttribute(c, b);\n        }\n      }, {\n        key: \"removeClass\",\n        value: function removeClass(b) {\n          return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(q(b) ? new RegExp(\"(^| )\".concat(b, \"( |$)\")) : b, \" \").replace(/ +/g, \" \").trim());\n        }\n      }, {\n        key: \"removeTextOutline\",\n        value: function removeTextOutline() {\n          var b = this.element.querySelector(\"tspan.highcharts-text-outline\");\n          b && this.safeRemoveChild(b);\n        }\n      }, {\n        key: \"safeRemoveChild\",\n        value: function safeRemoveChild(b) {\n          var c = b.parentNode;\n          c && c.removeChild(b);\n        }\n      }, {\n        key: \"setRadialReference\",\n        value: function setRadialReference(b) {\n          var c = this.element.gradient && this.renderer.gradients[this.element.gradient];\n          this.element.radialReference = b;\n          c && c.radAttr && c.animate(this.renderer.getRadialAttr(b, c.radAttr));\n          return this;\n        }\n      }, {\n        key: \"setTextPath\",\n        value: function setTextPath(b, c) {\n          var _this2 = this;\n          c = G(!0, {\n            enabled: !0,\n            attributes: {\n              dy: -5,\n              startOffset: \"50%\",\n              textAnchor: \"middle\"\n            }\n          }, c);\n          var f = this.renderer.url,\n            d = this.text || this,\n            k = d.textPath,\n            _c3 = c,\n            n = _c3.attributes,\n            A = _c3.enabled;\n          b = b || k && k.path;\n          k && k.undo();\n          b && A ? (c = t(d, \"afterModifyTree\", function (c) {\n            if (b && A) {\n              var _A = b.attr(\"id\");\n              _A || b.attr(\"id\", _A = P());\n              var k = {\n                x: 0,\n                y: 0\n              };\n              e(n.dx) && (k.dx = n.dx, delete n.dx);\n              e(n.dy) && (k.dy = n.dy, delete n.dy);\n              d.attr(k);\n              _this2.attr({\n                transform: \"\"\n              });\n              _this2.box && (_this2.box = _this2.box.destroy());\n              k = c.nodes.slice(0);\n              c.nodes.length = 0;\n              c.nodes[0] = {\n                tagName: \"textPath\",\n                attributes: E(n, {\n                  \"text-anchor\": n.textAnchor,\n                  href: \"\".concat(f, \"#\").concat(_A)\n                }),\n                children: k\n              };\n            }\n          }), d.textPath = {\n            path: b,\n            undo: c\n          }) : (d.attr({\n            dx: 0,\n            dy: 0\n          }), delete d.textPath);\n          this.added && (d.textCache = \"\", this.renderer.buildText(d));\n          return this;\n        }\n      }, {\n        key: \"shadow\",\n        value: function shadow(b) {\n          var c;\n          var f = this.renderer,\n            d = G(90 === (null === (c = this.parentGroup) || void 0 === c ? void 0 : c.rotation) ? {\n              offsetX: -1,\n              offsetY: -1\n            } : {}, r(b) ? b : {});\n          c = f.shadowDefinition(d);\n          return this.attr({\n            filter: b ? \"url(\".concat(f.url, \"#\").concat(c, \")\") : \"none\"\n          });\n        }\n      }, {\n        key: \"show\",\n        value: function show() {\n          var b = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n          return this.attr({\n            visibility: b ? \"inherit\" : \"visible\"\n          });\n        }\n      }, {\n        key: \"stroke-widthSetter\",\n        value: function strokeWidthSetter(b, c, f) {\n          this[c] = b;\n          f.setAttribute(c, b);\n        }\n      }, {\n        key: \"strokeWidth\",\n        value: function strokeWidth() {\n          if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n          var b = this.getStyle(\"stroke-width\");\n          var f = 0,\n            d;\n          b.indexOf(\"px\") === b.length - 2 ? f = c(b) : \"\" !== b && (d = u.createElementNS(l, \"rect\"), m(d, {\n            width: b,\n            \"stroke-width\": 0\n          }), this.element.parentNode.appendChild(d), f = d.getBBox().width, d.parentNode.removeChild(d));\n          return f;\n        }\n      }, {\n        key: \"symbolAttr\",\n        value: function symbolAttr(b) {\n          var c = this;\n          D.symbolCustomAttribs.forEach(function (d) {\n            c[d] = f(b[d], c[d]);\n          });\n          c.attr({\n            d: c.renderer.symbols[c.symbolName](c.x, c.y, c.width, c.height, c)\n          });\n        }\n      }, {\n        key: \"textSetter\",\n        value: function textSetter(b) {\n          b !== this.textStr && (delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));\n        }\n      }, {\n        key: \"titleSetter\",\n        value: function titleSetter(b) {\n          var c = this.element,\n            d = c.getElementsByTagName(\"title\")[0] || u.createElementNS(this.SVG_NS, \"title\");\n          c.insertBefore ? c.insertBefore(d, c.firstChild) : c.appendChild(d);\n          d.textContent = String(f(b, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\n        }\n      }, {\n        key: \"toFront\",\n        value: function toFront() {\n          var b = this.element;\n          b.parentNode.appendChild(b);\n          return this;\n        }\n      }, {\n        key: \"translate\",\n        value: function translate(b, c) {\n          return this.attr({\n            translateX: b,\n            translateY: c\n          });\n        }\n      }, {\n        key: \"updateTransform\",\n        value: function updateTransform() {\n          var b = this.element,\n            c = this.matrix,\n            _this$rotation = this.rotation,\n            d = _this$rotation === void 0 ? 0 : _this$rotation,\n            k = this.scaleX,\n            n = this.scaleY,\n            _this$translateX = this.translateX,\n            q = _this$translateX === void 0 ? 0 : _this$translateX,\n            _this$translateY = this.translateY,\n            A = _this$translateY === void 0 ? 0 : _this$translateY,\n            g = [\"translate(\" + q + \",\" + A + \")\"];\n          e(c) && g.push(\"matrix(\" + c.join(\",\") + \")\");\n          d && g.push(\"rotate(\" + d + \" \" + f(this.rotationOriginX, b.getAttribute(\"x\"), 0) + \" \" + f(this.rotationOriginY, b.getAttribute(\"y\") || 0) + \")\");\n          (e(k) || e(n)) && g.push(\"scale(\" + f(k, 1) + \" \" + f(n, 1) + \")\");\n          g.length && !(this.text || this).textPath && b.setAttribute(\"transform\", g.join(\" \"));\n        }\n      }, {\n        key: \"visibilitySetter\",\n        value: function visibilitySetter(b, c, f) {\n          \"inherit\" === b ? f.removeAttribute(c) : this[c] !== b && f.setAttribute(c, b);\n          this[c] = b;\n        }\n      }, {\n        key: \"xGetter\",\n        value: function xGetter(b) {\n          \"circle\" === this.element.nodeName && (\"x\" === b ? b = \"cx\" : \"y\" === b && (b = \"cy\"));\n          return this._defaultGetter(b);\n        }\n      }, {\n        key: \"zIndexSetter\",\n        value: function zIndexSetter(b, f) {\n          var d = this.renderer,\n            k = this.parentGroup;\n          var n = (k || d).element || d.box,\n            q = this.element;\n          d = n === d.box;\n          var A = !1,\n            g;\n          var a = this.added;\n          var r;\n          e(b) ? (q.setAttribute(\"data-z-index\", b), b = +b, this[f] === b && (a = !1)) : e(this[f]) && q.removeAttribute(\"data-z-index\");\n          this[f] = b;\n          if (a) {\n            (b = this.zIndex) && k && (k.handleZ = !0);\n            f = n.childNodes;\n            for (r = f.length - 1; 0 <= r && !A; r--) if (k = f[r], a = k.getAttribute(\"data-z-index\"), g = !e(a), k !== q) if (0 > b && g && !d && !r) n.insertBefore(q, f[r]), A = !0;else if (c(a) <= b || g && (!e(b) || 0 <= b)) n.insertBefore(q, f[r + 1]), A = !0;\n            A || (n.insertBefore(q, f[d ? 3 : 0]), A = !0);\n          }\n          return A;\n        }\n      }]);\n      return D;\n    }();\n    D.symbolCustomAttribs = \"anchorX anchorY clockwise end height innerR r start width x y\".split(\" \");\n    D.prototype.strokeSetter = D.prototype.fillSetter;\n    D.prototype.yGetter = D.prototype.xGetter;\n    D.prototype.matrixSetter = D.prototype.rotationOriginXSetter = D.prototype.rotationOriginYSetter = D.prototype.rotationSetter = D.prototype.scaleXSetter = D.prototype.scaleYSetter = D.prototype.translateXSetter = D.prototype.translateYSetter = D.prototype.verticalAlignSetter = function (b, c) {\n      this[c] = b;\n      this.doTransform = !0;\n    };\n    \"\";\n    return D;\n  });\n  M(a, \"Core/Renderer/RendererRegistry.js\", [a[\"Core/Globals.js\"]], function (a) {\n    var x;\n    (function (x) {\n      x.rendererTypes = {};\n      var y;\n      x.getRendererType = function () {\n        var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : y;\n        return x.rendererTypes[a] || x.rendererTypes[y];\n      };\n      x.registerRendererType = function (C, z, H) {\n        x.rendererTypes[C] = z;\n        if (!y || H) y = C, a.Renderer = z;\n      };\n    })(x || (x = {}));\n    return x;\n  });\n  M(a, \"Core/Renderer/SVG/SVGLabel.js\", [a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    var x = y.defined,\n      L = y.extend,\n      C = y.isNumber,\n      z = y.merge,\n      H = y.pick,\n      B = y.removeEvent;\n    var u = /*#__PURE__*/function (_a2) {\n      _inherits(u, _a2);\n      function u(a, l, p, t, m, h, g, e, w, E) {\n        var _this3;\n        _classCallCheck(this, u);\n        _this3 = _possibleConstructorReturn(this, _getPrototypeOf(u).call(this));\n        _this3.paddingRightSetter = _this3.paddingLeftSetter = _this3.paddingSetter;\n        _this3.init(a, \"g\");\n        _this3.textStr = l;\n        _this3.x = p;\n        _this3.y = t;\n        _this3.anchorX = h;\n        _this3.anchorY = g;\n        _this3.baseline = w;\n        _this3.className = E;\n        _this3.addClass(\"button\" === E ? \"highcharts-no-tooltip\" : \"highcharts-label\");\n        E && _this3.addClass(\"highcharts-\" + E);\n        _this3.text = a.text(void 0, 0, 0, e).attr({\n          zIndex: 1\n        });\n        var v;\n        \"string\" === typeof m && ((v = /^url\\((.*?)\\)$/.test(m)) || _this3.renderer.symbols[m]) && (_this3.symbolKey = m);\n        _this3.bBox = u.emptyBBox;\n        _this3.padding = 3;\n        _this3.baselineOffset = 0;\n        _this3.needsBox = a.styledMode || v;\n        _this3.deferredAttr = {};\n        _this3.alignFactor = 0;\n        return _this3;\n      }\n      _createClass(u, [{\n        key: \"alignSetter\",\n        value: function alignSetter(a) {\n          a = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[a];\n          a !== this.alignFactor && (this.alignFactor = a, this.bBox && C(this.xSetting) && this.attr({\n            x: this.xSetting\n          }));\n        }\n      }, {\n        key: \"anchorXSetter\",\n        value: function anchorXSetter(a, l) {\n          this.anchorX = a;\n          this.boxAttr(l, Math.round(a) - this.getCrispAdjust() - this.xSetting);\n        }\n      }, {\n        key: \"anchorYSetter\",\n        value: function anchorYSetter(a, l) {\n          this.anchorY = a;\n          this.boxAttr(l, a - this.ySetting);\n        }\n      }, {\n        key: \"boxAttr\",\n        value: function boxAttr(a, l) {\n          this.box ? this.box.attr(a, l) : this.deferredAttr[a] = l;\n        }\n      }, {\n        key: \"css\",\n        value: function css(v) {\n          if (v) {\n            var _a3 = {};\n            v = z(v);\n            u.textProps.forEach(function (l) {\n              \"undefined\" !== typeof v[l] && (_a3[l] = v[l], delete v[l]);\n            });\n            this.text.css(_a3);\n            \"fontSize\" in _a3 || \"fontWeight\" in _a3 ? this.updateTextPadding() : (\"width\" in _a3 || \"textOverflow\" in _a3) && this.updateBoxSize();\n          }\n          return a.prototype.css.call(this, v);\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          B(this.element, \"mouseenter\");\n          B(this.element, \"mouseleave\");\n          this.text && this.text.destroy();\n          this.box && (this.box = this.box.destroy());\n          a.prototype.destroy.call(this);\n        }\n      }, {\n        key: \"fillSetter\",\n        value: function fillSetter(a, l) {\n          a && (this.needsBox = !0);\n          this.fill = a;\n          this.boxAttr(l, a);\n        }\n      }, {\n        key: \"getBBox\",\n        value: function getBBox() {\n          this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();\n          var a = this.padding,\n            l = H(this.paddingLeft, a);\n          return {\n            width: this.width,\n            height: this.height,\n            x: this.bBox.x - l,\n            y: this.bBox.y - a\n          };\n        }\n      }, {\n        key: \"getCrispAdjust\",\n        value: function getCrispAdjust() {\n          return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n        }\n      }, {\n        key: \"heightSetter\",\n        value: function heightSetter(a) {\n          this.heightSetting = a;\n        }\n      }, {\n        key: \"onAdd\",\n        value: function onAdd() {\n          this.text.add(this);\n          this.attr({\n            text: H(this.textStr, \"\"),\n            x: this.x || 0,\n            y: this.y || 0\n          });\n          this.box && x(this.anchorX) && this.attr({\n            anchorX: this.anchorX,\n            anchorY: this.anchorY\n          });\n        }\n      }, {\n        key: \"paddingSetter\",\n        value: function paddingSetter(a, l) {\n          C(a) ? a !== this[l] && (this[l] = a, this.updateTextPadding()) : this[l] = void 0;\n        }\n      }, {\n        key: \"rSetter\",\n        value: function rSetter(a, l) {\n          this.boxAttr(l, a);\n        }\n      }, {\n        key: \"strokeSetter\",\n        value: function strokeSetter(a, l) {\n          this.stroke = a;\n          this.boxAttr(l, a);\n        }\n      }, {\n        key: \"stroke-widthSetter\",\n        value: function strokeWidthSetter(a, l) {\n          a && (this.needsBox = !0);\n          this[\"stroke-width\"] = a;\n          this.boxAttr(l, a);\n        }\n      }, {\n        key: \"text-alignSetter\",\n        value: function textAlignSetter(a) {\n          this.textAlign = a;\n        }\n      }, {\n        key: \"textSetter\",\n        value: function textSetter(a) {\n          \"undefined\" !== typeof a && this.text.attr({\n            text: a\n          });\n          this.updateTextPadding();\n        }\n      }, {\n        key: \"updateBoxSize\",\n        value: function updateBoxSize() {\n          var a = this.text;\n          var l = {},\n            p = this.padding,\n            t = this.bBox = C(this.widthSetting) && C(this.heightSetting) && !this.textAlign || !x(a.textStr) ? u.emptyBBox : a.getBBox();\n          this.width = this.getPaddedWidth();\n          this.height = (this.heightSetting || t.height || 0) + 2 * p;\n          var m = this.renderer.fontMetrics(a);\n          this.baselineOffset = p + Math.min((this.text.firstLineMetrics || m).b, t.height || Infinity);\n          this.heightSetting && (this.baselineOffset += (this.heightSetting - m.h) / 2);\n          this.needsBox && !a.textPath && (this.box || (a = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), a.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), a.add(this)), a = this.getCrispAdjust(), l.x = a, l.y = (this.baseline ? -this.baselineOffset : 0) + a, l.width = Math.round(this.width), l.height = Math.round(this.height), this.box.attr(L(l, this.deferredAttr)), this.deferredAttr = {});\n        }\n      }, {\n        key: \"updateTextPadding\",\n        value: function updateTextPadding() {\n          var a = this.text;\n          if (!a.textPath) {\n            this.updateBoxSize();\n            var l = this.baseline ? 0 : this.baselineOffset;\n            var p = H(this.paddingLeft, this.padding);\n            x(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (p += {\n              center: .5,\n              right: 1\n            }[this.textAlign] * (this.widthSetting - this.bBox.width));\n            if (p !== a.x || l !== a.y) a.attr(\"x\", p), a.hasBoxWidthChanged && (this.bBox = a.getBBox(!0)), \"undefined\" !== typeof l && a.attr(\"y\", l);\n            a.x = p;\n            a.y = l;\n          }\n        }\n      }, {\n        key: \"widthSetter\",\n        value: function widthSetter(a) {\n          this.widthSetting = C(a) ? a : void 0;\n        }\n      }, {\n        key: \"getPaddedWidth\",\n        value: function getPaddedWidth() {\n          var a = this.padding;\n          var l = H(this.paddingLeft, a);\n          a = H(this.paddingRight, a);\n          return (this.widthSetting || this.bBox.width || 0) + l + a;\n        }\n      }, {\n        key: \"xSetter\",\n        value: function xSetter(a) {\n          this.x = a;\n          this.alignFactor && (a -= this.alignFactor * this.getPaddedWidth(), this[\"forceAnimate:x\"] = !0);\n          this.xSetting = Math.round(a);\n          this.attr(\"translateX\", this.xSetting);\n        }\n      }, {\n        key: \"ySetter\",\n        value: function ySetter(a) {\n          this.ySetting = this.y = Math.round(a);\n          this.attr(\"translateY\", this.ySetting);\n        }\n      }]);\n      return u;\n    }(a);\n    u.emptyBBox = {\n      width: 0,\n      height: 0,\n      x: 0,\n      y: 0\n    };\n    u.textProps = \"color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow whiteSpace width\".split(\" \");\n    return u;\n  });\n  M(a, \"Core/Renderer/SVG/Symbols.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    function x(a, u, v, l, p) {\n      var t = [];\n      if (p) {\n        var m = p.start || 0,\n          h = H(p.r, v);\n        v = H(p.r, l || v);\n        l = (p.end || 0) - .001;\n        var g = p.innerR,\n          e = H(p.open, .001 > Math.abs((p.end || 0) - m - 2 * Math.PI)),\n          w = Math.cos(m),\n          E = Math.sin(m),\n          F = Math.cos(l),\n          d = Math.sin(l),\n          k = H(p.longArc, .001 > l - m - Math.PI ? 0 : 1);\n        var r = [\"A\", h, v, 0, k, H(p.clockwise, 1), a + h * F, u + v * d];\n        r.params = {\n          start: m,\n          end: l,\n          cx: a,\n          cy: u\n        };\n        t.push([\"M\", a + h * w, u + v * E], r);\n        C(g) && (r = [\"A\", g, g, 0, k, C(p.clockwise) ? 1 - p.clockwise : 0, a + g * w, u + g * E], r.params = {\n          start: l,\n          end: m,\n          cx: a,\n          cy: u\n        }, t.push(e ? [\"M\", a + g * F, u + g * d] : [\"L\", a + g * F, u + g * d], r));\n        e || t.push([\"Z\"]);\n      }\n      return t;\n    }\n    function I(a, u, v, l, p) {\n      return p && p.r ? L(a, u, v, l, p) : [[\"M\", a, u], [\"L\", a + v, u], [\"L\", a + v, u + l], [\"L\", a, u + l], [\"Z\"]];\n    }\n    function L(a, u, v, l, p) {\n      p = (null === p || void 0 === p ? void 0 : p.r) || 0;\n      return [[\"M\", a + p, u], [\"L\", a + v - p, u], [\"A\", p, p, 0, 0, 1, a + v, u + p], [\"L\", a + v, u + l - p], [\"A\", p, p, 0, 0, 1, a + v - p, u + l], [\"L\", a + p, u + l], [\"A\", p, p, 0, 0, 1, a, u + l - p], [\"L\", a, u + p], [\"A\", p, p, 0, 0, 1, a + p, u], [\"Z\"]];\n    }\n    var C = a.defined,\n      z = a.isNumber,\n      H = a.pick;\n    return {\n      arc: x,\n      callout: function callout(a, u, v, l, p) {\n        var t = Math.min(p && p.r || 0, v, l),\n          m = t + 6,\n          h = p && p.anchorX;\n        p = p && p.anchorY || 0;\n        var g = L(a, u, v, l, {\n          r: t\n        });\n        if (!z(h)) return g;\n        a + h >= v ? p > u + m && p < u + l - m ? g.splice(3, 1, [\"L\", a + v, p - 6], [\"L\", a + v + 6, p], [\"L\", a + v, p + 6], [\"L\", a + v, u + l - t]) : g.splice(3, 1, [\"L\", a + v, l / 2], [\"L\", h, p], [\"L\", a + v, l / 2], [\"L\", a + v, u + l - t]) : 0 >= a + h ? p > u + m && p < u + l - m ? g.splice(7, 1, [\"L\", a, p + 6], [\"L\", a - 6, p], [\"L\", a, p - 6], [\"L\", a, u + t]) : g.splice(7, 1, [\"L\", a, l / 2], [\"L\", h, p], [\"L\", a, l / 2], [\"L\", a, u + t]) : p && p > l && h > a + m && h < a + v - m ? g.splice(5, 1, [\"L\", h + 6, u + l], [\"L\", h, u + l + 6], [\"L\", h - 6, u + l], [\"L\", a + t, u + l]) : p && 0 > p && h > a + m && h < a + v - m && g.splice(1, 1, [\"L\", h - 6, u], [\"L\", h, u - 6], [\"L\", h + 6, u], [\"L\", v - t, u]);\n        return g;\n      },\n      circle: function circle(a, u, v, l) {\n        return x(a + v / 2, u + l / 2, v / 2, l / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      diamond: function diamond(a, u, v, l) {\n        return [[\"M\", a + v / 2, u], [\"L\", a + v, u + l / 2], [\"L\", a + v / 2, u + l], [\"L\", a, u + l / 2], [\"Z\"]];\n      },\n      rect: I,\n      roundedRect: L,\n      square: I,\n      triangle: function triangle(a, u, v, l) {\n        return [[\"M\", a + v / 2, u], [\"L\", a + v, u + l], [\"L\", a, u + l], [\"Z\"]];\n      },\n      \"triangle-down\": function triangleDown(a, u, v, l) {\n        return [[\"M\", a, u], [\"L\", a + v, u], [\"L\", a + v / 2, u + l], [\"Z\"]];\n      }\n    };\n  });\n  M(a, \"Core/Renderer/SVG/TextBuilder.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    var x = y.doc,\n      C = y.SVG_NS,\n      z = y.win,\n      H = I.attr,\n      B = I.extend,\n      u = I.fireEvent,\n      v = I.isString,\n      l = I.objectEach,\n      p = I.pick;\n    var t = /*#__PURE__*/function () {\n      function t(a) {\n        _classCallCheck(this, t);\n        var h = a.styles;\n        this.renderer = a.renderer;\n        this.svgElement = a;\n        this.width = a.textWidth;\n        this.textLineHeight = h && h.lineHeight;\n        this.textOutline = h && h.textOutline;\n        this.ellipsis = !(!h || \"ellipsis\" !== h.textOverflow);\n        this.noWrap = !(!h || \"nowrap\" !== h.whiteSpace);\n      }\n      _createClass(t, [{\n        key: \"buildSVG\",\n        value: function buildSVG() {\n          var m = this.svgElement,\n            h = m.element;\n          var g = m.renderer,\n            e = p(m.textStr, \"\").toString();\n          var w = -1 !== e.indexOf(\"<\"),\n            l = h.childNodes;\n          g = !m.added && g.box;\n          var t = /<br.*?>/g;\n          var d = [e, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, m.getStyle(\"font-size\"), this.width].join();\n          if (d !== m.textCache) {\n            m.textCache = d;\n            delete m.actualWidth;\n            for (d = l.length; d--;) h.removeChild(l[d]);\n            w || this.ellipsis || this.width || m.textPath || -1 !== e.indexOf(\" \") && (!this.noWrap || t.test(e)) ? \"\" !== e && (g && g.appendChild(h), e = new a(e), this.modifyTree(e.nodes), e.addToDOM(h), this.modifyDOM(), this.ellipsis && -1 !== (h.textContent || \"\").indexOf(\"\\u2026\") && m.attr(\"title\", this.unescapeEntities(m.textStr || \"\", [\"&lt;\", \"&gt;\"])), g && g.removeChild(h)) : h.appendChild(x.createTextNode(this.unescapeEntities(e)));\n            v(this.textOutline) && m.applyTextOutline && m.applyTextOutline(this.textOutline);\n          }\n        }\n      }, {\n        key: \"modifyDOM\",\n        value: function modifyDOM() {\n          var _this4 = this;\n          var a = this.svgElement,\n            h = H(a.element, \"x\");\n          a.firstLineMetrics = void 0;\n          var g;\n          for (; g = a.element.firstChild;) if (/^[\\s\\u200B]*$/.test(g.textContent || \" \")) a.element.removeChild(g);else break;\n          [].forEach.call(a.element.querySelectorAll(\"tspan.highcharts-br\"), function (e, d) {\n            e.nextSibling && e.previousSibling && (0 === d && 1 === e.previousSibling.nodeType && (a.firstLineMetrics = a.renderer.fontMetrics(e.previousSibling)), H(e, {\n              dy: _this4.getLineHeight(e.nextSibling),\n              x: h\n            }));\n          });\n          var e = this.width || 0;\n          if (e) {\n            var w = function w(g, d) {\n                var k = g.textContent || \"\";\n                var r = k.replace(/([^\\^])-/g, \"$1- \").split(\" \");\n                var q = !_this4.noWrap && (1 < r.length || 1 < a.element.childNodes.length);\n                var m = _this4.getLineHeight(d);\n                var b = 0,\n                  f = a.actualWidth;\n                if (_this4.ellipsis) k && _this4.truncate(g, k, void 0, 0, Math.max(0, e - .8 * m), function (b, f) {\n                  return b.substring(0, f) + \"\\u2026\";\n                });else if (q) {\n                  k = [];\n                  for (q = []; d.firstChild && d.firstChild !== g;) q.push(d.firstChild), d.removeChild(d.firstChild);\n                  for (; r.length;) r.length && !_this4.noWrap && 0 < b && (k.push(g.textContent || \"\"), g.textContent = r.join(\" \").replace(/- /g, \"-\")), _this4.truncate(g, void 0, r, 0 === b ? f || 0 : 0, e, function (b, f) {\n                    return r.slice(0, f).join(\" \").replace(/- /g, \"-\");\n                  }), f = a.actualWidth, b++;\n                  q.forEach(function (b) {\n                    d.insertBefore(b, g);\n                  });\n                  k.forEach(function (b) {\n                    d.insertBefore(x.createTextNode(b), g);\n                    b = x.createElementNS(C, \"tspan\");\n                    b.textContent = \"\\u200B\";\n                    H(b, {\n                      dy: m,\n                      x: h\n                    });\n                    d.insertBefore(b, g);\n                  });\n                }\n              },\n              l = function l(e) {\n                [].slice.call(e.childNodes).forEach(function (d) {\n                  d.nodeType === z.Node.TEXT_NODE ? w(d, e) : (-1 !== d.className.baseVal.indexOf(\"highcharts-br\") && (a.actualWidth = 0), l(d));\n                });\n              };\n            l(a.element);\n          }\n        }\n      }, {\n        key: \"getLineHeight\",\n        value: function getLineHeight(a) {\n          a = a.nodeType === z.Node.TEXT_NODE ? a.parentElement : a;\n          return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a || this.svgElement.element).h;\n        }\n      }, {\n        key: \"modifyTree\",\n        value: function modifyTree(a) {\n          var _this5 = this;\n          var h = function h(g, e) {\n            var _g$attributes = g.attributes,\n              m = _g$attributes === void 0 ? {} : _g$attributes,\n              l = g.children,\n              _g$style = g.style,\n              p = _g$style === void 0 ? {} : _g$style,\n              d = g.tagName,\n              k = _this5.renderer.styledMode;\n            if (\"b\" === d || \"strong\" === d) k ? m[\"class\"] = \"highcharts-strong\" : p.fontWeight = \"bold\";else if (\"i\" === d || \"em\" === d) k ? m[\"class\"] = \"highcharts-emphasized\" : p.fontStyle = \"italic\";\n            p && p.color && (p.fill = p.color);\n            \"br\" === d ? (m[\"class\"] = \"highcharts-br\", g.textContent = \"\\u200B\", (e = a[e + 1]) && e.textContent && (e.textContent = e.textContent.replace(/^ +/gm, \"\"))) : \"a\" === d && l && l.some(function (d) {\n              return \"#text\" === d.tagName;\n            }) && (g.children = [{\n              children: l,\n              tagName: \"tspan\"\n            }]);\n            \"#text\" !== d && \"a\" !== d && (g.tagName = \"tspan\");\n            B(g, {\n              attributes: m,\n              style: p\n            });\n            l && l.filter(function (d) {\n              return \"#text\" !== d.tagName;\n            }).forEach(h);\n          };\n          a.forEach(h);\n          u(this.svgElement, \"afterModifyTree\", {\n            nodes: a\n          });\n        }\n      }, {\n        key: \"truncate\",\n        value: function truncate(a, h, g, e, l, p) {\n          var m = this.svgElement,\n            d = m.rotation,\n            k = [];\n          var r = g ? 1 : 0,\n            q = (h || g || \"\").length,\n            w = q,\n            b,\n            f;\n          var c = function c(b, _c4) {\n            b = _c4 || b;\n            if ((_c4 = a.parentNode) && \"undefined\" === typeof k[b] && _c4.getSubStringLength) try {\n              k[b] = e + _c4.getSubStringLength(0, g ? b + 1 : b);\n            } catch (D) {\n              \"\";\n            }\n            return k[b];\n          };\n          m.rotation = 0;\n          f = c(a.textContent.length);\n          if (e + f > l) {\n            for (; r <= q;) w = Math.ceil((r + q) / 2), g && (b = p(g, w)), f = c(w, b && b.length - 1), r === q ? r = q + 1 : f > l ? q = w - 1 : r = w;\n            0 === q ? a.textContent = \"\" : h && q === h.length - 1 || (a.textContent = b || p(h || g, w));\n          }\n          g && g.splice(0, w);\n          m.actualWidth = f;\n          m.rotation = d;\n        }\n      }, {\n        key: \"unescapeEntities\",\n        value: function unescapeEntities(a, h) {\n          l(this.renderer.escapes, function (g, e) {\n            h && -1 !== h.indexOf(g) || (a = a.toString().replace(new RegExp(g, \"g\"), e));\n          });\n          return a;\n        }\n      }]);\n      return t;\n    }();\n    return t;\n  });\n  M(a, \"Core/Renderer/SVG/SVGRenderer.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGLabel.js\"], a[\"Core/Renderer/SVG/Symbols.js\"], a[\"Core/Renderer/SVG/TextBuilder.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z, H, B, u) {\n    var v = I.charts,\n      l = I.deg2rad,\n      p = I.doc,\n      t = I.isFirefox,\n      m = I.isMS,\n      h = I.isWebKit,\n      g = I.noop,\n      e = I.SVG_NS,\n      w = I.symbolSizes,\n      E = I.win,\n      F = u.addEvent,\n      d = u.attr,\n      k = u.createElement,\n      r = u.css,\n      q = u.defined,\n      G = u.destroyObjectProperties,\n      b = u.extend,\n      f = u.isArray,\n      c = u.isNumber,\n      n = u.isObject,\n      P = u.isString,\n      D = u.merge,\n      K = u.pick,\n      x = u.pInt,\n      T = u.uniqueKey;\n    var Z;\n    var V = /*#__PURE__*/function () {\n      function V(b, c, f, d, a, k, n) {\n        _classCallCheck(this, V);\n        this.width = this.url = this.style = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;\n        this.init(b, c, f, d, a, k, n);\n      }\n      _createClass(V, [{\n        key: \"init\",\n        value: function init(b, c, f, a, k, n, J) {\n          var A = this.createElement(\"svg\").attr({\n              version: \"1.1\",\n              \"class\": \"highcharts-root\"\n            }),\n            e = A.element;\n          J || A.css(this.getStyle(a));\n          b.appendChild(e);\n          d(b, \"dir\", \"ltr\");\n          -1 === b.innerHTML.indexOf(\"xmlns\") && d(e, \"xmlns\", this.SVG_NS);\n          this.box = e;\n          this.boxWrapper = A;\n          this.alignedObjects = [];\n          this.url = this.getReferenceURL();\n          this.createElement(\"desc\").add().element.appendChild(p.createTextNode(\"Created with Highcharts 11.1.0\"));\n          this.defs = this.createElement(\"defs\").add();\n          this.allowHTML = n;\n          this.forExport = k;\n          this.styledMode = J;\n          this.gradients = {};\n          this.cache = {};\n          this.cacheKeys = [];\n          this.imgCount = 0;\n          this.rootFontSize = A.getStyle(\"font-size\");\n          this.setSize(c, f, !1);\n          var q;\n          t && b.getBoundingClientRect && (c = function c() {\n            r(b, {\n              left: 0,\n              top: 0\n            });\n            q = b.getBoundingClientRect();\n            r(b, {\n              left: Math.ceil(q.left) - q.left + \"px\",\n              top: Math.ceil(q.top) - q.top + \"px\"\n            });\n          }, c(), this.unSubPixelFix = F(E, \"resize\", c));\n        }\n      }, {\n        key: \"definition\",\n        value: function definition(b) {\n          return new a([b]).addToDOM(this.defs.element);\n        }\n      }, {\n        key: \"getReferenceURL\",\n        value: function getReferenceURL() {\n          if ((t || h) && p.getElementsByTagName(\"base\").length) {\n            if (!q(Z)) {\n              var b = T();\n              b = new a([{\n                tagName: \"svg\",\n                attributes: {\n                  width: 8,\n                  height: 8\n                },\n                children: [{\n                  tagName: \"defs\",\n                  children: [{\n                    tagName: \"clipPath\",\n                    attributes: {\n                      id: b\n                    },\n                    children: [{\n                      tagName: \"rect\",\n                      attributes: {\n                        width: 4,\n                        height: 4\n                      }\n                    }]\n                  }]\n                }, {\n                  tagName: \"rect\",\n                  attributes: {\n                    id: \"hitme\",\n                    width: 8,\n                    height: 8,\n                    \"clip-path\": \"url(#\".concat(b, \")\"),\n                    fill: \"rgba(0,0,0,0.001)\"\n                  }\n                }]\n              }]).addToDOM(p.body);\n              r(b, {\n                position: \"fixed\",\n                top: 0,\n                left: 0,\n                zIndex: 9E5\n              });\n              var _c5 = p.elementFromPoint(6, 6);\n              Z = \"hitme\" === (_c5 && _c5.id);\n              p.body.removeChild(b);\n            }\n            if (Z) return E.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\");\n          }\n          return \"\";\n        }\n      }, {\n        key: \"getStyle\",\n        value: function getStyle(c) {\n          return this.style = b({\n            fontFamily: \"Helvetica, Arial, sans-serif\",\n            fontSize: \"1rem\"\n          }, c);\n        }\n      }, {\n        key: \"setStyle\",\n        value: function setStyle(b) {\n          this.boxWrapper.css(this.getStyle(b));\n        }\n      }, {\n        key: \"isHidden\",\n        value: function isHidden() {\n          return !this.boxWrapper.getBBox().width;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var b = this.defs;\n          this.box = null;\n          this.boxWrapper = this.boxWrapper.destroy();\n          G(this.gradients || {});\n          this.gradients = null;\n          this.defs = b.destroy();\n          this.unSubPixelFix && this.unSubPixelFix();\n          return this.alignedObjects = null;\n        }\n      }, {\n        key: \"createElement\",\n        value: function createElement(b) {\n          var c = new this.Element();\n          c.init(this, b);\n          return c;\n        }\n      }, {\n        key: \"getRadialAttr\",\n        value: function getRadialAttr(b, c) {\n          return {\n            cx: b[0] - b[2] / 2 + (c.cx || 0) * b[2],\n            cy: b[1] - b[2] / 2 + (c.cy || 0) * b[2],\n            r: (c.r || 0) * b[2]\n          };\n        }\n      }, {\n        key: \"shadowDefinition\",\n        value: function shadowDefinition(b) {\n          var c = [\"highcharts-drop-shadow-\".concat(this.chartIndex)].concat(_toConsumableArray(Object.keys(b).map(function (c) {\n              return b[c];\n            }))).join(\"-\").replace(/[^a-z0-9\\-]/g, \"\"),\n            f = D({\n              color: \"#000000\",\n              offsetX: 1,\n              offsetY: 1,\n              opacity: .15,\n              width: 5\n            }, b);\n          this.defs.element.querySelector(\"#\".concat(c)) || this.definition({\n            tagName: \"filter\",\n            attributes: {\n              id: c\n            },\n            children: [{\n              tagName: \"feDropShadow\",\n              attributes: {\n                dx: f.offsetX,\n                dy: f.offsetY,\n                \"flood-color\": f.color,\n                \"flood-opacity\": Math.min(5 * f.opacity, 1),\n                stdDeviation: f.width / 2\n              }\n            }]\n          });\n          return c;\n        }\n      }, {\n        key: \"buildText\",\n        value: function buildText(b) {\n          new B(b).buildSVG();\n        }\n      }, {\n        key: \"getContrast\",\n        value: function getContrast(b) {\n          b = y.parse(b).rgba.map(function (b) {\n            b /= 255;\n            return .03928 >= b ? b / 12.92 : Math.pow((b + .055) / 1.055, 2.4);\n          });\n          b = .2126 * b[0] + .7152 * b[1] + .0722 * b[2];\n          return 1.05 / (b + .05) > (b + .05) / .05 ? \"#FFFFFF\" : \"#000000\";\n        }\n      }, {\n        key: \"button\",\n        value: function button(c, f, d, k) {\n          var e = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n          var q = arguments.length > 5 ? arguments[5] : undefined;\n          var J = arguments.length > 6 ? arguments[6] : undefined;\n          var g = arguments.length > 7 ? arguments[7] : undefined;\n          var r = arguments.length > 8 ? arguments[8] : undefined;\n          var h = arguments.length > 9 ? arguments[9] : undefined;\n          var A = this.label(c, f, d, r, void 0, void 0, h, void 0, \"button\"),\n            O = this.styledMode;\n          c = e.states || {};\n          var N = 0;\n          e = D(e);\n          delete e.states;\n          var l = D({\n            color: \"#333333\",\n            cursor: \"pointer\",\n            fontSize: \"0.8em\",\n            fontWeight: \"normal\"\n          }, e.style);\n          delete e.style;\n          var w = a.filterUserAttributes(e);\n          A.attr(D({\n            padding: 8,\n            r: 2\n          }, w));\n          var p, G, R;\n          O || (w = D({\n            fill: \"#f7f7f7\",\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1\n          }, w), q = D(w, {\n            fill: \"#e6e6e6\"\n          }, a.filterUserAttributes(q || c.hover || {})), p = q.style, delete q.style, J = D(w, {\n            fill: \"#e6e9ff\",\n            style: {\n              color: \"#000000\",\n              fontWeight: \"bold\"\n            }\n          }, a.filterUserAttributes(J || c.select || {})), G = J.style, delete J.style, g = D(w, {\n            style: {\n              color: \"#cccccc\"\n            }\n          }, a.filterUserAttributes(g || c.disabled || {})), R = g.style, delete g.style);\n          F(A.element, m ? \"mouseover\" : \"mouseenter\", function () {\n            3 !== N && A.setState(1);\n          });\n          F(A.element, m ? \"mouseout\" : \"mouseleave\", function () {\n            3 !== N && A.setState(N);\n          });\n          A.setState = function (b) {\n            1 !== b && (A.state = N = b);\n            A.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][b || 0]);\n            O || (A.attr([w, q, J, g][b || 0]), b = [l, p, G, R][b || 0], n(b) && A.css(b));\n          };\n          O || (A.attr(w).css(b({\n            cursor: \"default\"\n          }, l)), h && A.text.css({\n            pointerEvents: \"none\"\n          }));\n          return A.on(\"touchstart\", function (b) {\n            return b.stopPropagation();\n          }).on(\"click\", function (b) {\n            3 !== N && k.call(A, b);\n          });\n        }\n      }, {\n        key: \"crispLine\",\n        value: function crispLine(b, c) {\n          var f = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"round\";\n          var d = b[0],\n            a = b[1];\n          q(d[1]) && d[1] === a[1] && (d[1] = a[1] = Math[f](d[1]) - c % 2 / 2);\n          q(d[2]) && d[2] === a[2] && (d[2] = a[2] = Math[f](d[2]) + c % 2 / 2);\n          return b;\n        }\n      }, {\n        key: \"path\",\n        value: function path(c) {\n          var d = this.styledMode ? {} : {\n            fill: \"none\"\n          };\n          f(c) ? d.d = c : n(c) && b(d, c);\n          return this.createElement(\"path\").attr(d);\n        }\n      }, {\n        key: \"circle\",\n        value: function circle(b, c, f) {\n          b = n(b) ? b : \"undefined\" === typeof b ? {} : {\n            x: b,\n            y: c,\n            r: f\n          };\n          c = this.createElement(\"circle\");\n          c.xSetter = c.ySetter = function (b, c, f) {\n            f.setAttribute(\"c\" + c, b);\n          };\n          return c.attr(b);\n        }\n      }, {\n        key: \"arc\",\n        value: function arc(b, c, f, d, a, k) {\n          n(b) ? (d = b, c = d.y, f = d.r, b = d.x) : d = {\n            innerR: d,\n            start: a,\n            end: k\n          };\n          b = this.symbol(\"arc\", b, c, f, f, d);\n          b.r = f;\n          return b;\n        }\n      }, {\n        key: \"rect\",\n        value: function rect(c, f, a, k, e, q) {\n          c = n(c) ? c : \"undefined\" === typeof c ? {} : {\n            x: c,\n            y: f,\n            r: e,\n            width: Math.max(a || 0, 0),\n            height: Math.max(k || 0, 0)\n          };\n          var A = this.createElement(\"rect\");\n          this.styledMode || (\"undefined\" !== typeof q && (c[\"stroke-width\"] = q, b(c, A.crisp(c))), c.fill = \"none\");\n          A.rSetter = function (b, c, f) {\n            A.r = b;\n            d(f, {\n              rx: b,\n              ry: b\n            });\n          };\n          A.rGetter = function () {\n            return A.r || 0;\n          };\n          return A.attr(c);\n        }\n      }, {\n        key: \"roundedRect\",\n        value: function roundedRect(b) {\n          return this.symbol(\"roundedRect\").attr(b);\n        }\n      }, {\n        key: \"setSize\",\n        value: function setSize(b, c, f) {\n          this.width = b;\n          this.height = c;\n          this.boxWrapper.animate({\n            width: b,\n            height: c\n          }, {\n            step: function step() {\n              this.attr({\n                viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n              });\n            },\n            duration: K(f, !0) ? void 0 : 0\n          });\n          this.alignElements();\n        }\n      }, {\n        key: \"g\",\n        value: function g(b) {\n          var c = this.createElement(\"g\");\n          return b ? c.attr({\n            \"class\": \"highcharts-\" + b\n          }) : c;\n        }\n      }, {\n        key: \"image\",\n        value: function image(b, f, d, a, k, n) {\n          var A = {\n            preserveAspectRatio: \"none\"\n          };\n          c(f) && (A.x = f);\n          c(d) && (A.y = d);\n          c(a) && (A.width = a);\n          c(k) && (A.height = k);\n          var e = this.createElement(\"image\").attr(A);\n          f = function f(c) {\n            e.attr({\n              href: b\n            });\n            n.call(e, c);\n          };\n          n ? (e.attr({\n            href: \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"\n          }), d = new E.Image(), F(d, \"load\", f), d.src = b, d.complete && f({})) : e.attr({\n            href: b\n          });\n          return e;\n        }\n      }, {\n        key: \"symbol\",\n        value: function symbol(c, f, a, n, e, g) {\n          var A = this,\n            h = /^url\\((.*?)\\)$/,\n            O = h.test(c),\n            m = !O && (this.symbols[c] ? c : \"circle\"),\n            l = m && this.symbols[m];\n          var D, G, P, t;\n          if (l) \"number\" === typeof f && (G = l.call(this.symbols, Math.round(f || 0), Math.round(a || 0), n || 0, e || 0, g)), D = this.path(G), A.styledMode || D.attr(\"fill\", \"none\"), b(D, {\n            symbolName: m || void 0,\n            x: f,\n            y: a,\n            width: n,\n            height: e\n          }), g && b(D, g);else if (O) {\n            P = c.match(h)[1];\n            var _b8 = D = this.image(P);\n            _b8.imgwidth = K(g && g.width, w[P] && w[P].width);\n            _b8.imgheight = K(g && g.height, w[P] && w[P].height);\n            t = function t(b) {\n              return b.attr({\n                width: b.width,\n                height: b.height\n              });\n            };\n            [\"width\", \"height\"].forEach(function (c) {\n              _b8[c + \"Setter\"] = function (b, c) {\n                this[c] = b;\n                var f = this.alignByTranslate,\n                  a = this.element,\n                  k = this.width,\n                  A = this.height,\n                  n = this.imgwidth,\n                  e = this.imgheight;\n                b = this[\"img\" + c];\n                if (q(b)) {\n                  var J = 1;\n                  g && \"within\" === g.backgroundSize && k && A ? (J = Math.min(k / n, A / e), d(a, {\n                    width: Math.round(n * J),\n                    height: Math.round(e * J)\n                  })) : a && a.setAttribute(c, b);\n                  f || this.translate(((k || 0) - n * J) / 2, ((A || 0) - e * J) / 2);\n                }\n              };\n            });\n            q(f) && _b8.attr({\n              x: f,\n              y: a\n            });\n            _b8.isImg = !0;\n            q(_b8.imgwidth) && q(_b8.imgheight) ? t(_b8) : (_b8.attr({\n              width: 0,\n              height: 0\n            }), k(\"img\", {\n              onload: function onload() {\n                var c = v[A.chartIndex];\n                0 === this.width && (r(this, {\n                  position: \"absolute\",\n                  top: \"-999em\"\n                }), p.body.appendChild(this));\n                w[P] = {\n                  width: this.width,\n                  height: this.height\n                };\n                _b8.imgwidth = this.width;\n                _b8.imgheight = this.height;\n                _b8.element && t(_b8);\n                this.parentNode && this.parentNode.removeChild(this);\n                A.imgCount--;\n                if (!A.imgCount && c && !c.hasLoaded) c.onload();\n              },\n              src: P\n            }), this.imgCount++);\n          }\n          return D;\n        }\n      }, {\n        key: \"clipRect\",\n        value: function clipRect(b, c, f, d) {\n          var a = T() + \"-\",\n            k = this.createElement(\"clipPath\").attr({\n              id: a\n            }).add(this.defs);\n          b = this.rect(b, c, f, d, 0).add(k);\n          b.id = a;\n          b.clipPath = k;\n          b.count = 0;\n          return b;\n        }\n      }, {\n        key: \"text\",\n        value: function text(b, c, f, d) {\n          var a = {};\n          if (d && (this.allowHTML || !this.forExport)) return this.html(b, c, f);\n          a.x = Math.round(c || 0);\n          f && (a.y = Math.round(f));\n          q(b) && (a.text = b);\n          b = this.createElement(\"text\").attr(a);\n          if (!d || this.forExport && !this.allowHTML) b.xSetter = function (b, c, f) {\n            var d = f.getElementsByTagName(\"tspan\"),\n              a = f.getAttribute(c);\n            for (var _f = 0, _k3; _f < d.length; _f++) _k3 = d[_f], _k3.getAttribute(c) === a && _k3.setAttribute(c, b);\n            f.setAttribute(c, b);\n          };\n          return b;\n        }\n      }, {\n        key: \"fontMetrics\",\n        value: function fontMetrics(b) {\n          b = x(C.prototype.getStyle.call(b, \"font-size\") || 0);\n          var c = 24 > b ? b + 3 : Math.round(1.2 * b);\n          return {\n            h: c,\n            b: Math.round(.8 * c),\n            f: b\n          };\n        }\n      }, {\n        key: \"rotCorr\",\n        value: function rotCorr(b, c, f) {\n          var d = b;\n          c && f && (d = Math.max(d * Math.cos(c * l), 4));\n          return {\n            x: -b / 3 * Math.sin(c * l),\n            y: d\n          };\n        }\n      }, {\n        key: \"pathToSegments\",\n        value: function pathToSegments(b) {\n          var f = [],\n            d = [],\n            a = {\n              A: 8,\n              C: 7,\n              H: 2,\n              L: 3,\n              M: 3,\n              Q: 5,\n              S: 5,\n              T: 3,\n              V: 2\n            };\n          for (var _k4 = 0; _k4 < b.length; _k4++) P(d[0]) && c(b[_k4]) && d.length === a[d[0].toUpperCase()] && b.splice(_k4, 0, d[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" === typeof b[_k4] && (d.length && f.push(d.slice(0)), d.length = 0), d.push(b[_k4]);\n          f.push(d.slice(0));\n          return f;\n        }\n      }, {\n        key: \"label\",\n        value: function label(b, c, f, d, a, k, n, e, q) {\n          return new z(this, b, c, f, d, a, k, n, e, q);\n        }\n      }, {\n        key: \"alignElements\",\n        value: function alignElements() {\n          this.alignedObjects.forEach(function (b) {\n            return b.align();\n          });\n        }\n      }]);\n      return V;\n    }();\n    b(V.prototype, {\n      Element: C,\n      SVG_NS: e,\n      escapes: {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        \"'\": \"&#39;\",\n        '\"': \"&quot;\"\n      },\n      symbols: H,\n      draw: g\n    });\n    L.registerRendererType(\"svg\", V, !0);\n    \"\";\n    return V;\n  });\n  M(a, \"Core/Renderer/HTML/HTMLElement.js\", [a[\"Core/Globals.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    var x = a.isFirefox,\n      C = a.isMS,\n      z = a.isWebKit,\n      H = a.win,\n      B = I.css,\n      u = I.defined,\n      v = I.extend,\n      l = I.pick,\n      p = I.pInt,\n      t = [];\n    var m = /*#__PURE__*/function (_y2) {\n      _inherits(m, _y2);\n      function m() {\n        _classCallCheck(this, m);\n        return _possibleConstructorReturn(this, _getPrototypeOf(m).apply(this, arguments));\n      }\n      _createClass(m, [{\n        key: \"getSpanCorrection\",\n        value: function getSpanCorrection(a, g, e) {\n          this.xCorr = -a * e;\n          this.yCorr = -g;\n        }\n      }, {\n        key: \"htmlCss\",\n        value: function htmlCss(a) {\n          var g = \"SPAN\" === this.element.tagName && a && \"width\" in a,\n            e = l(g && a.width, void 0);\n          var h;\n          g && (delete a.width, this.textWidth = e, h = !0);\n          a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");\n          this.styles = v(this.styles, a);\n          B(this.element, a);\n          h && this.htmlUpdateTransform();\n          return this;\n        }\n      }, {\n        key: \"htmlGetBBox\",\n        value: function htmlGetBBox() {\n          var a = this.element;\n          return {\n            x: a.offsetLeft,\n            y: a.offsetTop,\n            width: a.offsetWidth,\n            height: a.offsetHeight\n          };\n        }\n      }, {\n        key: \"htmlUpdateTransform\",\n        value: function htmlUpdateTransform() {\n          if (this.added) {\n            var a = this.renderer,\n              g = this.element,\n              e = this.x || 0,\n              m = this.y || 0,\n              l = this.textAlign || \"left\",\n              t = {\n                left: 0,\n                center: .5,\n                right: 1\n              }[l],\n              d = this.styles,\n              k = d && d.whiteSpace;\n            B(g, {\n              marginLeft: this.translateX || 0,\n              marginTop: this.translateY || 0\n            });\n            if (\"SPAN\" === g.tagName) {\n              d = this.rotation;\n              var q = this.textWidth && p(this.textWidth),\n                h = [d, l, g.innerHTML, this.textWidth, this.textAlign].join();\n              var b = !1;\n              if (q !== this.oldTextWidth) {\n                if (this.textPxLength) var r = this.textPxLength;else B(g, {\n                  width: \"\",\n                  whiteSpace: k || \"nowrap\"\n                }), r = g.offsetWidth;\n                (q > this.oldTextWidth || r > q) && (/[ \\-]/.test(g.textContent || g.innerText) || \"ellipsis\" === g.style.textOverflow) && (B(g, {\n                  width: r > q || d ? q + \"px\" : \"auto\",\n                  display: \"block\",\n                  whiteSpace: k || \"normal\"\n                }), this.oldTextWidth = q, b = !0);\n              }\n              this.hasBoxWidthChanged = b;\n              h !== this.cTT && (a = a.fontMetrics(g).b, !u(d) || d === (this.oldRotation || 0) && l === this.oldAlign || this.setSpanRotation(d, t, a), this.getSpanCorrection(!u(d) && this.textPxLength || g.offsetWidth, a, t, d, l));\n              B(g, {\n                left: e + (this.xCorr || 0) + \"px\",\n                top: m + (this.yCorr || 0) + \"px\"\n              });\n              this.cTT = h;\n              this.oldRotation = d;\n              this.oldAlign = l;\n            }\n          } else this.alignOnAdd = !0;\n        }\n      }, {\n        key: \"setSpanRotation\",\n        value: function setSpanRotation(a, g, e) {\n          var h = {},\n            m = C && !/Edge/.test(H.navigator.userAgent) ? \"-ms-transform\" : z ? \"-webkit-transform\" : x ? \"MozTransform\" : H.opera ? \"-o-transform\" : void 0;\n          m && (h[m] = h.transform = \"rotate(\" + a + \"deg)\", h[m + (x ? \"Origin\" : \"-origin\")] = h.transformOrigin = 100 * g + \"% \" + e + \"px\", B(this.element, h));\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(a) {\n          if (I.pushUnique(t, a)) {\n            var g = m.prototype,\n              e = a.prototype;\n            e.getSpanCorrection = g.getSpanCorrection;\n            e.htmlCss = g.htmlCss;\n            e.htmlGetBBox = g.htmlGetBBox;\n            e.htmlUpdateTransform = g.htmlUpdateTransform;\n            e.setSpanRotation = g.setSpanRotation;\n          }\n          return a;\n        }\n      }]);\n      return m;\n    }(y);\n    return m;\n  });\n  M(a, \"Core/Renderer/HTML/HTMLRenderer.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L) {\n    var x = L.attr,\n      z = L.createElement,\n      H = L.extend,\n      B = L.pick,\n      u = [];\n    var v = /*#__PURE__*/function (_I) {\n      _inherits(v, _I);\n      function v() {\n        _classCallCheck(this, v);\n        return _possibleConstructorReturn(this, _getPrototypeOf(v).apply(this, arguments));\n      }\n      _createClass(v, [{\n        key: \"html\",\n        value: function html(l, p, t) {\n          var m = this.createElement(\"span\"),\n            h = m.element,\n            g = m.renderer,\n            e = function e(a, _e2) {\n              [\"opacity\", \"visibility\"].forEach(function (g) {\n                a[g + \"Setter\"] = function (d, k, r) {\n                  var q = a.div ? a.div.style : _e2;\n                  y.prototype[g + \"Setter\"].call(this, d, k, r);\n                  q && (q[k] = d);\n                };\n              });\n              a.addedSetters = !0;\n            };\n          m.textSetter = function (e) {\n            e !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a.setElementHTML(this.element, B(e, \"\")), this.textStr = e, m.doTransform = !0);\n          };\n          e(m, m.element.style);\n          m.xSetter = m.ySetter = m.alignSetter = m.rotationSetter = function (a, e) {\n            \"align\" === e ? m.alignValue = m.textAlign = a : m[e] = a;\n            m.doTransform = !0;\n          };\n          m.afterSetters = function () {\n            this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n          };\n          m.attr({\n            text: l,\n            x: Math.round(p),\n            y: Math.round(t)\n          }).css({\n            position: \"absolute\"\n          });\n          g.styledMode || m.css({\n            fontFamily: this.style.fontFamily,\n            fontSize: this.style.fontSize\n          });\n          h.style.whiteSpace = \"nowrap\";\n          m.css = m.htmlCss;\n          m.add = function (a) {\n            var l = g.box.parentNode,\n              w = [];\n            var d;\n            if (this.parentGroup = a) {\n              if (d = a.div, !d) {\n                for (; a;) w.push(a), a = a.parentGroup;\n                w.reverse().forEach(function (a) {\n                  function k(f, c) {\n                    a[c] = f;\n                    \"translateX\" === c ? b.left = f + \"px\" : b.top = f + \"px\";\n                    a.doTransform = !0;\n                  }\n                  var q = x(a.element, \"class\"),\n                    g = a.styles || {};\n                  d = a.div = a.div || z(\"div\", q ? {\n                    className: q\n                  } : void 0, {\n                    position: \"absolute\",\n                    left: (a.translateX || 0) + \"px\",\n                    top: (a.translateY || 0) + \"px\",\n                    display: a.display,\n                    opacity: a.opacity,\n                    visibility: a.visibility\n                  }, d || l);\n                  var b = d.style;\n                  H(a, {\n                    classSetter: function (b) {\n                      return function (c) {\n                        this.element.setAttribute(\"class\", c);\n                        b.className = c;\n                      };\n                    }(d),\n                    css: function css(f) {\n                      m.css.call(a, f);\n                      [\"cursor\", \"pointerEvents\"].forEach(function (c) {\n                        f[c] && (b[c] = f[c]);\n                      });\n                      return a;\n                    },\n                    on: function on() {\n                      w[0].div && m.on.apply({\n                        element: w[0].div,\n                        onEvents: a.onEvents\n                      }, arguments);\n                      return a;\n                    },\n                    translateXSetter: k,\n                    translateYSetter: k\n                  });\n                  a.addedSetters || e(a);\n                  a.css(g);\n                });\n              }\n            } else d = l;\n            d.appendChild(h);\n            m.added = !0;\n            m.alignOnAdd && m.htmlUpdateTransform();\n            return m;\n          };\n          return m;\n        }\n      }], [{\n        key: \"compose\",\n        value: function compose(a) {\n          L.pushUnique(u, a) && (a.prototype.html = v.prototype.html);\n          return a;\n        }\n      }]);\n      return v;\n    }(I);\n    return v;\n  });\n  M(a, \"Core/Axis/AxisDefaults.js\", [], function () {\n    var a;\n    (function (a) {\n      a.defaultXAxisOptions = {\n        alignTicks: !0,\n        allowDecimals: void 0,\n        panningEnabled: !0,\n        zIndex: 2,\n        zoomEnabled: !0,\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e %b\"\n          },\n          week: {\n            main: \"%e %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        gridLineDashStyle: \"Solid\",\n        gridZIndex: 1,\n        labels: {\n          autoRotation: void 0,\n          autoRotationLimit: 80,\n          distance: 15,\n          enabled: !0,\n          indentation: 10,\n          overflow: \"justify\",\n          padding: 5,\n          reserveSpace: void 0,\n          rotation: void 0,\n          staggerLines: 0,\n          step: 0,\n          useHTML: !1,\n          zIndex: 7,\n          style: {\n            color: \"#333333\",\n            cursor: \"default\",\n            fontSize: \"0.8em\"\n          }\n        },\n        maxPadding: .01,\n        minorGridLineDashStyle: \"Solid\",\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minorTicksPerMajor: 5,\n        minPadding: .01,\n        offset: void 0,\n        opposite: !1,\n        reversed: void 0,\n        reversedStacks: !1,\n        showEmpty: !0,\n        showFirstLabel: !0,\n        showLastLabel: !0,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          rotation: 0,\n          useHTML: !1,\n          x: 0,\n          y: 0,\n          style: {\n            color: \"#666666\",\n            fontSize: \"0.8em\"\n          }\n        },\n        type: \"linear\",\n        uniqueNames: !0,\n        visible: !0,\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#333333\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        gridLineWidth: void 0,\n        tickColor: \"#333333\"\n      };\n      a.defaultYAxisOptions = {\n        reversedStacks: !0,\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: void 0\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          animation: {},\n          allowOverlap: !1,\n          enabled: !1,\n          crop: !0,\n          overflow: \"justify\",\n          formatter: function formatter() {\n            var a = this.axis.chart.numberFormatter;\n            return a(this.total || 0, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"0.7em\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      };\n      a.defaultLeftAxisOptions = {\n        title: {\n          rotation: 270\n        }\n      };\n      a.defaultRightAxisOptions = {\n        title: {\n          rotation: 90\n        }\n      };\n      a.defaultBottomAxisOptions = {\n        labels: {\n          autoRotation: [-45]\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      a.defaultTopAxisOptions = {\n        labels: {\n          autoRotation: [-45]\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n    })(a || (a = {}));\n    return a;\n  });\n  M(a, \"Core/Foundation.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    var x = a.addEvent,\n      I = a.isFunction,\n      L = a.objectEach,\n      C = a.removeEvent;\n    var z;\n    (function (a) {\n      a.registerEventOptions = function (a, u) {\n        a.eventOptions = a.eventOptions || {};\n        L(u.events, function (v, l) {\n          a.eventOptions[l] !== v && (a.eventOptions[l] && (C(a, l, a.eventOptions[l]), delete a.eventOptions[l]), I(v) && (a.eventOptions[l] = v, x(a, l, v, {\n            order: 0\n          })));\n        });\n      };\n    })(z || (z = {}));\n    return z;\n  });\n  M(a, \"Core/Axis/Tick.js\", [a[\"Core/Templating.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    var x = y.deg2rad,\n      C = I.clamp,\n      z = I.correctFloat,\n      H = I.defined,\n      B = I.destroyObjectProperties,\n      u = I.extend,\n      v = I.fireEvent,\n      l = I.isNumber,\n      p = I.merge,\n      t = I.objectEach,\n      m = I.pick;\n    var h = /*#__PURE__*/function () {\n      function h(a, e, _h2, m, l) {\n        _classCallCheck(this, h);\n        this.isNewLabel = this.isNew = !0;\n        this.axis = a;\n        this.pos = e;\n        this.type = _h2 || \"\";\n        this.parameters = l || {};\n        this.tickmarkOffset = this.parameters.tickmarkOffset;\n        this.options = this.parameters.options;\n        v(this, \"init\");\n        _h2 || m || this.addLabel();\n      }\n      _createClass(h, [{\n        key: \"addLabel\",\n        value: function addLabel() {\n          var g = this,\n            e = g.axis;\n          var h = e.options;\n          var p = e.chart;\n          var t = e.categories;\n          var d = e.logarithmic,\n            k = e.names,\n            r = g.pos,\n            q = m(g.options && g.options.labels, h.labels);\n          var G = e.tickPositions;\n          var b = r === G[0],\n            f = r === G[G.length - 1],\n            c = (!q.step || 1 === q.step) && 1 === e.tickInterval;\n          G = G.info;\n          var n = g.label,\n            P,\n            D,\n            K;\n          t = this.parameters.category || (t ? m(t[r], k[r], r) : r);\n          d && l(t) && (t = z(d.lin2log(t)));\n          e.dateTime && (G ? (D = p.time.resolveDTLFormat(h.dateTimeLabelFormats[!h.grid && G.higherRanks[r] || G.unitName]), P = D.main) : l(t) && (P = e.dateTime.getXDateFormat(t, h.dateTimeLabelFormats || {})));\n          g.isFirst = b;\n          g.isLast = f;\n          var x = {\n            axis: e,\n            chart: p,\n            dateTimeLabelFormat: P,\n            isFirst: b,\n            isLast: f,\n            pos: r,\n            tick: g,\n            tickPositionInfo: G,\n            value: t\n          };\n          v(this, \"labelFormat\", x);\n          var B = function B(b) {\n            return q.formatter ? q.formatter.call(b, b) : q.format ? (b.text = e.defaultLabelFormatter.call(b, b), a.format(q.format, b, p)) : e.defaultLabelFormatter.call(b, b);\n          };\n          h = B.call(x, x);\n          var y = D && D.list;\n          g.shortenLabel = y ? function () {\n            for (K = 0; K < y.length; K++) if (u(x, {\n              dateTimeLabelFormat: y[K]\n            }), n.attr({\n              text: B.call(x, x)\n            }), n.getBBox().width < e.getSlotWidth(g) - 2 * q.padding) return;\n            n.attr({\n              text: \"\"\n            });\n          } : void 0;\n          c && e._addedPlotLB && g.moveLabel(h, q);\n          H(n) || g.movedLabel ? n && n.textStr !== h && !c && (!n.textWidth || q.style.width || n.styles.width || n.css({\n            width: null\n          }), n.attr({\n            text: h\n          }), n.textPxLength = n.getBBox().width) : (g.label = n = g.createLabel({\n            x: 0,\n            y: 0\n          }, h, q), g.rotation = 0);\n        }\n      }, {\n        key: \"createLabel\",\n        value: function createLabel(a, e, h) {\n          var g = this.axis,\n            m = g.chart;\n          if (a = H(e) && h.enabled ? m.renderer.text(e, a.x, a.y, h.useHTML).add(g.labelGroup) : null) m.styledMode || a.css(p(h.style)), a.textPxLength = a.getBBox().width;\n          return a;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          B(this, this.axis);\n        }\n      }, {\n        key: \"getPosition\",\n        value: function getPosition(a, e, h, m) {\n          var g = this.axis,\n            d = g.chart,\n            k = m && d.oldChartHeight || d.chartHeight;\n          a = {\n            x: a ? z(g.translate(e + h, void 0, void 0, m) + g.transB) : g.left + g.offset + (g.opposite ? (m && d.oldChartWidth || d.chartWidth) - g.right - g.left : 0),\n            y: a ? k - g.bottom + g.offset - (g.opposite ? g.height : 0) : z(k - g.translate(e + h, void 0, void 0, m) - g.transB)\n          };\n          a.y = C(a.y, -1E5, 1E5);\n          v(this, \"afterGetPosition\", {\n            pos: a\n          });\n          return a;\n        }\n      }, {\n        key: \"getLabelPosition\",\n        value: function getLabelPosition(a, e, h, l, p, d, k, r) {\n          var q = this.axis,\n            g = q.transA,\n            b = q.isLinked && q.linkedParent ? q.linkedParent.reversed : q.reversed,\n            f = q.staggerLines,\n            c = q.tickRotCorr || {\n              x: 0,\n              y: 0\n            },\n            n = l || q.reserveSpaceDefault ? 0 : -q.labelOffset * (\"center\" === q.labelAlign ? .5 : 1),\n            w = p.distance,\n            D = {};\n          h = 0 === q.side ? h.rotation ? -w : -h.getBBox().height : 2 === q.side ? c.y + w : Math.cos(h.rotation * x) * (c.y - h.getBBox(!1, 0).height / 2);\n          H(p.y) && (h = 0 === q.side && q.horiz ? p.y + h : p.y);\n          a = a + m(p.x, [0, 1, 0, -1][q.side] * w) + n + c.x - (d && l ? d * g * (b ? -1 : 1) : 0);\n          e = e + h - (d && !l ? d * g * (b ? 1 : -1) : 0);\n          f && (l = k / (r || 1) % f, q.opposite && (l = f - l - 1), e += q.labelOffset / f * l);\n          D.x = a;\n          D.y = Math.round(e);\n          v(this, \"afterGetLabelPosition\", {\n            pos: D,\n            tickmarkOffset: d,\n            index: k\n          });\n          return D;\n        }\n      }, {\n        key: \"getLabelSize\",\n        value: function getLabelSize() {\n          return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n        }\n      }, {\n        key: \"getMarkPath\",\n        value: function getMarkPath(a, e, h, m, l, d) {\n          return d.crispLine([[\"M\", a, e], [\"L\", a + (l ? 0 : -h), e + (l ? h : 0)]], m);\n        }\n      }, {\n        key: \"handleOverflow\",\n        value: function handleOverflow(a) {\n          var e = this.axis,\n            g = e.options.labels,\n            h = a.x;\n          var l = e.chart.chartWidth,\n            d = e.chart.spacing;\n          var k = m(e.labelLeft, Math.min(e.pos, d[3]));\n          d = m(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, l - d[1]));\n          var r = this.label,\n            q = this.rotation,\n            p = {\n              left: 0,\n              center: .5,\n              right: 1\n            }[e.labelAlign || r.attr(\"align\")],\n            b = r.getBBox().width,\n            f = e.getSlotWidth(this),\n            c = {};\n          var n = f,\n            t = 1,\n            D;\n          if (q || \"justify\" !== g.overflow) 0 > q && h - p * b < k ? D = Math.round(h / Math.cos(q * x) - k) : 0 < q && h + p * b > d && (D = Math.round((l - h) / Math.cos(q * x)));else if (l = h + (1 - p) * b, h - p * b < k ? n = a.x + n * (1 - p) - k : l > d && (n = d - a.x + n * p, t = -1), n = Math.min(f, n), n < f && \"center\" === e.labelAlign && (a.x += t * (f - n - p * (f - Math.min(b, n)))), b > n || e.autoRotation && (r.styles || {}).width) D = n;\n          D && (this.shortenLabel ? this.shortenLabel() : (c.width = Math.floor(D) + \"px\", (g.style || {}).textOverflow || (c.textOverflow = \"ellipsis\"), r.css(c)));\n        }\n      }, {\n        key: \"moveLabel\",\n        value: function moveLabel(a, e) {\n          var g = this;\n          var h = g.label;\n          var m = g.axis;\n          var d = !1;\n          h && h.textStr === a ? (g.movedLabel = h, d = !0, delete g.label) : t(m.ticks, function (k) {\n            d || k.isNew || k === g || !k.label || k.label.textStr !== a || (g.movedLabel = k.label, d = !0, k.labelPos = g.movedLabel.xy, delete k.label);\n          });\n          d || !g.labelPos && !h || (h = g.labelPos || h.xy, g.movedLabel = g.createLabel(h, a, e), g.movedLabel && g.movedLabel.attr({\n            opacity: 0\n          }));\n        }\n      }, {\n        key: \"render\",\n        value: function render(a, e, h) {\n          var g = this.axis,\n            l = g.horiz,\n            d = this.pos,\n            k = m(this.tickmarkOffset, g.tickmarkOffset);\n          d = this.getPosition(l, d, k, e);\n          k = d.x;\n          var r = d.y;\n          g = l && k === g.pos + g.len || !l && r === g.pos ? -1 : 1;\n          l = m(h, this.label && this.label.newOpacity, 1);\n          h = m(h, 1);\n          this.isActive = !0;\n          this.renderGridLine(e, h, g);\n          this.renderMark(d, h, g);\n          this.renderLabel(d, e, l, a);\n          this.isNew = !1;\n          v(this, \"afterRender\");\n        }\n      }, {\n        key: \"renderGridLine\",\n        value: function renderGridLine(a, e, h) {\n          var g = this.axis,\n            l = g.options,\n            d = {},\n            k = this.pos,\n            r = this.type,\n            q = m(this.tickmarkOffset, g.tickmarkOffset),\n            p = g.chart.renderer;\n          var b = this.gridLine,\n            f = l.gridLineWidth,\n            c = l.gridLineColor,\n            n = l.gridLineDashStyle;\n          \"minor\" === this.type && (f = l.minorGridLineWidth, c = l.minorGridLineColor, n = l.minorGridLineDashStyle);\n          b || (g.chart.styledMode || (d.stroke = c, d[\"stroke-width\"] = f || 0, d.dashstyle = n), r || (d.zIndex = 1), a && (e = 0), this.gridLine = b = p.path().attr(d).addClass(\"highcharts-\" + (r ? r + \"-\" : \"\") + \"grid-line\").add(g.gridGroup));\n          if (b && (h = g.getPlotLinePath({\n            value: k + q,\n            lineWidth: b.strokeWidth() * h,\n            force: \"pass\",\n            old: a,\n            acrossPanes: !1\n          }))) b[a || this.isNew ? \"attr\" : \"animate\"]({\n            d: h,\n            opacity: e\n          });\n        }\n      }, {\n        key: \"renderMark\",\n        value: function renderMark(a, e, h) {\n          var g = this.axis;\n          var l = g.options;\n          var d = g.chart.renderer,\n            k = this.type,\n            r = g.tickSize(k ? k + \"Tick\" : \"tick\"),\n            q = a.x;\n          a = a.y;\n          var p = m(l[\"minor\" !== k ? \"tickWidth\" : \"minorTickWidth\"], !k && g.isXAxis ? 1 : 0);\n          l = l[\"minor\" !== k ? \"tickColor\" : \"minorTickColor\"];\n          var b = this.mark;\n          var f = !b;\n          r && (g.opposite && (r[0] = -r[0]), b || (this.mark = b = d.path().addClass(\"highcharts-\" + (k ? k + \"-\" : \"\") + \"tick\").add(g.axisGroup), g.chart.styledMode || b.attr({\n            stroke: l,\n            \"stroke-width\": p\n          })), b[f ? \"attr\" : \"animate\"]({\n            d: this.getMarkPath(q, a, r[0], b.strokeWidth() * h, g.horiz, d),\n            opacity: e\n          }));\n        }\n      }, {\n        key: \"renderLabel\",\n        value: function renderLabel(a, e, h, p) {\n          var g = this.axis;\n          var d = g.horiz,\n            k = g.options,\n            r = this.label,\n            q = k.labels,\n            t = q.step;\n          g = m(this.tickmarkOffset, g.tickmarkOffset);\n          var b = a.x;\n          a = a.y;\n          var f = !0;\n          r && l(b) && (r.xy = a = this.getLabelPosition(b, a, r, d, q, g, p, t), this.isFirst && !this.isLast && !k.showFirstLabel || this.isLast && !this.isFirst && !k.showLastLabel ? f = !1 : !d || q.step || q.rotation || e || 0 === h || this.handleOverflow(a), t && p % t && (f = !1), f && l(a.y) ? (a.opacity = h, r[this.isNewLabel ? \"attr\" : \"animate\"](a).show(!0), this.isNewLabel = !1) : (r.hide(), this.isNewLabel = !0));\n        }\n      }, {\n        key: \"replaceMovedLabel\",\n        value: function replaceMovedLabel() {\n          var a = this.label,\n            e = this.axis;\n          a && !this.isNew && (a.animate({\n            opacity: 0\n          }, void 0, a.destroy), delete this.label);\n          e.isDirty = !0;\n          this.label = this.movedLabel;\n          delete this.movedLabel;\n        }\n      }]);\n      return h;\n    }();\n    \"\";\n    return h;\n  });\n  M(a, \"Core/Axis/Axis.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/AxisDefaults.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Defaults.js\"], a[\"Core/Foundation.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/Tick.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z, H, B) {\n    var u = a.animObject,\n      v = L.defaultOptions,\n      l = C.registerEventOptions,\n      p = z.deg2rad,\n      t = B.arrayMax,\n      m = B.arrayMin,\n      h = B.clamp,\n      g = B.correctFloat,\n      e = B.defined,\n      w = B.destroyObjectProperties,\n      x = B.erase,\n      F = B.error,\n      d = B.extend,\n      k = B.fireEvent,\n      r = B.getClosestDistance,\n      q = B.insertItem,\n      G = B.isArray,\n      b = B.isNumber,\n      f = B.isString,\n      c = B.merge,\n      n = B.normalizeTickInterval,\n      P = B.objectEach,\n      D = B.pick,\n      K = B.relativeLength,\n      X = B.removeEvent,\n      T = B.splat,\n      Z = B.syncTimeout,\n      V = function V(b, c) {\n        return n(c, void 0, void 0, D(b.options.allowDecimals, .5 > c || void 0 !== b.tickAmount), !!b.tickAmount);\n      };\n    var Y = /*#__PURE__*/function () {\n      function Y(b, c, f) {\n        _classCallCheck(this, Y);\n        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.index = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;\n        this.init(b, c, f);\n      }\n      _createClass(Y, [{\n        key: \"init\",\n        value: function init(c, f) {\n          var a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.coll;\n          var d = \"xAxis\" === a;\n          this.chart = c;\n          this.horiz = this.isZAxis || (c.inverted ? !d : d);\n          this.isXAxis = d;\n          this.coll = a;\n          k(this, \"init\", {\n            userOptions: f\n          });\n          this.opposite = D(f.opposite, this.opposite);\n          this.side = D(f.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);\n          this.setOptions(f);\n          a = this.options;\n          var A = a.labels,\n            n = a.type;\n          this.userOptions = f;\n          this.minPixelPadding = 0;\n          this.reversed = D(a.reversed, this.reversed);\n          this.visible = a.visible;\n          this.zoomEnabled = a.zoomEnabled;\n          this.hasNames = \"category\" === n || !0 === a.categories;\n          this.categories = a.categories || (this.hasNames ? [] : void 0);\n          this.names || (this.names = [], this.names.keys = {});\n          this.plotLinesAndBandsGroups = {};\n          this.positiveValuesOnly = !!this.logarithmic;\n          this.isLinked = e(a.linkedTo);\n          this.ticks = {};\n          this.labelEdge = [];\n          this.minorTicks = {};\n          this.plotLinesAndBands = [];\n          this.alternateBands = {};\n          this.len = 0;\n          this.minRange = this.userMinRange = a.minRange || a.maxZoom;\n          this.range = a.range;\n          this.offset = a.offset || 0;\n          this.min = this.max = null;\n          f = D(a.crosshair, T(c.options.tooltip.crosshairs)[d ? 0 : 1]);\n          this.crosshair = !0 === f ? {} : f;\n          -1 === c.axes.indexOf(this) && (d ? c.axes.splice(c.xAxis.length, 0, this) : c.axes.push(this), q(this, c[this.coll]));\n          c.orderItems(this.coll);\n          this.series = this.series || [];\n          c.inverted && !this.isZAxis && d && \"undefined\" === typeof this.reversed && (this.reversed = !0);\n          this.labelRotation = b(A.rotation) ? A.rotation : void 0;\n          l(this, a);\n          k(this, \"afterInit\");\n        }\n      }, {\n        key: \"setOptions\",\n        value: function setOptions(b) {\n          this.options = c(y.defaultXAxisOptions, \"yAxis\" === this.coll && y.defaultYAxisOptions, [y.defaultTopAxisOptions, y.defaultRightAxisOptions, y.defaultBottomAxisOptions, y.defaultLeftAxisOptions][this.side], c(v[this.coll], b));\n          k(this, \"afterSetOptions\", {\n            userOptions: b\n          });\n        }\n      }, {\n        key: \"defaultLabelFormatter\",\n        value: function defaultLabelFormatter(c) {\n          var f = this.axis;\n          c = this.chart.numberFormatter;\n          var a = b(this.value) ? this.value : NaN,\n            d = f.chart.time,\n            k = this.dateTimeLabelFormat;\n          var n = v.lang;\n          var A = n.numericSymbols;\n          n = n.numericSymbolMagnitude || 1E3;\n          var e = f.logarithmic ? Math.abs(a) : f.tickInterval;\n          var q = A && A.length,\n            g;\n          if (f.categories) g = \"\".concat(this.value);else if (k) g = d.dateFormat(k, a);else if (q && 1E3 <= e) for (; q-- && \"undefined\" === typeof g;) f = Math.pow(n, q + 1), e >= f && 0 === 10 * a % f && null !== A[q] && 0 !== a && (g = c(a / f, -1) + A[q]);\n          \"undefined\" === typeof g && (g = 1E4 <= Math.abs(a) ? c(a, -1) : c(a, -1, void 0, \"\"));\n          return g;\n        }\n      }, {\n        key: \"getSeriesExtremes\",\n        value: function getSeriesExtremes() {\n          var c = this,\n            f = c.chart;\n          var a;\n          k(this, \"getSeriesExtremes\", null, function () {\n            c.hasVisibleSeries = !1;\n            c.dataMin = c.dataMax = c.threshold = null;\n            c.softThreshold = !c.isXAxis;\n            c.series.forEach(function (d) {\n              if (d.visible || !f.options.chart.ignoreHiddenSeries) {\n                var k = d.options;\n                var _f2 = k.threshold,\n                  _n,\n                  A;\n                c.hasVisibleSeries = !0;\n                c.positiveValuesOnly && 0 >= _f2 && (_f2 = null);\n                if (c.isXAxis) (k = d.xData) && k.length && (k = c.logarithmic ? k.filter(function (b) {\n                  return 0 < b;\n                }) : k, a = d.getXExtremes(k), _n = a.min, A = a.max, b(_n) || _n instanceof Date || (k = k.filter(b), a = d.getXExtremes(k), _n = a.min, A = a.max), k.length && (c.dataMin = Math.min(D(c.dataMin, _n), _n), c.dataMax = Math.max(D(c.dataMax, A), A)));else if (d = d.applyExtremes(), b(d.dataMin) && (_n = d.dataMin, c.dataMin = Math.min(D(c.dataMin, _n), _n)), b(d.dataMax) && (A = d.dataMax, c.dataMax = Math.max(D(c.dataMax, A), A)), e(_f2) && (c.threshold = _f2), !k.softThreshold || c.positiveValuesOnly) c.softThreshold = !1;\n              }\n            });\n          });\n          k(this, \"afterGetSeriesExtremes\");\n        }\n      }, {\n        key: \"translate\",\n        value: function translate(c, f, a, d, k, n) {\n          var e = this.linkedParent || this,\n            A = d && e.old ? e.old.min : e.min;\n          if (!b(A)) return NaN;\n          var q = e.minPixelPadding;\n          k = (e.isOrdinal || e.brokenAxis && e.brokenAxis.hasBreaks || e.logarithmic && k) && e.lin2val;\n          var J = 1,\n            h = 0;\n          d = d && e.old ? e.old.transA : e.transA;\n          d || (d = e.transA);\n          a && (J *= -1, h = e.len);\n          e.reversed && (J *= -1, h -= J * (e.sector || e.len));\n          f ? (n = (c * J + h - q) / d + A, k && (n = e.lin2val(n))) : (k && (c = e.val2lin(c)), c = J * (c - A) * d, n = (e.isRadial ? c : g(c)) + h + J * q + (b(n) ? d * n : 0));\n          return n;\n        }\n      }, {\n        key: \"toPixels\",\n        value: function toPixels(b, c) {\n          return this.translate(b, !1, !this.horiz, void 0, !0) + (c ? 0 : this.pos);\n        }\n      }, {\n        key: \"toValue\",\n        value: function toValue(b, c) {\n          return this.translate(b - (c ? 0 : this.pos), !0, !this.horiz, void 0, !0);\n        }\n      }, {\n        key: \"getPlotLinePath\",\n        value: function getPlotLinePath(c) {\n          function f(b, c, f) {\n            \"pass\" !== t && (b < c || b > f) && (t ? b = h(b, c, f) : K = !0);\n            return b;\n          }\n          var a = this,\n            d = a.chart,\n            n = a.left,\n            e = a.top,\n            A = c.old,\n            q = c.value,\n            g = c.lineWidth,\n            r = A && d.oldChartHeight || d.chartHeight,\n            m = A && d.oldChartWidth || d.chartWidth,\n            l = a.transB;\n          var p = c.translatedValue,\n            t = c.force,\n            P,\n            w,\n            R,\n            Q,\n            K;\n          c = {\n            value: q,\n            lineWidth: g,\n            old: A,\n            force: t,\n            acrossPanes: c.acrossPanes,\n            translatedValue: p\n          };\n          k(this, \"getPlotLinePath\", c, function (c) {\n            p = D(p, a.translate(q, void 0, void 0, A));\n            p = h(p, -1E5, 1E5);\n            P = R = Math.round(p + l);\n            w = Q = Math.round(r - p - l);\n            b(p) ? a.horiz ? (w = e, Q = r - a.bottom, P = R = f(P, n, n + a.width)) : (P = n, R = m - a.right, w = Q = f(w, e, e + a.height)) : (K = !0, t = !1);\n            c.path = K && !t ? null : d.renderer.crispLine([[\"M\", P, w], [\"L\", R, Q]], g || 1);\n          });\n          return c.path;\n        }\n      }, {\n        key: \"getLinearTickPositions\",\n        value: function getLinearTickPositions(b, c, f) {\n          var a = g(Math.floor(c / b) * b);\n          f = g(Math.ceil(f / b) * b);\n          var d = [];\n          var k, n;\n          g(a + b) === a && (n = 20);\n          if (this.single) return [c];\n          for (c = a; c <= f;) {\n            d.push(c);\n            c = g(c + b, n);\n            if (c === k) break;\n            k = c;\n          }\n          return d;\n        }\n      }, {\n        key: \"getMinorTickInterval\",\n        value: function getMinorTickInterval() {\n          var b = this.options;\n          return !0 === b.minorTicks ? D(b.minorTickInterval, \"auto\") : !1 === b.minorTicks ? null : b.minorTickInterval;\n        }\n      }, {\n        key: \"getMinorTickPositions\",\n        value: function getMinorTickPositions() {\n          var b = this.options;\n          var c = this.tickPositions,\n            f = this.minorTickInterval;\n          var a = this.pointRangePadding || 0;\n          var d = this.min - a;\n          a = this.max + a;\n          var k = a - d;\n          var n = [];\n          if (k && k / f < this.len / 3) {\n            var _k5 = this.logarithmic;\n            if (_k5) this.paddedTicks.forEach(function (b, c, a) {\n              c && n.push.apply(n, _k5.getLogTickPositions(f, a[c - 1], a[c], !0));\n            });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) n = n.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(f), d, a, b.startOfWeek));else for (b = d + (c[0] - d) % f; b <= a && b !== n[0]; b += f) n.push(b);\n          }\n          0 !== n.length && this.trimTicks(n);\n          return n;\n        }\n      }, {\n        key: \"adjustForMinRange\",\n        value: function adjustForMinRange() {\n          var b = this.options,\n            c = this.logarithmic;\n          var f = this.min;\n          var a = this.max;\n          var d, k;\n          if (this.isXAxis && \"undefined\" === typeof this.minRange && !c) if (e(b.min) || e(b.max) || e(b.floor) || e(b.ceiling)) this.minRange = null;else {\n            var n = r(this.series.map(function (b) {\n              var c;\n              return (b.xIncrement ? null === (c = b.xData) || void 0 === c ? void 0 : c.slice(0, 2) : b.xData) || [];\n            })) || 0;\n            this.minRange = Math.min(5 * n, this.dataMax - this.dataMin);\n          }\n          a - f < this.minRange && (n = this.dataMax - this.dataMin >= this.minRange, k = this.minRange, a = (k - a + f) / 2, d = [f - a, D(b.min, f - a)], n && (d[2] = c ? c.log2lin(this.dataMin) : this.dataMin), f = t(d), a = [f + k, D(b.max, f + k)], n && (a[2] = c ? c.log2lin(this.dataMax) : this.dataMax), a = m(a), a - f < k && (d[0] = a - k, d[1] = D(b.min, a - k), f = t(d)));\n          this.min = f;\n          this.max = a;\n        }\n      }, {\n        key: \"getClosest\",\n        value: function getClosest() {\n          var b, c;\n          if (this.categories) c = 1;else {\n            var _f3 = [];\n            this.series.forEach(function (b) {\n              var a;\n              var d = b.closestPointRange,\n                k = b.visible || !b.chart.options.chart.ignoreHiddenSeries;\n              1 === (null === (a = b.xData) || void 0 === a ? void 0 : a.length) ? _f3.push(b.xData[0]) : !b.noSharedTooltip && e(d) && k && (c = e(c) ? Math.min(c, d) : d);\n            });\n            _f3.length && (_f3.sort(function (b, c) {\n              return b - c;\n            }), b = r([_f3]));\n          }\n          return b && c ? Math.min(b, c) : b || c;\n        }\n      }, {\n        key: \"nameToX\",\n        value: function nameToX(b) {\n          var c = G(this.options.categories),\n            f = c ? this.categories : this.names;\n          var a = b.options.x,\n            d;\n          b.series.requireSorting = !1;\n          e(a) || (a = this.options.uniqueNames && f ? c ? f.indexOf(b.name) : D(f.keys[b.name], -1) : b.series.autoIncrement());\n          -1 === a ? !c && f && (d = f.length) : d = a;\n          \"undefined\" !== typeof d ? (this.names[d] = b.name, this.names.keys[b.name] = d) : b.x && (d = b.x);\n          return d;\n        }\n      }, {\n        key: \"updateNames\",\n        value: function updateNames() {\n          var b = this,\n            c = this.names;\n          0 < c.length && (Object.keys(c.keys).forEach(function (b) {\n            delete c.keys[b];\n          }), c.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (c) {\n            c.xIncrement = null;\n            if (!c.points || c.isDirtyData) b.max = Math.max(b.max, c.xData.length - 1), c.processData(), c.generatePoints();\n            c.data.forEach(function (f, a) {\n              var d;\n              f && f.options && \"undefined\" !== typeof f.name && (d = b.nameToX(f), \"undefined\" !== typeof d && d !== f.x && (f.x = d, c.xData[a] = d));\n            });\n          }));\n        }\n      }, {\n        key: \"setAxisTranslation\",\n        value: function setAxisTranslation() {\n          var b = this,\n            c = b.max - b.min;\n          var a = b.linkedParent;\n          var d = !!b.categories,\n            n = b.isXAxis;\n          var e = b.axisPointRange || 0,\n            q,\n            g = 0,\n            h = 0,\n            r = b.transA;\n          if (n || d || e) q = b.getClosest(), a ? (g = a.minPointOffset, h = a.pointRangePadding) : b.series.forEach(function (c) {\n            var a = d ? 1 : n ? D(c.options.pointRange, q, 0) : b.axisPointRange || 0,\n              k = c.options.pointPlacement;\n            e = Math.max(e, a);\n            if (!b.single || d) c = c.is(\"xrange\") ? !n : n, g = Math.max(g, c && f(k) ? 0 : a / 2), h = Math.max(h, c && \"on\" === k ? 0 : a);\n          }), a = b.ordinal && b.ordinal.slope && q ? b.ordinal.slope / q : 1, b.minPointOffset = g *= a, b.pointRangePadding = h *= a, b.pointRange = Math.min(e, b.single && d ? 1 : c), n && q && (b.closestPointRange = q);\n          b.translationSlope = b.transA = r = b.staticScale || b.len / (c + h || 1);\n          b.transB = b.horiz ? b.left : b.bottom;\n          b.minPixelPadding = r * g;\n          k(this, \"afterSetAxisTranslation\");\n        }\n      }, {\n        key: \"minFromRange\",\n        value: function minFromRange() {\n          return this.max - this.range;\n        }\n      }, {\n        key: \"setTickInterval\",\n        value: function setTickInterval(c) {\n          var f = this.chart;\n          var a = this.logarithmic,\n            d = this.options,\n            n = this.isXAxis,\n            q = this.isLinked,\n            h = d.tickPixelInterval,\n            A = this.categories,\n            r = this.softThreshold;\n          var m = d.maxPadding,\n            l = d.minPadding;\n          var p = b(d.tickInterval) && 0 <= d.tickInterval ? d.tickInterval : void 0,\n            t = b(this.threshold) ? this.threshold : null,\n            P,\n            w,\n            K;\n          this.dateTime || A || q || this.getTickAmount();\n          w = D(this.userMin, d.min);\n          K = D(this.userMax, d.max);\n          if (q) {\n            this.linkedParent = f[this.coll][d.linkedTo];\n            var R = this.linkedParent.getExtremes();\n            this.min = D(R.min, R.dataMin);\n            this.max = D(R.max, R.dataMax);\n            d.type !== this.linkedParent.options.type && F(11, 1, f);\n          } else r && e(t) && (this.dataMin >= t ? (R = t, l = 0) : this.dataMax <= t && (P = t, m = 0)), this.min = D(w, R, this.dataMin), this.max = D(K, P, this.dataMax);\n          a && (this.positiveValuesOnly && !c && 0 >= Math.min(this.min, D(this.dataMin, this.min)) && F(10, 1, f), this.min = g(a.log2lin(this.min), 16), this.max = g(a.log2lin(this.max), 16));\n          this.range && e(this.max) && (this.userMin = this.min = w = Math.max(this.dataMin, this.minFromRange()), this.userMax = K = this.max, this.range = null);\n          k(this, \"foundExtremes\");\n          this.beforePadding && this.beforePadding();\n          this.adjustForMinRange();\n          !b(this.userMin) && b(d.softMin) && d.softMin < this.min && (this.min = w = d.softMin);\n          !b(this.userMax) && b(d.softMax) && d.softMax > this.max && (this.max = K = d.softMax);\n          !(A || this.axisPointRange || this.stacking && this.stacking.usePercentage || q) && e(this.min) && e(this.max) && (f = this.max - this.min) && (!e(w) && l && (this.min -= f * l), !e(K) && m && (this.max += f * m));\n          !b(this.userMin) && b(d.floor) && (this.min = Math.max(this.min, d.floor));\n          !b(this.userMax) && b(d.ceiling) && (this.max = Math.min(this.max, d.ceiling));\n          r && e(this.dataMin) && (t = t || 0, !e(w) && this.min < t && this.dataMin >= t ? this.min = this.options.minRange ? Math.min(t, this.max - this.minRange) : t : !e(K) && this.max > t && this.dataMax <= t && (this.max = this.options.minRange ? Math.max(t, this.min + this.minRange) : t));\n          b(this.min) && b(this.max) && !this.chart.polar && this.min > this.max && (e(this.options.min) ? this.max = this.min : e(this.options.max) && (this.min = this.max));\n          this.tickInterval = this.min === this.max || \"undefined\" === typeof this.min || \"undefined\" === typeof this.max ? 1 : q && this.linkedParent && !p && h === this.linkedParent.options.tickPixelInterval ? p = this.linkedParent.tickInterval : D(p, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, A ? 1 : (this.max - this.min) * h / Math.max(this.len, h));\n          if (n && !c) {\n            var _b9 = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);\n            this.series.forEach(function (c) {\n              c.forceCrop = c.forceCropping && c.forceCropping();\n              c.processData(_b9);\n            });\n            k(this, \"postProcessData\", {\n              hasExtremesChanged: _b9\n            });\n          }\n          this.setAxisTranslation();\n          k(this, \"initialAxisTranslation\");\n          this.pointRange && !p && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));\n          c = D(d.minTickInterval, this.dateTime && !this.series.some(function (b) {\n            return b.noSharedTooltip;\n          }) ? this.closestPointRange : 0);\n          !p && this.tickInterval < c && (this.tickInterval = c);\n          this.dateTime || this.logarithmic || p || (this.tickInterval = V(this, this.tickInterval));\n          this.tickAmount || (this.tickInterval = this.unsquish());\n          this.setTickPositions();\n        }\n      }, {\n        key: \"setTickPositions\",\n        value: function setTickPositions() {\n          var c = this.options;\n          var f = c.tickPositions,\n            a = c.tickPositioner;\n          var d = this.getMinorTickInterval(),\n            n = this.hasVerticalPanning(),\n            q = \"colorAxis\" === this.coll;\n          var g = (q || !n) && c.startOnTick;\n          n = (q || !n) && c.endOnTick;\n          q = [];\n          var h;\n          this.tickmarkOffset = this.categories && \"between\" === c.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n          this.minorTickInterval = \"auto\" === d && this.tickInterval ? this.tickInterval / c.minorTicksPerMajor : d;\n          this.single = this.min === this.max && e(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== c.allowDecimals);\n          if (f) q = f.slice();else if (b(this.min) && b(this.max)) {\n            if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200))) {\n              if (this.dateTime) q = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, c.units), this.min, this.max, c.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0);else if (this.logarithmic) q = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else for (d = c = this.tickInterval; d <= 2 * c;) if (q = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && q.length > this.tickAmount) this.tickInterval = V(this, d *= 1.1);else break;\n            } else q = [this.min, this.max], F(19, !1, this.chart);\n            q.length > this.len && (q = [q[0], q[q.length - 1]], q[0] === q[1] && (q.length = 1));\n            a && (this.tickPositions = q, (h = a.apply(this, [this.min, this.max])) && (q = h));\n          }\n          this.tickPositions = q;\n          this.paddedTicks = q.slice(0);\n          this.trimTicks(q, g, n);\n          !this.isLinked && b(this.min) && b(this.max) && (this.single && 2 > q.length && !this.categories && !this.series.some(function (b) {\n            return b.is(\"heatmap\") && \"between\" === b.options.pointPlacement;\n          }) && (this.min -= .5, this.max += .5), f || h || this.adjustTickAmount());\n          k(this, \"afterSetTickPositions\");\n        }\n      }, {\n        key: \"trimTicks\",\n        value: function trimTicks(b, c, f) {\n          var a = b[0],\n            d = b[b.length - 1],\n            n = !this.isOrdinal && this.minPointOffset || 0;\n          k(this, \"trimTicks\");\n          if (!this.isLinked) {\n            if (c && -Infinity !== a) this.min = a;else for (; this.min - n > b[0];) b.shift();\n            if (f) this.max = d;else for (; this.max + n < b[b.length - 1];) b.pop();\n            0 === b.length && e(a) && !this.options.tickPositions && b.push((d + a) / 2);\n          }\n        }\n      }, {\n        key: \"alignToOthers\",\n        value: function alignToOthers() {\n          var c = this,\n            f = [this],\n            a = c.options,\n            d = \"yAxis\" === this.coll && this.chart.options.chart.alignThresholds,\n            k = [];\n          var n;\n          c.thresholdAlignment = void 0;\n          if ((!1 !== this.chart.options.chart.alignTicks && a.alignTicks || d) && !1 !== a.startOnTick && !1 !== a.endOnTick && !c.logarithmic) {\n            var _b10 = function _b10(b) {\n                var c = b.horiz,\n                  f = b.options;\n                return [c ? f.left : f.top, f.width, f.height, f.pane].join();\n              },\n              _a4 = _b10(this);\n            this.chart[this.coll].forEach(function (d) {\n              var k = d.series;\n              k.length && k.some(function (b) {\n                return b.visible;\n              }) && d !== c && _b10(d) === _a4 && (n = !0, f.push(d));\n            });\n          }\n          if (n && d) {\n            f.forEach(function (f) {\n              f = f.getThresholdAlignment(c);\n              b(f) && k.push(f);\n            });\n            var _a5 = 1 < k.length ? k.reduce(function (b, c) {\n              return b + c;\n            }, 0) / k.length : void 0;\n            f.forEach(function (b) {\n              b.thresholdAlignment = _a5;\n            });\n          }\n          return n;\n        }\n      }, {\n        key: \"getThresholdAlignment\",\n        value: function getThresholdAlignment(c) {\n          (!b(this.dataMin) || this !== c && this.series.some(function (b) {\n            return b.isDirty || b.isDirtyData;\n          })) && this.getSeriesExtremes();\n          if (b(this.threshold)) return c = h((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (c = 1 - c), c;\n        }\n      }, {\n        key: \"getTickAmount\",\n        value: function getTickAmount() {\n          var b = this.options,\n            c = b.tickPixelInterval;\n          var f = b.tickAmount;\n          !e(b.tickInterval) && !f && this.len < c && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (f = 2);\n          !f && this.alignToOthers() && (f = Math.ceil(this.len / c) + 1);\n          4 > f && (this.finalTickAmt = f, f = 5);\n          this.tickAmount = f;\n        }\n      }, {\n        key: \"adjustTickAmount\",\n        value: function adjustTickAmount() {\n          var c = this,\n            f = c.finalTickAmt,\n            a = c.max,\n            d = c.min,\n            k = c.options,\n            n = c.tickPositions,\n            q = c.tickAmount,\n            h = c.thresholdAlignment,\n            r = n && n.length;\n          var m = D(c.threshold, c.softThreshold ? 0 : null);\n          var l = c.tickInterval;\n          var p;\n          b(h) && (p = .5 > h ? Math.ceil(h * (q - 1)) : Math.floor(h * (q - 1)), k.reversed && (p = q - 1 - p));\n          if (c.hasData() && b(d) && b(a)) {\n            var _h3 = function _h3() {\n              c.transA *= (r - 1) / (q - 1);\n              c.min = k.startOnTick ? n[0] : Math.min(d, n[0]);\n              c.max = k.endOnTick ? n[n.length - 1] : Math.max(a, n[n.length - 1]);\n            };\n            if (b(p) && b(c.threshold)) {\n              for (; n[p] !== m || n.length !== q || n[0] > d || n[n.length - 1] < a;) {\n                n.length = 0;\n                for (n.push(c.threshold); n.length < q;) void 0 === n[p] || n[p] > c.threshold ? n.unshift(g(n[0] - l)) : n.push(g(n[n.length - 1] + l));\n                if (l > 8 * c.tickInterval) break;\n                l *= 2;\n              }\n              _h3();\n            } else if (r < q) {\n              for (; n.length < q;) n.length % 2 || d === m ? n.push(g(n[n.length - 1] + l)) : n.unshift(g(n[0] - l));\n              _h3();\n            }\n            if (e(f)) {\n              for (l = m = n.length; l--;) (3 === f && 1 === l % 2 || 2 >= f && 0 < l && l < m - 1) && n.splice(l, 1);\n              c.finalTickAmt = void 0;\n            }\n          }\n        }\n      }, {\n        key: \"setScale\",\n        value: function setScale() {\n          var b = !1,\n            c = !1;\n          this.series.forEach(function (f) {\n            b = b || f.isDirtyData || f.isDirty;\n            c = c || f.xAxis && f.xAxis.isDirty || !1;\n          });\n          this.setAxisSize();\n          var f = this.len !== (this.old && this.old.len);\n          f || b || c || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && (this.stacking.resetStacks(), this.stacking.buildStacks()), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = f || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();\n          b && this.panningState && (this.panningState.isDirty = !0);\n          k(this, \"afterSetScale\");\n        }\n      }, {\n        key: \"setExtremes\",\n        value: function setExtremes(b, c, f, a, n) {\n          var e = this,\n            q = e.chart;\n          f = D(f, !0);\n          e.series.forEach(function (b) {\n            delete b.kdTree;\n          });\n          n = d(n, {\n            min: b,\n            max: c\n          });\n          k(e, \"setExtremes\", n, function () {\n            e.userMin = b;\n            e.userMax = c;\n            e.eventArgs = n;\n            f && q.redraw(a);\n          });\n        }\n      }, {\n        key: \"zoom\",\n        value: function zoom(b, c) {\n          var f = this,\n            a = this.dataMin,\n            d = this.dataMax,\n            n = this.options,\n            q = Math.min(a, D(n.min, a)),\n            g = Math.max(d, D(n.max, d));\n          b = {\n            newMin: b,\n            newMax: c\n          };\n          k(this, \"zoom\", b, function (b) {\n            var c = b.newMin,\n              n = b.newMax;\n            if (c !== f.min || n !== f.max) f.allowZoomOutside || (e(a) && (c < q && (c = q), c > g && (c = g)), e(d) && (n < q && (n = q), n > g && (n = g))), f.displayBtn = \"undefined\" !== typeof c || \"undefined\" !== typeof n, f.setExtremes(c, n, !1, void 0, {\n              trigger: \"zoom\"\n            });\n            b.zoomed = !0;\n          });\n          return b.zoomed;\n        }\n      }, {\n        key: \"setAxisSize\",\n        value: function setAxisSize() {\n          var b = this.chart;\n          var c = this.options;\n          var f = c.offsets || [0, 0, 0, 0],\n            a = this.horiz,\n            d = this.width = Math.round(K(D(c.width, b.plotWidth - f[3] + f[1]), b.plotWidth)),\n            n = this.height = Math.round(K(D(c.height, b.plotHeight - f[0] + f[2]), b.plotHeight)),\n            k = this.top = Math.round(K(D(c.top, b.plotTop + f[0]), b.plotHeight, b.plotTop));\n          c = this.left = Math.round(K(D(c.left, b.plotLeft + f[3]), b.plotWidth, b.plotLeft));\n          this.bottom = b.chartHeight - n - k;\n          this.right = b.chartWidth - d - c;\n          this.len = Math.max(a ? d : n, 0);\n          this.pos = a ? c : k;\n        }\n      }, {\n        key: \"getExtremes\",\n        value: function getExtremes() {\n          var b = this.logarithmic;\n          return {\n            min: b ? g(b.lin2log(this.min)) : this.min,\n            max: b ? g(b.lin2log(this.max)) : this.max,\n            dataMin: this.dataMin,\n            dataMax: this.dataMax,\n            userMin: this.userMin,\n            userMax: this.userMax\n          };\n        }\n      }, {\n        key: \"getThreshold\",\n        value: function getThreshold(b) {\n          var c = this.logarithmic;\n          var f = c ? c.lin2log(this.min) : this.min;\n          c = c ? c.lin2log(this.max) : this.max;\n          null === b || -Infinity === b ? b = f : Infinity === b ? b = c : f > b ? b = f : c < b && (b = c);\n          return this.translate(b, 0, 1, 0, 1);\n        }\n      }, {\n        key: \"autoLabelAlign\",\n        value: function autoLabelAlign(b) {\n          var c = (D(b, 0) - 90 * this.side + 720) % 360;\n          b = {\n            align: \"center\"\n          };\n          k(this, \"autoLabelAlign\", b, function (b) {\n            15 < c && 165 > c ? b.align = \"right\" : 195 < c && 345 > c && (b.align = \"left\");\n          });\n          return b.align;\n        }\n      }, {\n        key: \"tickSize\",\n        value: function tickSize(b) {\n          var c = this.options,\n            f = D(c[\"tick\" === b ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === b && this.isXAxis && !this.categories ? 1 : 0);\n          var a = c[\"tick\" === b ? \"tickLength\" : \"minorTickLength\"],\n            d;\n          f && a && (\"inside\" === c[b + \"Position\"] && (a = -a), d = [a, f]);\n          b = {\n            tickSize: d\n          };\n          k(this, \"afterTickSize\", b);\n          return b.tickSize;\n        }\n      }, {\n        key: \"labelMetrics\",\n        value: function labelMetrics() {\n          var b = this.chart.renderer;\n          var c = this.ticks;\n          c = c[Object.keys(c)[0]] || {};\n          return this.chart.renderer.fontMetrics(c.label || c.movedLabel || b.box);\n        }\n      }, {\n        key: \"unsquish\",\n        value: function unsquish() {\n          var c = this.options.labels;\n          var f = this.horiz;\n          var a = this.tickInterval,\n            d = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / a),\n            n = c.rotation,\n            k = .75 * this.labelMetrics().h,\n            e = Math.max(this.max - this.min, 0),\n            q = function q(b) {\n              var c = b / (d || 1);\n              c = 1 < c ? Math.ceil(c) : 1;\n              c * a > e && Infinity !== b && Infinity !== d && e && (c = Math.ceil(e / a));\n              return g(c * a);\n            };\n          var h = a,\n            r,\n            l = Number.MAX_VALUE,\n            m;\n          if (f) {\n            if (c.staggerLines || (b(n) ? m = [n] : d < c.autoRotationLimit && (m = c.autoRotation)), m) {\n              var _b11;\n              var _iterator = _createForOfIteratorHelper(m),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var _c6 = _step.value;\n                  if (_c6 === n || _c6 && -90 <= _c6 && 90 >= _c6) f = q(Math.abs(k / Math.sin(p * _c6))), _b11 = f + Math.abs(_c6 / 360), _b11 < l && (l = _b11, r = _c6, h = f);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n            }\n          } else h = q(k);\n          this.autoRotation = m;\n          this.labelRotation = D(r, b(n) ? n : 0);\n          return c.step ? a : h;\n        }\n      }, {\n        key: \"getSlotWidth\",\n        value: function getSlotWidth(c) {\n          var f = this.chart,\n            a = this.horiz,\n            d = this.options.labels,\n            n = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            k = f.margin[3];\n          if (c && b(c.slotWidth)) return c.slotWidth;\n          if (a && 2 > d.step) return d.rotation ? 0 : (this.staggerLines || 1) * this.len / n;\n          if (!a) {\n            c = d.style.width;\n            if (void 0 !== c) return parseInt(String(c), 10);\n            if (k) return k - f.spacing[3];\n          }\n          return .33 * f.chartWidth;\n        }\n      }, {\n        key: \"renderUnsquish\",\n        value: function renderUnsquish() {\n          var b = this.chart,\n            c = b.renderer,\n            a = this.tickPositions,\n            d = this.ticks,\n            n = this.options.labels,\n            k = n.style,\n            e = this.horiz,\n            q = this.getSlotWidth();\n          var g = Math.max(1, Math.round(q - 2 * n.padding));\n          var h = {},\n            r = this.labelMetrics(),\n            m = k.textOverflow;\n          var l,\n            p,\n            D = 0;\n          f(n.rotation) || (h.rotation = n.rotation || 0);\n          a.forEach(function (b) {\n            b = d[b];\n            b.movedLabel && b.replaceMovedLabel();\n            b && b.label && b.label.textPxLength > D && (D = b.label.textPxLength);\n          });\n          this.maxLabelLength = D;\n          if (this.autoRotation) D > g && D > r.h ? h.rotation = this.labelRotation : this.labelRotation = 0;else if (q && (l = g, !m)) for (p = \"clip\", g = a.length; !e && g--;) {\n            var t = a[g];\n            if (t = d[t].label) t.styles && \"ellipsis\" === t.styles.textOverflow ? t.css({\n              textOverflow: \"clip\"\n            }) : t.textPxLength > q && t.css({\n              width: q + \"px\"\n            }), t.getBBox().height > this.len / a.length - (r.h - r.f) && (t.specificTextOverflow = \"ellipsis\");\n          }\n          h.rotation && (l = D > .5 * b.chartHeight ? .33 * b.chartHeight : D, m || (p = \"ellipsis\"));\n          if (this.labelAlign = n.align || this.autoLabelAlign(this.labelRotation)) h.align = this.labelAlign;\n          a.forEach(function (b) {\n            var c = (b = d[b]) && b.label,\n              f = k.width,\n              a = {};\n            c && (c.attr(h), b.shortenLabel ? b.shortenLabel() : l && !f && \"nowrap\" !== k.whiteSpace && (l < c.textPxLength || \"SPAN\" === c.element.tagName) ? (a.width = l + \"px\", m || (a.textOverflow = c.specificTextOverflow || p), c.css(a)) : c.styles && c.styles.width && !a.width && !f && c.css({\n              width: null\n            }), delete c.specificTextOverflow, b.rotation = h.rotation);\n          }, this);\n          this.tickRotCorr = c.rotCorr(r.b, this.labelRotation || 0, 0 !== this.side);\n        }\n      }, {\n        key: \"hasData\",\n        value: function hasData() {\n          return this.series.some(function (b) {\n            return b.hasData();\n          }) || this.options.showEmpty && e(this.min) && e(this.max);\n        }\n      }, {\n        key: \"addTitle\",\n        value: function addTitle(b) {\n          var f = this.chart.renderer,\n            a = this.horiz,\n            d = this.opposite,\n            n = this.options.title,\n            k = this.chart.styledMode;\n          var e;\n          this.axisTitle || ((e = n.textAlign) || (e = (a ? {\n            low: \"left\",\n            middle: \"center\",\n            high: \"right\"\n          } : {\n            low: d ? \"right\" : \"left\",\n            middle: \"center\",\n            high: d ? \"left\" : \"right\"\n          })[n.align]), this.axisTitle = f.text(n.text || \"\", 0, 0, n.useHTML).attr({\n            zIndex: 7,\n            rotation: n.rotation,\n            align: e\n          }).addClass(\"highcharts-axis-title\"), k || this.axisTitle.css(c(n.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n          k || n.style.width || this.isRadial || this.axisTitle.css({\n            width: this.len + \"px\"\n          });\n          this.axisTitle[b ? \"show\" : \"hide\"](b);\n        }\n      }, {\n        key: \"generateTick\",\n        value: function generateTick(b) {\n          var c = this.ticks;\n          c[b] ? c[b].addLabel() : c[b] = new H(this, b);\n        }\n      }, {\n        key: \"getOffset\",\n        value: function getOffset() {\n          var _this6 = this;\n          var c = this,\n            f = c.chart,\n            a = c.horiz,\n            d = c.options,\n            n = c.side,\n            q = c.ticks,\n            g = c.tickPositions,\n            h = c.coll,\n            r = c.axisParent,\n            m = f.renderer,\n            l = f.inverted && !c.isZAxis ? [1, 0, 3, 2][n] : n;\n          var p = c.hasData();\n          var t = d.title;\n          var w = d.labels;\n          var K = b(d.crossing);\n          var G = f.axisOffset;\n          var R = f.clipOffset,\n            Q = [-1, 1, 1, -1][n],\n            v = d.className;\n          var ja,\n            u = 0,\n            x;\n          var E = 0;\n          var F = 0;\n          c.showAxis = ja = p || d.showEmpty;\n          c.staggerLines = c.horiz && w.staggerLines || void 0;\n          if (!c.axisGroup) {\n            var _b12 = function _b12(b, c, f) {\n              return m.g(b).attr({\n                zIndex: f\n              }).addClass(\"highcharts-\".concat(h.toLowerCase()).concat(c, \" \") + (_this6.isRadial ? \"highcharts-radial-axis\".concat(c, \" \") : \"\") + (v || \"\")).add(r);\n            };\n            c.gridGroup = _b12(\"grid\", \"-grid\", d.gridZIndex);\n            c.axisGroup = _b12(\"axis\", \"\", d.zIndex);\n            c.labelGroup = _b12(\"axis-labels\", \"-labels\", w.zIndex);\n          }\n          p || c.isLinked ? (g.forEach(function (b) {\n            c.generateTick(b);\n          }), c.renderUnsquish(), c.reserveSpaceDefault = 0 === n || 2 === n || {\n            1: \"left\",\n            3: \"right\"\n          }[n] === c.labelAlign, D(w.reserveSpace, K ? !1 : null, \"center\" === c.labelAlign ? !0 : null, c.reserveSpaceDefault) && g.forEach(function (b) {\n            F = Math.max(q[b].getLabelSize(), F);\n          }), c.staggerLines && (F *= c.staggerLines), c.labelOffset = F * (c.opposite ? -1 : 1)) : P(q, function (b, c) {\n            b.destroy();\n            delete q[c];\n          });\n          t && t.text && !1 !== t.enabled && (c.addTitle(ja), ja && !K && !1 !== t.reserveSpace && (c.titleOffset = u = c.axisTitle.getBBox()[a ? \"height\" : \"width\"], x = t.offset, E = e(x) ? 0 : D(t.margin, a ? 5 : 10)));\n          c.renderLine();\n          c.offset = Q * D(d.offset, G[n] ? G[n] + (d.margin || 0) : 0);\n          c.tickRotCorr = c.tickRotCorr || {\n            x: 0,\n            y: 0\n          };\n          p = 0 === n ? -c.labelMetrics().h : 2 === n ? c.tickRotCorr.y : 0;\n          E = Math.abs(F) + E;\n          F && (E = E - p + Q * (a ? D(w.y, c.tickRotCorr.y + Q * w.distance) : D(w.x, Q * w.distance)));\n          c.axisTitleMargin = D(x, E);\n          c.getMaxLabelDimensions && (c.maxLabelDimensions = c.getMaxLabelDimensions(q, g));\n          \"colorAxis\" !== h && (w = this.tickSize(\"tick\"), G[n] = Math.max(G[n], (c.axisTitleMargin || 0) + u + Q * c.offset, E, g && g.length && w ? w[0] + Q * c.offset : 0), G = !c.axisLine || d.offset ? 0 : 2 * Math.floor(c.axisLine.strokeWidth() / 2), R[l] = Math.max(R[l], G));\n          k(this, \"afterGetOffset\");\n        }\n      }, {\n        key: \"getLinePath\",\n        value: function getLinePath(b) {\n          var c = this.chart,\n            f = this.opposite;\n          var a = this.offset;\n          var d = this.horiz,\n            n = this.left + (f ? this.width : 0) + a;\n          a = c.chartHeight - this.bottom - (f ? this.height : 0) + a;\n          f && (b *= -1);\n          return c.renderer.crispLine([[\"M\", d ? this.left : n, d ? a : this.top], [\"L\", d ? c.chartWidth - this.right : n, d ? a : c.chartHeight - this.bottom]], b);\n        }\n      }, {\n        key: \"renderLine\",\n        value: function renderLine() {\n          this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n            stroke: this.options.lineColor,\n            \"stroke-width\": this.options.lineWidth,\n            zIndex: 7\n          }));\n        }\n      }, {\n        key: \"getTitlePosition\",\n        value: function getTitlePosition(b) {\n          var c = this.horiz,\n            f = this.left;\n          var a = this.top;\n          var d = this.len;\n          var n = this.options.title,\n            e = c ? f : a,\n            q = this.opposite,\n            g = this.offset,\n            h = n.x,\n            r = n.y,\n            l = this.chart.renderer.fontMetrics(b);\n          b = b ? Math.max(b.getBBox(!1, 0).height - l.h - 1, 0) : 0;\n          d = {\n            low: e + (c ? 0 : d),\n            middle: e + d / 2,\n            high: e + (c ? d : 0)\n          }[n.align];\n          f = (c ? a + this.height : f) + (c ? 1 : -1) * (q ? -1 : 1) * (this.axisTitleMargin || 0) + [-b, b, l.f, -b][this.side];\n          c = {\n            x: c ? d + h : f + (q ? this.width : 0) + g + h,\n            y: c ? f + r - (q ? this.height : 0) + g : d + r\n          };\n          k(this, \"afterGetTitlePosition\", {\n            titlePosition: c\n          });\n          return c;\n        }\n      }, {\n        key: \"renderMinorTick\",\n        value: function renderMinorTick(b, c) {\n          var f = this.minorTicks;\n          f[b] || (f[b] = new H(this, b, \"minor\"));\n          c && f[b].isNew && f[b].render(null, !0);\n          f[b].render(null, !1, 1);\n        }\n      }, {\n        key: \"renderTick\",\n        value: function renderTick(b, c, f) {\n          var a = this.ticks;\n          if (!this.isLinked || b >= this.min && b <= this.max || this.grid && this.grid.isColumn) a[b] || (a[b] = new H(this, b)), f && a[b].isNew && a[b].render(c, !0, -1), a[b].render(c);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var c = this,\n            f = c.chart,\n            a = c.logarithmic,\n            d = c.options,\n            n = c.isLinked,\n            e = c.tickPositions,\n            q = c.axisTitle,\n            g = c.ticks,\n            h = c.minorTicks,\n            r = c.alternateBands,\n            l = d.stackLabels,\n            m = d.alternateGridColor;\n          var p = d.crossing;\n          var D = c.tickmarkOffset,\n            t = c.axisLine,\n            w = c.showAxis,\n            K = u(f.renderer.globalAnimation);\n          var Q, G;\n          c.labelEdge.length = 0;\n          c.overlap = !1;\n          [g, h, r].forEach(function (b) {\n            P(b, function (b) {\n              b.isActive = !1;\n            });\n          });\n          if (b(p)) {\n            var _b13 = this.isXAxis ? f.yAxis[0] : f.xAxis[0],\n              _a6 = [1, -1, -1, 1][this.side];\n            _b13 && (p = _b13.toPixels(p, !0), c.horiz && (p = _b13.len - p), c.offset = _a6 * p);\n          }\n          if (c.hasData() || n) {\n            var _n2 = c.chart.hasRendered && c.old && b(c.old.min);\n            c.minorTickInterval && !c.categories && c.getMinorTickPositions().forEach(function (b) {\n              c.renderMinorTick(b, _n2);\n            });\n            e.length && (e.forEach(function (b, f) {\n              c.renderTick(b, f, _n2);\n            }), D && (0 === c.min || c.single) && (g[-1] || (g[-1] = new H(c, -1, null, !0)), g[-1].render(-1)));\n            m && e.forEach(function (b, d) {\n              G = \"undefined\" !== typeof e[d + 1] ? e[d + 1] + D : c.max - D;\n              0 === d % 2 && b < c.max && G <= c.max + (f.polar ? -D : D) && (r[b] || (r[b] = new z.PlotLineOrBand(c)), Q = b + D, r[b].options = {\n                from: a ? a.lin2log(Q) : Q,\n                to: a ? a.lin2log(G) : G,\n                color: m,\n                className: \"highcharts-alternate-grid\"\n              }, r[b].render(), r[b].isActive = !0);\n            });\n            c._addedPlotLB || (c._addedPlotLB = !0, (d.plotLines || []).concat(d.plotBands || []).forEach(function (b) {\n              c.addPlotBandOrLine(b);\n            }));\n          }\n          [g, h, r].forEach(function (b) {\n            var c = [],\n              a = K.duration;\n            P(b, function (b, f) {\n              b.isActive || (b.render(f, !1, 0), b.isActive = !1, c.push(f));\n            });\n            Z(function () {\n              var f = c.length;\n              for (; f--;) b[c[f]] && !b[c[f]].isActive && (b[c[f]].destroy(), delete b[c[f]]);\n            }, b !== r && f.hasRendered && a ? a : 0);\n          });\n          t && (t[t.isPlaced ? \"animate\" : \"attr\"]({\n            d: this.getLinePath(t.strokeWidth())\n          }), t.isPlaced = !0, t[w ? \"show\" : \"hide\"](w));\n          q && w && (q[q.isNew ? \"attr\" : \"animate\"](c.getTitlePosition(q)), q.isNew = !1);\n          l && l.enabled && c.stacking && c.stacking.renderStackTotals();\n          c.old = {\n            len: c.len,\n            max: c.max,\n            min: c.min,\n            transA: c.transA,\n            userMax: c.userMax,\n            userMin: c.userMin\n          };\n          c.isDirty = !1;\n          k(this, \"afterRender\");\n        }\n      }, {\n        key: \"redraw\",\n        value: function redraw() {\n          this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {\n            b.render();\n          }));\n          this.series.forEach(function (b) {\n            b.isDirty = !0;\n          });\n        }\n      }, {\n        key: \"getKeepProps\",\n        value: function getKeepProps() {\n          return this.keepProps || Y.keepProps;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy(b) {\n          var c = this,\n            f = c.plotLinesAndBands,\n            a = this.eventOptions;\n          k(this, \"destroy\", {\n            keepEvents: b\n          });\n          b || X(c);\n          [c.ticks, c.minorTicks, c.alternateBands].forEach(function (b) {\n            w(b);\n          });\n          if (f) for (b = f.length; b--;) f[b].destroy();\n          \"axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (b) {\n            c[b] && (c[b] = c[b].destroy());\n          });\n          for (var _b14 in c.plotLinesAndBandsGroups) c.plotLinesAndBandsGroups[_b14] = c.plotLinesAndBandsGroups[_b14].destroy();\n          P(c, function (b, f) {\n            -1 === c.getKeepProps().indexOf(f) && delete c[f];\n          });\n          this.eventOptions = a;\n        }\n      }, {\n        key: \"drawCrosshair\",\n        value: function drawCrosshair(b, c) {\n          var f = this.crosshair;\n          var a = D(f && f.snap, !0);\n          var n = this.chart;\n          var q,\n            g = this.cross;\n          k(this, \"drawCrosshair\", {\n            e: b,\n            point: c\n          });\n          b || (b = this.cross && this.cross.e);\n          if (f && !1 !== (e(c) || !a)) {\n            a ? e(c) && (q = D(\"colorAxis\" !== this.coll ? c.crosshairPos : null, this.isXAxis ? c.plotX : this.len - c.plotY)) : q = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);\n            if (e(q)) {\n              var h = {\n                value: c && (this.isXAxis ? c.x : D(c.stackY, c.y)),\n                translatedValue: q\n              };\n              n.polar && d(h, {\n                isCrosshair: !0,\n                chartX: b && b.chartX,\n                chartY: b && b.chartY,\n                point: c\n              });\n              h = this.getPlotLinePath(h) || null;\n            }\n            if (!e(h)) {\n              this.hideCrosshair();\n              return;\n            }\n            a = this.categories && !this.isRadial;\n            g || (this.cross = g = n.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (a ? \"category \" : \"thin \") + (f.className || \"\")).attr({\n              zIndex: D(f.zIndex, 2)\n            }).add(), n.styledMode || (g.attr({\n              stroke: f.color || (a ? I.parse(\"#ccd3ff\").setOpacity(.25).get() : \"#cccccc\"),\n              \"stroke-width\": D(f.width, 1)\n            }).css({\n              \"pointer-events\": \"none\"\n            }), f.dashStyle && g.attr({\n              dashstyle: f.dashStyle\n            })));\n            g.show().attr({\n              d: h\n            });\n            a && !f.width && g.attr({\n              \"stroke-width\": this.transA\n            });\n            this.cross.e = b;\n          } else this.hideCrosshair();\n          k(this, \"afterDrawCrosshair\", {\n            e: b,\n            point: c\n          });\n        }\n      }, {\n        key: \"hideCrosshair\",\n        value: function hideCrosshair() {\n          this.cross && this.cross.hide();\n          k(this, \"afterHideCrosshair\");\n        }\n      }, {\n        key: \"hasVerticalPanning\",\n        value: function hasVerticalPanning() {\n          var b = this.chart.options.chart.panning;\n          return !!(b && b.enabled && /y/.test(b.type));\n        }\n      }, {\n        key: \"update\",\n        value: function update(b, f) {\n          var a = this.chart;\n          b = c(this.userOptions, b);\n          this.destroy(!0);\n          this.init(a, b);\n          a.isDirtyBox = !0;\n          D(f, !0) && a.redraw();\n        }\n      }, {\n        key: \"remove\",\n        value: function remove(b) {\n          var c = this.chart,\n            f = this.coll,\n            a = this.series;\n          var d = a.length;\n          for (; d--;) a[d] && a[d].remove(!1);\n          x(c.axes, this);\n          x(c[f] || [], this);\n          c.orderItems(f);\n          this.destroy();\n          c.isDirtyBox = !0;\n          D(b, !0) && c.redraw();\n        }\n      }, {\n        key: \"setTitle\",\n        value: function setTitle(b, c) {\n          this.update({\n            title: b\n          }, c);\n        }\n      }, {\n        key: \"setCategories\",\n        value: function setCategories(b, c) {\n          this.update({\n            categories: b\n          }, c);\n        }\n      }]);\n      return Y;\n    }();\n    Y.defaultOptions = y.defaultXAxisOptions;\n    Y.keepProps = \"coll extKey hcEvents names series userMax userMin\".split(\" \");\n    \"\";\n    return Y;\n  });\n  M(a, \"Core/Axis/DateTimeAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    var x = a.addEvent,\n      I = a.getMagnitude,\n      L = a.normalizeTickInterval,\n      C = a.timeUnits;\n    var z;\n    (function (y) {\n      function B() {\n        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n      }\n      function u(a) {\n        \"datetime\" !== a.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new l(this));\n      }\n      var v = [];\n      y.compose = function (l) {\n        a.pushUnique(v, l) && (l.keepProps.push(\"dateTime\"), l.prototype.getTimeTicks = B, x(l, \"init\", u));\n        return l;\n      };\n      var l = /*#__PURE__*/function () {\n        function l(a) {\n          _classCallCheck(this, l);\n          this.axis = a;\n        }\n        _createClass(l, [{\n          key: \"normalizeTimeTickInterval\",\n          value: function normalizeTimeTickInterval(a, l) {\n            var m = l || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n            l = m[m.length - 1];\n            var h = C[l[0]],\n              g = l[1],\n              e;\n            for (e = 0; e < m.length && !(l = m[e], h = C[l[0]], g = l[1], m[e + 1] && a <= (h * g[g.length - 1] + C[m[e + 1][0]]) / 2); e++);\n            h === C.year && a < 5 * h && (g = [1, 2, 5]);\n            a = L(a / h, g, \"year\" === l[0] ? Math.max(I(a / h), 1) : 1);\n            return {\n              unitRange: h,\n              count: a,\n              unitName: l[0]\n            };\n          }\n        }, {\n          key: \"getXDateFormat\",\n          value: function getXDateFormat(a, l) {\n            var m = this.axis,\n              h = m.chart.time;\n            return m.closestPointRange ? h.getDateFormat(m.closestPointRange, a, m.options.startOfWeek, l) || h.resolveDTLFormat(l.year).main : h.resolveDTLFormat(l.day).main;\n          }\n        }]);\n        return l;\n      }();\n      y.Additions = l;\n    })(z || (z = {}));\n    return z;\n  });\n  M(a, \"Core/Axis/LogarithmicAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    var x = a.addEvent,\n      I = a.normalizeTickInterval,\n      L = a.pick;\n    var C;\n    (function (y) {\n      function H(a) {\n        var l = this.logarithmic;\n        \"logarithmic\" !== a.userOptions.type ? this.logarithmic = void 0 : l || (this.logarithmic = new v(this));\n      }\n      function B() {\n        var a = this.logarithmic;\n        a && (this.lin2val = function (l) {\n          return a.lin2log(l);\n        }, this.val2lin = function (l) {\n          return a.log2lin(l);\n        });\n      }\n      var u = [];\n      y.compose = function (l) {\n        a.pushUnique(u, l) && (l.keepProps.push(\"logarithmic\"), x(l, \"init\", H), x(l, \"afterInit\", B));\n        return l;\n      };\n      var v = /*#__PURE__*/function () {\n        function v(a) {\n          _classCallCheck(this, v);\n          this.axis = a;\n        }\n        _createClass(v, [{\n          key: \"getLogTickPositions\",\n          value: function getLogTickPositions(a, p, t, m) {\n            var h = this.axis;\n            var g = h.len,\n              e = h.options;\n            var l = [];\n            m || (this.minorAutoInterval = void 0);\n            if (.5 <= a) a = Math.round(a), l = h.getLinearTickPositions(a, p, t);else if (.08 <= a) {\n              e = Math.floor(p);\n              var _h4, w, d, k, r;\n              for (g = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; e < t + 1 && !r; e++) for (w = g.length, _h4 = 0; _h4 < w && !r; _h4++) d = this.log2lin(this.lin2log(e) * g[_h4]), d > p && (!m || k <= t) && \"undefined\" !== typeof k && l.push(k), k > t && (r = !0), k = d;\n            } else p = this.lin2log(p), t = this.lin2log(t), a = m ? h.getMinorTickInterval() : e.tickInterval, a = L(\"auto\" === a ? null : a, this.minorAutoInterval, e.tickPixelInterval / (m ? 5 : 1) * (t - p) / ((m ? g / h.tickPositions.length : g) || 1)), a = I(a), l = h.getLinearTickPositions(a, p, t).map(this.log2lin), m || (this.minorAutoInterval = a / 5);\n            m || (h.tickInterval = a);\n            return l;\n          }\n        }, {\n          key: \"lin2log\",\n          value: function lin2log(a) {\n            return Math.pow(10, a);\n          }\n        }, {\n          key: \"log2lin\",\n          value: function log2lin(a) {\n            return Math.log(a) / Math.LN10;\n          }\n        }]);\n        return v;\n      }();\n      y.Additions = v;\n    })(C || (C = {}));\n    return C;\n  });\n  M(a, \"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    var x = a.erase,\n      I = a.extend,\n      L = a.isNumber;\n    var C;\n    (function (y) {\n      function H(a) {\n        return this.addPlotBandOrLine(a, \"plotBands\");\n      }\n      function B(a, e) {\n        var _this7 = this;\n        var g = this.userOptions;\n        var l = new h(this, a);\n        this.visible && (l = l.render());\n        if (l) {\n          this._addedPlotLB || (this._addedPlotLB = !0, (g.plotLines || []).concat(g.plotBands || []).forEach(function (a) {\n            _this7.addPlotBandOrLine(a);\n          }));\n          if (e) {\n            var _h5 = g[e] || [];\n            _h5.push(a);\n            g[e] = _h5;\n          }\n          this.plotLinesAndBands.push(l);\n        }\n        return l;\n      }\n      function u(a) {\n        return this.addPlotBandOrLine(a, \"plotLines\");\n      }\n      function v(a, e) {\n        var h = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.options;\n        var g = this.getPlotLinePath({\n            value: e,\n            force: !0,\n            acrossPanes: h.acrossPanes\n          }),\n          l = [],\n          d = this.horiz;\n        e = !L(this.min) || !L(this.max) || a < this.min && e < this.min || a > this.max && e > this.max;\n        a = this.getPlotLinePath({\n          value: a,\n          force: !0,\n          acrossPanes: h.acrossPanes\n        });\n        h = 1;\n        var k;\n        if (a && g) for (e && (k = a.toString() === g.toString(), h = 0), e = 0; e < a.length; e += 2) {\n          var r = a[e],\n            q = a[e + 1],\n            _m2 = g[e],\n            b = g[e + 1];\n          \"M\" !== r[0] && \"L\" !== r[0] || \"M\" !== q[0] && \"L\" !== q[0] || \"M\" !== _m2[0] && \"L\" !== _m2[0] || \"M\" !== b[0] && \"L\" !== b[0] || (d && _m2[1] === r[1] ? (_m2[1] += h, b[1] += h) : d || _m2[2] !== r[2] || (_m2[2] += h, b[2] += h), l.push([\"M\", r[1], r[2]], [\"L\", q[1], q[2]], [\"L\", b[1], b[2]], [\"L\", _m2[1], _m2[2]], [\"Z\"]));\n          l.isFlat = k;\n        }\n        return l;\n      }\n      function l(a) {\n        this.removePlotBandOrLine(a);\n      }\n      function p(a) {\n        var e = this.plotLinesAndBands,\n          g = this.options,\n          h = this.userOptions;\n        if (e) {\n          var _l = e.length;\n          for (; _l--;) e[_l].id === a && e[_l].destroy();\n          [g.plotLines || [], h.plotLines || [], g.plotBands || [], h.plotBands || []].forEach(function (d) {\n            for (_l = d.length; _l--;) (d[_l] || {}).id === a && x(d, d[_l]);\n          });\n        }\n      }\n      function t(a) {\n        this.removePlotBandOrLine(a);\n      }\n      var m = [];\n      var h;\n      y.compose = function (g, e) {\n        h || (h = g);\n        a.pushUnique(m, e) && I(e.prototype, {\n          addPlotBand: H,\n          addPlotLine: u,\n          addPlotBandOrLine: B,\n          getPlotBandPath: v,\n          removePlotBand: l,\n          removePlotLine: t,\n          removePlotBandOrLine: p\n        });\n        return e;\n      };\n    })(C || (C = {}));\n    return C;\n  });\n  M(a, \"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\", [a[\"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    var x = y.arrayMax,\n      L = y.arrayMin,\n      C = y.defined,\n      z = y.destroyObjectProperties,\n      H = y.erase,\n      B = y.fireEvent,\n      u = y.merge,\n      v = y.objectEach,\n      l = y.pick;\n    var p = /*#__PURE__*/function () {\n      _createClass(p, null, [{\n        key: \"compose\",\n        value: function compose(l) {\n          return a.compose(p, l);\n        }\n      }]);\n      function p(a, l) {\n        _classCallCheck(this, p);\n        this.axis = a;\n        l && (this.options = l, this.id = l.id);\n      }\n      _createClass(p, [{\n        key: \"render\",\n        value: function render() {\n          B(this, \"render\");\n          var a = this,\n            m = a.axis,\n            h = m.horiz;\n          var g = m.logarithmic;\n          var e = a.options,\n            p = e.color,\n            x = l(e.zIndex, 0),\n            F = e.events,\n            d = {},\n            k = m.chart.renderer;\n          var r = e.label,\n            q = a.label,\n            G = e.to,\n            b = e.from,\n            f = e.value,\n            c = a.svgElem;\n          var n = [];\n          var P = C(b) && C(G);\n          n = C(f);\n          var D = !c,\n            K = {\n              \"class\": \"highcharts-plot-\" + (P ? \"band \" : \"line \") + (e.className || \"\")\n            };\n          var X = P ? \"bands\" : \"lines\";\n          g && (b = g.log2lin(b), G = g.log2lin(G), f = g.log2lin(f));\n          m.chart.styledMode || (n ? (K.stroke = p || \"#999999\", K[\"stroke-width\"] = l(e.width, 1), e.dashStyle && (K.dashstyle = e.dashStyle)) : P && (K.fill = p || \"#e6e9ff\", e.borderWidth && (K.stroke = e.borderColor, K[\"stroke-width\"] = e.borderWidth)));\n          d.zIndex = x;\n          X += \"-\" + x;\n          (g = m.plotLinesAndBandsGroups[X]) || (m.plotLinesAndBandsGroups[X] = g = k.g(\"plot-\" + X).attr(d).add());\n          D && (a.svgElem = c = k.path().attr(K).add(g));\n          if (n) n = m.getPlotLinePath({\n            value: f,\n            lineWidth: c.strokeWidth(),\n            acrossPanes: e.acrossPanes\n          });else if (P) n = m.getPlotBandPath(b, G, e);else return;\n          !a.eventsAdded && F && (v(F, function (b, f) {\n            c.on(f, function (b) {\n              F[f].apply(a, [b]);\n            });\n          }), a.eventsAdded = !0);\n          (D || !c.d) && n && n.length ? c.attr({\n            d: n\n          }) : c && (n ? (c.show(), c.animate({\n            d: n\n          })) : c.d && (c.hide(), q && (a.label = q = q.destroy())));\n          r && (C(r.text) || C(r.formatter)) && n && n.length && 0 < m.width && 0 < m.height && !n.isFlat ? (r = u({\n            align: h && P && \"center\",\n            x: h ? !P && 4 : 10,\n            verticalAlign: !h && P && \"middle\",\n            y: h ? P ? 16 : 10 : P ? 6 : -4,\n            rotation: h && !P && 90\n          }, r), this.renderLabel(r, n, P, x)) : q && q.hide();\n          return a;\n        }\n      }, {\n        key: \"renderLabel\",\n        value: function renderLabel(a, l, h, g) {\n          var e = this.axis;\n          var m = e.chart.renderer;\n          var p = this.label;\n          p || (this.label = p = m.text(this.getLabelText(a), 0, 0, a.useHTML).attr({\n            align: a.textAlign || a.align,\n            rotation: a.rotation,\n            \"class\": \"highcharts-plot-\" + (h ? \"band\" : \"line\") + \"-label \" + (a.className || \"\"),\n            zIndex: g\n          }).add(), e.chart.styledMode || p.css(u({\n            fontSize: \"0.8em\",\n            textOverflow: \"ellipsis\"\n          }, a.style)));\n          g = l.xBounds || [l[0][1], l[1][1], h ? l[2][1] : l[0][1]];\n          l = l.yBounds || [l[0][2], l[1][2], h ? l[2][2] : l[0][2]];\n          h = L(g);\n          m = L(l);\n          p.align(a, !1, {\n            x: h,\n            y: m,\n            width: x(g) - h,\n            height: x(l) - m\n          });\n          p.alignValue && \"left\" !== p.alignValue || (a = a.clip ? e.width : e.chart.chartWidth, p.css({\n            width: (90 === p.rotation ? e.height - (p.alignAttr.y - e.top) : a - (p.alignAttr.x - e.left)) + \"px\"\n          }));\n          p.show(!0);\n        }\n      }, {\n        key: \"getLabelText\",\n        value: function getLabelText(a) {\n          return C(a.formatter) ? a.formatter.call(this) : a.text;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          H(this.axis.plotLinesAndBands, this);\n          delete this.axis;\n          z(this);\n        }\n      }]);\n      return p;\n    }();\n    \"\";\n    \"\";\n    return p;\n  });\n  M(a, \"Core/Tooltip.js\", [a[\"Core/Templating.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C) {\n    var x = a.format,\n      H = y.doc,\n      B = y.isSafari,\n      u = I.distribute,\n      v = C.addEvent,\n      l = C.clamp,\n      p = C.css,\n      t = C.discardElement,\n      m = C.extend,\n      h = C.fireEvent,\n      g = C.isArray,\n      e = C.isNumber,\n      w = C.isString,\n      E = C.merge,\n      F = C.pick,\n      d = C.splat,\n      k = C.syncTimeout;\n    var r = /*#__PURE__*/function () {\n      function r(a, d) {\n        _classCallCheck(this, r);\n        this.allowShared = !0;\n        this.container = void 0;\n        this.crosshairs = [];\n        this.distance = 0;\n        this.isHidden = !0;\n        this.isSticky = !1;\n        this.now = {};\n        this.options = {};\n        this.outside = !1;\n        this.chart = a;\n        this.init(a, d);\n      }\n      _createClass(r, [{\n        key: \"bodyFormatter\",\n        value: function bodyFormatter(a) {\n          return a.map(function (a) {\n            var b = a.series.tooltipOptions;\n            return (b[(a.point.formatPrefix || \"point\") + \"Formatter\"] || a.point.tooltipFormatter).call(a.point, b[(a.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n          });\n        }\n      }, {\n        key: \"cleanSplit\",\n        value: function cleanSplit(a) {\n          this.chart.series.forEach(function (d) {\n            var b = d && d.tt;\n            b && (!b.isActive || a ? d.tt = b.destroy() : b.isActive = !1);\n          });\n        }\n      }, {\n        key: \"defaultFormatter\",\n        value: function defaultFormatter(a) {\n          var k = this.points || d(this);\n          var b;\n          b = [a.tooltipFooterHeaderFormatter(k[0])];\n          b = b.concat(a.bodyFormatter(k));\n          b.push(a.tooltipFooterHeaderFormatter(k[0], !0));\n          return b;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          this.label && (this.label = this.label.destroy());\n          this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy()));\n          this.renderer && (this.renderer = this.renderer.destroy(), t(this.container));\n          C.clearTimeout(this.hideTimer);\n          C.clearTimeout(this.tooltipTimeout);\n        }\n      }, {\n        key: \"getAnchor\",\n        value: function getAnchor(a, k) {\n          var b = this.chart;\n          var f = b.pointer,\n            c = b.inverted,\n            n = b.plotTop;\n          b = b.plotLeft;\n          a = d(a);\n          a[0].series && a[0].series.yAxis && !a[0].series.yAxis.options.reversedStacks && (a = a.slice().reverse());\n          if (this.followPointer && k) \"undefined\" === typeof k.chartX && (k = f.normalize(k)), a = [k.chartX - b, k.chartY - n];else if (a[0].tooltipPos) a = a[0].tooltipPos;else {\n            var _f4 = 0,\n              _d5 = 0;\n            a.forEach(function (b) {\n              if (b = b.pos(!0)) _f4 += b[0], _d5 += b[1];\n            });\n            _f4 /= a.length;\n            _d5 /= a.length;\n            this.shared && 1 < a.length && k && (c ? _f4 = k.chartX : _d5 = k.chartY);\n            a = [_f4 - b, _d5 - n];\n          }\n          return a.map(Math.round);\n        }\n      }, {\n        key: \"getClassName\",\n        value: function getClassName(a, d, b) {\n          var f = a.series,\n            c = f.options;\n          return [this.options.className, \"highcharts-label\", b && \"highcharts-tooltip-header\", d ? \"highcharts-tooltip-box\" : \"highcharts-tooltip\", !b && \"highcharts-color-\" + F(a.colorIndex, f.colorIndex), c && c.className].filter(w).join(\" \");\n        }\n      }, {\n        key: \"getLabel\",\n        value: function getLabel() {\n          var a = this,\n            d = this.chart.styledMode,\n            b = this.options,\n            f = this.split && this.allowShared,\n            c = b.style.pointerEvents || (this.shouldStickOnContact() ? \"auto\" : \"none\");\n          var n,\n            k = this.chart.renderer;\n          if (this.label) {\n            var e = !this.label.hasClass(\"highcharts-label\");\n            (!f && e || f && !e) && this.destroy();\n          }\n          if (!this.label) {\n            if (this.outside) {\n              e = this.chart.options.chart.style;\n              var _b15 = L.getRendererType();\n              this.container = n = y.doc.createElement(\"div\");\n              n.className = \"highcharts-tooltip-container\";\n              p(n, {\n                position: \"absolute\",\n                top: \"1px\",\n                pointerEvents: c,\n                zIndex: Math.max(this.options.style.zIndex || 0, (e && e.zIndex || 0) + 3)\n              });\n              y.doc.body.appendChild(n);\n              this.renderer = k = new _b15(n, 0, 0, e, void 0, void 0, k.styledMode);\n            }\n            f ? this.label = k.g(\"tooltip\") : (this.label = k.label(\"\", 0, 0, b.shape, void 0, void 0, b.useHTML, void 0, \"tooltip\").attr({\n              padding: b.padding,\n              r: b.borderRadius\n            }), d || this.label.attr({\n              fill: b.backgroundColor,\n              \"stroke-width\": b.borderWidth || 0\n            }).css(b.style).css({\n              pointerEvents: c\n            }));\n            if (a.outside) {\n              var _b16 = this.label,\n                _c7 = _b16.xSetter,\n                _f5 = _b16.ySetter;\n              _b16.xSetter = function (f) {\n                _c7.call(_b16, a.distance);\n                n.style.left = f + \"px\";\n              };\n              _b16.ySetter = function (c) {\n                _f5.call(_b16, a.distance);\n                n.style.top = c + \"px\";\n              };\n            }\n            this.label.attr({\n              zIndex: 8\n            }).shadow(b.shadow).add();\n          }\n          return this.label;\n        }\n      }, {\n        key: \"getPlayingField\",\n        value: function getPlayingField() {\n          var a = H.body,\n            d = H.documentElement,\n            b = this.chart,\n            f = this.distance,\n            c = this.outside;\n          return {\n            width: c ? Math.max(a.scrollWidth, d.scrollWidth, a.offsetWidth, d.offsetWidth, d.clientWidth) - 2 * f : b.chartWidth,\n            height: c ? Math.max(a.scrollHeight, d.scrollHeight, a.offsetHeight, d.offsetHeight, d.clientHeight) : b.chartHeight\n          };\n        }\n      }, {\n        key: \"getPosition\",\n        value: function getPosition(a, d, b) {\n          var f = this.chart,\n            c = this.distance,\n            n = {},\n            k = f.inverted && b.h || 0,\n            e = this.outside;\n          var q = this.getPlayingField();\n          var g = q.width,\n            h = q.height,\n            r = f.pointer.getChartPosition();\n          q = function q(n) {\n            var k = \"x\" === n;\n            return [n, k ? g : h, k ? a : d].concat(e ? [k ? a * r.scaleX : d * r.scaleY, k ? r.left - c + (b.plotX + f.plotLeft) * r.scaleX : r.top - c + (b.plotY + f.plotTop) * r.scaleY, 0, k ? g : h] : [k ? a : d, k ? b.plotX + f.plotLeft : b.plotY + f.plotTop, k ? f.plotLeft : f.plotTop, k ? f.plotLeft + f.plotWidth : f.plotTop + f.plotHeight]);\n          };\n          var l = q(\"y\"),\n            m = q(\"x\"),\n            p;\n          q = !!b.negative;\n          !f.polar && f.hoverSeries && f.hoverSeries.yAxis && f.hoverSeries.yAxis.reversed && (q = !q);\n          var t = !this.followPointer && F(b.ttBelow, !f.inverted === q),\n            w = function w(b, a, f, d, q, g, h) {\n              var l = e ? \"y\" === b ? c * r.scaleY : c * r.scaleX : c,\n                m = (f - d) / 2,\n                p = d < q - c,\n                J = q + c + d < a,\n                D = q - l - f + m;\n              q = q + l - m;\n              if (t && J) n[b] = q;else if (!t && p) n[b] = D;else if (p) n[b] = Math.min(h - d, 0 > D - k ? D : D - k);else if (J) n[b] = Math.max(g, q + k + f > a ? q : q + k);else return !1;\n            },\n            G = function G(b, a, f, d, k) {\n              var e;\n              k < c || k > a - c ? e = !1 : n[b] = k < f / 2 ? 1 : k > a - d / 2 ? a - d - 2 : k - f / 2;\n              return e;\n            },\n            v = function v(b) {\n              var c = l;\n              l = m;\n              m = c;\n              p = b;\n            },\n            J = function J() {\n              !1 !== w.apply(0, l) ? !1 !== G.apply(0, m) || p || (v(!0), J()) : p ? n.x = n.y = 0 : (v(!0), J());\n            };\n          (f.inverted || 1 < this.len) && v();\n          J();\n          return n;\n        }\n      }, {\n        key: \"hide\",\n        value: function hide(a) {\n          var d = this;\n          C.clearTimeout(this.hideTimer);\n          a = F(a, this.options.hideDelay);\n          this.isHidden || (this.hideTimer = k(function () {\n            d.getLabel().fadeOut(a ? void 0 : a);\n            d.isHidden = !0;\n          }, a));\n        }\n      }, {\n        key: \"init\",\n        value: function init(a, d) {\n          this.chart = a;\n          this.options = d;\n          this.crosshairs = [];\n          this.now = {\n            x: 0,\n            y: 0\n          };\n          this.isHidden = !0;\n          this.split = d.split && !a.inverted && !a.polar;\n          this.shared = d.shared || this.split;\n          this.outside = F(d.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY));\n        }\n      }, {\n        key: \"shouldStickOnContact\",\n        value: function shouldStickOnContact(a) {\n          return !(this.followPointer || !this.options.stickOnContact || a && !this.chart.pointer.inClass(a.target, \"highcharts-tooltip\"));\n        }\n      }, {\n        key: \"move\",\n        value: function move(a, d, b, f) {\n          var c = this,\n            n = c.now,\n            k = !1 !== c.options.animation && !c.isHidden && (1 < Math.abs(a - n.x) || 1 < Math.abs(d - n.y)),\n            e = c.followPointer || 1 < c.len;\n          m(n, {\n            x: k ? (2 * n.x + a) / 3 : a,\n            y: k ? (n.y + d) / 2 : d,\n            anchorX: e ? void 0 : k ? (2 * n.anchorX + b) / 3 : b,\n            anchorY: e ? void 0 : k ? (n.anchorY + f) / 2 : f\n          });\n          c.getLabel().attr(n);\n          c.drawTracker();\n          k && (C.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n            c && c.move(a, d, b, f);\n          }, 32));\n        }\n      }, {\n        key: \"refresh\",\n        value: function refresh(a, k) {\n          var b = this.chart,\n            f = this.options,\n            c = b.pointer,\n            n = d(a),\n            e = n[0],\n            q = [];\n          var r = f.format,\n            l = f.formatter || this.defaultFormatter;\n          var m = this.shared,\n            p = b.styledMode;\n          var t = {};\n          if (f.enabled && e.series) {\n            C.clearTimeout(this.hideTimer);\n            this.allowShared = !(!g(a) && a.series && a.series.noSharedTooltip);\n            this.followPointer = !this.split && e.series.tooltipOptions.followPointer;\n            a = this.getAnchor(a, k);\n            var v = a[0],\n              G = a[1];\n            m && this.allowShared ? (c.applyInactiveState(n), n.forEach(function (b) {\n              b.setState(\"hover\");\n              q.push(b.getLabelConfig());\n            }), t = e.getLabelConfig(), t.points = q) : t = e.getLabelConfig();\n            this.len = q.length;\n            r = w(r) ? x(r, t, b) : l.call(t, this);\n            l = e.series;\n            this.distance = F(l.tooltipOptions.distance, 16);\n            if (!1 === r) this.hide();else {\n              if (this.split && this.allowShared) this.renderSplit(r, n);else {\n                var _d6 = v,\n                  _g2 = G;\n                k && c.isDirectTouch && (_d6 = k.chartX - b.plotLeft, _g2 = k.chartY - b.plotTop);\n                if (b.polar || !1 === l.options.clip || n.some(function (b) {\n                  return c.isDirectTouch || b.series.shouldShowTooltip(_d6, _g2);\n                })) k = this.getLabel(), f.style.width && !p || k.css({\n                  width: (this.outside ? this.getPlayingField() : b.spacingBox).width + \"px\"\n                }), k.attr({\n                  text: r && r.join ? r.join(\"\") : r\n                }), k.addClass(this.getClassName(e), !0), p || k.attr({\n                  stroke: f.borderColor || e.color || l.color || \"#666666\"\n                }), this.updatePosition({\n                  plotX: v,\n                  plotY: G,\n                  negative: e.negative,\n                  ttBelow: e.ttBelow,\n                  h: a[2] || 0\n                });else {\n                  this.hide();\n                  return;\n                }\n              }\n              this.isHidden && this.label && this.label.attr({\n                opacity: 1\n              }).show();\n              this.isHidden = !1;\n            }\n            h(this, \"refresh\");\n          }\n        }\n      }, {\n        key: \"renderSplit\",\n        value: function renderSplit(a, d) {\n          function b(b, c, a, d) {\n            var n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !0;\n            a ? (c = S ? 0 : z, b = l(b - d / 2, J.left, J.right - d - (f.outside ? W : 0))) : (c -= da, b = n ? b - d - x : b + x, b = l(b, n ? b : J.left, J.right));\n            return {\n              x: b,\n              y: c\n            };\n          }\n          var f = this,\n            c = f.chart,\n            _f$chart = f.chart,\n            n = _f$chart.chartWidth,\n            k = _f$chart.chartHeight,\n            e = _f$chart.plotHeight,\n            g = _f$chart.plotLeft,\n            h = _f$chart.plotTop,\n            q = _f$chart.pointer,\n            _f$chart$scrollablePi = _f$chart.scrollablePixelsY,\n            r = _f$chart$scrollablePi === void 0 ? 0 : _f$chart$scrollablePi,\n            p = _f$chart.scrollablePixelsX,\n            _f$chart$scrollingCon = _f$chart.scrollingContainer,\n            _f$chart$scrollingCon2 = _f$chart$scrollingCon === void 0 ? {\n              scrollLeft: 0,\n              scrollTop: 0\n            } : _f$chart$scrollingCon,\n            t = _f$chart$scrollingCon2.scrollLeft,\n            v = _f$chart$scrollingCon2.scrollTop,\n            G = _f$chart.styledMode,\n            x = f.distance,\n            E = f.options,\n            y = f.options.positioner,\n            J = f.outside && \"number\" !== typeof p ? H.documentElement.getBoundingClientRect() : {\n              left: t,\n              right: t + n,\n              top: v,\n              bottom: v + k\n            },\n            N = f.getLabel(),\n            O = this.renderer || c.renderer,\n            S = !(!c.xAxis[0] || !c.xAxis[0].opposite),\n            _q$getChartPosition = q.getChartPosition(),\n            W = _q$getChartPosition.left,\n            ha = _q$getChartPosition.top;\n          var da = h + v,\n            C = 0,\n            z = e - r;\n          w(a) && (a = [!1, a]);\n          a = a.slice(0, d.length + 1).reduce(function (c, a, n) {\n            if (!1 !== a && \"\" !== a) {\n              n = d[n - 1] || {\n                isHeader: !0,\n                plotX: d[0].plotX,\n                plotY: e,\n                series: {}\n              };\n              var D = n.isHeader;\n              var k = D ? f : n.series,\n                q;\n              {\n                var r = n;\n                a = a.toString();\n                var m = k.tt;\n                var _r = r,\n                  _b17 = _r.isHeader,\n                  _c8 = _r.series;\n                m || (m = {\n                  padding: E.padding,\n                  r: E.borderRadius\n                }, G || (m.fill = E.backgroundColor, m[\"stroke-width\"] = null !== (q = E.borderWidth) && void 0 !== q ? q : 1), m = O.label(\"\", 0, 0, E[_b17 ? \"headerShape\" : \"shape\"], void 0, void 0, E.useHTML).addClass(f.getClassName(r, !0, _b17)).attr(m).add(N));\n                m.isActive = !0;\n                m.attr({\n                  text: a\n                });\n                G || m.css(E.style).attr({\n                  stroke: E.borderColor || r.color || _c8.color || \"#333333\"\n                });\n                q = m;\n              }\n              q = k.tt = q;\n              r = q.getBBox();\n              k = r.width + q.strokeWidth();\n              D && (C = r.height, z += C, S && (da -= C));\n              {\n                var _n3 = n,\n                  _b18 = _n3.isHeader,\n                  _n3$plotX = _n3.plotX,\n                  _c9 = _n3$plotX === void 0 ? 0 : _n3$plotX,\n                  _n3$plotY = _n3.plotY,\n                  _f6 = _n3$plotY === void 0 ? 0 : _n3$plotY,\n                  _d7 = _n3.series;\n                if (_b18) {\n                  a = g + _c9;\n                  var p = h + e / 2;\n                } else {\n                  var _b19 = _d7.xAxis,\n                    _n4 = _d7.yAxis;\n                  a = _b19.pos + l(_c9, -x, _b19.len + x);\n                  _d7.shouldShowTooltip(0, _n4.pos - h + _f6, {\n                    ignoreX: !0\n                  }) && (p = _n4.pos + _f6);\n                }\n                a = l(a, J.left - x, J.right + x);\n                p = {\n                  anchorX: a,\n                  anchorY: p\n                };\n              }\n              var _p = p,\n                _t = _p.anchorX,\n                _Q = _p.anchorY;\n              \"number\" === typeof _Q ? (p = r.height + 1, r = y ? y.call(f, k, p, n) : b(_t, _Q, D, k), c.push({\n                align: y ? 0 : void 0,\n                anchorX: _t,\n                anchorY: _Q,\n                boxWidth: k,\n                point: n,\n                rank: F(r.rank, D ? 1 : 0),\n                size: p,\n                target: r.y,\n                tt: q,\n                x: r.x\n              })) : q.isActive = !1;\n            }\n            return c;\n          }, []);\n          !y && a.some(function (b) {\n            var c = f.outside;\n            c = (c ? W : 0) + b.anchorX;\n            return c < J.left && c + b.boxWidth < J.right ? !0 : c < W - J.left + b.boxWidth && J.right - c > c;\n          }) && (a = a.map(function (c) {\n            var _b20 = b(c.anchorX, c.anchorY, c.point.isHeader, c.boxWidth, !1),\n              a = _b20.x,\n              f = _b20.y;\n            return m(c, {\n              target: f,\n              x: a\n            });\n          }));\n          f.cleanSplit();\n          u(a, z);\n          var ca = W,\n            L = W;\n          a.forEach(function (b) {\n            var c = b.x,\n              a = b.boxWidth,\n              d = b.isHeader;\n            d || (f.outside && W + c < ca && (ca = W + c), !d && f.outside && ca + a > L && (L = W + c));\n          });\n          a.forEach(function (b) {\n            var c = b.x,\n              a = b.anchorX,\n              d = b.anchorY,\n              n = b.pos,\n              k = b.point.isHeader,\n              e = {\n                visibility: \"undefined\" === typeof n ? \"hidden\" : \"inherit\",\n                x: c,\n                y: (n || 0) + da,\n                anchorX: a,\n                anchorY: d\n              };\n            if (f.outside && c < a) {\n              var _b21 = W - ca;\n              0 < _b21 && (k || (e.x = c + _b21, e.anchorX = a + _b21), k && (e.x = (L - ca) / 2, e.anchorX = a + _b21));\n            }\n            b.tt.attr(e);\n          });\n          var R = f.container,\n            Q = f.outside,\n            la = f.renderer;\n          if (Q && R && la) {\n            var _N$getBBox = N.getBBox(),\n              _b22 = _N$getBBox.width,\n              _c10 = _N$getBBox.height,\n              _a7 = _N$getBBox.x,\n              _f7 = _N$getBBox.y;\n            la.setSize(_b22 + _a7, _c10 + _f7, !1);\n            R.style.left = ca + \"px\";\n            R.style.top = ha + \"px\";\n          }\n          B && N.attr({\n            opacity: 1 === N.opacity ? .999 : 1\n          });\n        }\n      }, {\n        key: \"drawTracker\",\n        value: function drawTracker() {\n          if (this.shouldStickOnContact()) {\n            var a = this.chart,\n              d = this.label,\n              b = this.shared ? a.hoverPoints : a.hoverPoint;\n            if (d && b) {\n              var f = {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0\n              };\n              b = this.getAnchor(b);\n              var c = d.getBBox();\n              b[0] += a.plotLeft - d.translateX;\n              b[1] += a.plotTop - d.translateY;\n              f.x = Math.min(0, b[0]);\n              f.y = Math.min(0, b[1]);\n              f.width = 0 > b[0] ? Math.max(Math.abs(b[0]), c.width - b[0]) : Math.max(Math.abs(b[0]), c.width);\n              f.height = 0 > b[1] ? Math.max(Math.abs(b[1]), c.height - Math.abs(b[1])) : Math.max(Math.abs(b[1]), c.height);\n              this.tracker ? this.tracker.attr(f) : (this.tracker = d.renderer.rect(f).addClass(\"highcharts-tracker\").add(d), a.styledMode || this.tracker.attr({\n                fill: \"rgba(0,0,0,0)\"\n              }));\n            }\n          } else this.tracker && (this.tracker = this.tracker.destroy());\n        }\n      }, {\n        key: \"styledModeFormat\",\n        value: function styledModeFormat(a) {\n          return a.replace('style=\"font-size: 0.8em\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}\"');\n        }\n      }, {\n        key: \"tooltipFooterHeaderFormatter\",\n        value: function tooltipFooterHeaderFormatter(a, d) {\n          var b = a.series,\n            f = b.tooltipOptions;\n          var c = b.xAxis;\n          var n = c && c.dateTime;\n          c = {\n            isFooter: d,\n            labelConfig: a\n          };\n          var k = f.xDateFormat,\n            g = f[d ? \"footerFormat\" : \"headerFormat\"];\n          h(this, \"headerFormatter\", c, function (c) {\n            n && !k && e(a.key) && (k = n.getXDateFormat(a.key, f.dateTimeLabelFormats));\n            n && k && (a.point && a.point.tooltipDateKeys || [\"key\"]).forEach(function (b) {\n              g = g.replace(\"{point.\" + b + \"}\", \"{point.\" + b + \":\" + k + \"}\");\n            });\n            b.chart.styledMode && (g = this.styledModeFormat(g));\n            c.text = x(g, {\n              point: a,\n              series: b\n            }, this.chart);\n          });\n          return c.text;\n        }\n      }, {\n        key: \"update\",\n        value: function update(a) {\n          this.destroy();\n          this.init(this.chart, E(!0, this.options, a));\n        }\n      }, {\n        key: \"updatePosition\",\n        value: function updatePosition(a) {\n          var d = this.chart,\n            b = this.distance,\n            f = this.options;\n          var c = d.pointer;\n          var n = this.getLabel(),\n            _c$getChartPosition = c.getChartPosition(),\n            k = _c$getChartPosition.left,\n            e = _c$getChartPosition.top,\n            g = _c$getChartPosition.scaleX,\n            h = _c$getChartPosition.scaleY;\n          c = (f.positioner || this.getPosition).call(this, n.width, n.height, a);\n          var q = (a.plotX || 0) + d.plotLeft;\n          a = (a.plotY || 0) + d.plotTop;\n          var r;\n          if (this.outside) {\n            f.positioner && (c.x += k - b, c.y += e - b);\n            r = (f.borderWidth || 0) + 2 * b;\n            this.renderer.setSize(n.width + r, n.height + r, !1);\n            if (1 !== g || 1 !== h) p(this.container, {\n              transform: \"scale(\".concat(g, \", \").concat(h, \")\")\n            }), q *= g, a *= h;\n            q += k - c.x;\n            a += e - c.y;\n          }\n          this.move(Math.round(c.x), Math.round(c.y || 0), q, a);\n        }\n      }]);\n      return r;\n    }();\n    (function (a) {\n      var d = [];\n      a.compose = function (b) {\n        C.pushUnique(d, b) && v(b, \"afterInit\", function () {\n          var b = this.chart;\n          b.options.tooltip && (b.tooltip = new a(b, b.options.tooltip));\n        });\n      };\n    })(r || (r = {}));\n    \"\";\n    return r;\n  });\n  M(a, \"Core/Series/Point.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Defaults.js\"], a[\"Core/Templating.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C) {\n    var x = y.animObject,\n      H = I.defaultOptions,\n      B = L.format,\n      u = C.addEvent,\n      v = C.defined,\n      l = C.erase,\n      p = C.extend,\n      t = C.fireEvent,\n      m = C.getNestedProperty,\n      h = C.isArray,\n      g = C.isFunction,\n      e = C.isNumber,\n      w = C.isObject,\n      E = C.merge,\n      F = C.objectEach,\n      d = C.pick,\n      k = C.syncTimeout,\n      r = C.removeEvent,\n      q = C.uniqueKey;\n    var G = /*#__PURE__*/function () {\n      function G() {\n        _classCallCheck(this, G);\n        this.category = void 0;\n        this.destroyed = !1;\n        this.formatPrefix = \"point\";\n        this.id = void 0;\n        this.isNull = !1;\n        this.percentage = this.options = this.name = void 0;\n        this.selected = !1;\n        this.total = this.shapeArgs = this.series = void 0;\n        this.visible = !0;\n        this.x = void 0;\n      }\n      _createClass(G, [{\n        key: \"animateBeforeDestroy\",\n        value: function animateBeforeDestroy() {\n          var b = this,\n            a = {\n              x: b.startXPos,\n              opacity: 0\n            },\n            c = b.getGraphicalProps();\n          c.singular.forEach(function (c) {\n            b[c] = b[c].animate(\"dataLabel\" === c ? {\n              x: b[c].startXPos,\n              y: b[c].startYPos,\n              opacity: 0\n            } : a);\n          });\n          c.plural.forEach(function (c) {\n            b[c].forEach(function (c) {\n              c.element && c.animate(p({\n                x: b.startXPos\n              }, c.startYPos ? {\n                x: c.startXPos,\n                y: c.startYPos\n              } : {}));\n            });\n          });\n        }\n      }, {\n        key: \"applyOptions\",\n        value: function applyOptions(b, a) {\n          var c = this.series,\n            f = c.options.pointValKey || c.pointValKey;\n          b = G.prototype.optionsToObject.call(this, b);\n          p(this, b);\n          this.options = this.options ? p(this.options, b) : b;\n          b.group && delete this.group;\n          b.dataLabels && delete this.dataLabels;\n          f && (this.y = G.prototype.getNestedProperty.call(this, f));\n          this.formatPrefix = (this.isNull = this.isValid && !this.isValid()) ? \"null\" : \"point\";\n          this.selected && (this.state = \"select\");\n          \"name\" in this && \"undefined\" === typeof a && c.xAxis && c.xAxis.hasNames && (this.x = c.xAxis.nameToX(this));\n          \"undefined\" === typeof this.x && c ? this.x = \"undefined\" === typeof a ? c.autoIncrement() : a : e(b.x) && c.options.relativeXValue && (this.x = c.autoIncrement(b.x));\n          return this;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          if (!this.destroyed) {\n            var _a8 = this;\n            var b = _a8.series;\n            var c = b.chart;\n            b = b.options.dataSorting;\n            var _d8 = c.hoverPoints,\n              _e3 = x(_a8.series.chart.renderer.globalAnimation),\n              _g3 = function _g3() {\n                if (_a8.graphic || _a8.graphics || _a8.dataLabel || _a8.dataLabels) r(_a8), _a8.destroyElements();\n                for (var _b23 in _a8) delete _a8[_b23];\n              };\n            _a8.legendItem && c.legend.destroyItem(_a8);\n            _d8 && (_a8.setState(), l(_d8, _a8), _d8.length || (c.hoverPoints = null));\n            if (_a8 === c.hoverPoint) _a8.onMouseOut();\n            b && b.enabled ? (this.animateBeforeDestroy(), k(_g3, _e3.duration)) : _g3();\n            c.pointCount--;\n          }\n          this.destroyed = !0;\n        }\n      }, {\n        key: \"destroyElements\",\n        value: function destroyElements(b) {\n          var a = this;\n          b = a.getGraphicalProps(b);\n          b.singular.forEach(function (b) {\n            a[b] = a[b].destroy();\n          });\n          b.plural.forEach(function (b) {\n            a[b].forEach(function (b) {\n              b && b.element && b.destroy();\n            });\n            delete a[b];\n          });\n        }\n      }, {\n        key: \"firePointEvent\",\n        value: function firePointEvent(b, a, c) {\n          var f = this,\n            d = this.series.options;\n          (d.point.events[b] || f.options && f.options.events && f.options.events[b]) && f.importEvents();\n          \"click\" === b && d.allowPointSelect && (c = function c(b) {\n            f.select && f.select(null, b.ctrlKey || b.metaKey || b.shiftKey);\n          });\n          t(f, b, a, c);\n        }\n      }, {\n        key: \"getClassName\",\n        value: function getClassName() {\n          return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (\"undefined\" !== typeof this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n        }\n      }, {\n        key: \"getGraphicalProps\",\n        value: function getGraphicalProps(b) {\n          var a = this,\n            c = [],\n            d = {\n              singular: [],\n              plural: []\n            };\n          var k, e;\n          b = b || {\n            graphic: 1,\n            dataLabel: 1\n          };\n          b.graphic && c.push(\"graphic\");\n          b.dataLabel && c.push(\"dataLabel\", \"dataLabelPath\", \"dataLabelUpper\", \"connector\");\n          for (e = c.length; e--;) k = c[e], a[k] && d.singular.push(k);\n          [\"graphic\", \"dataLabel\", \"connector\"].forEach(function (c) {\n            var f = c + \"s\";\n            b[c] && a[f] && d.plural.push(f);\n          });\n          return d;\n        }\n      }, {\n        key: \"getLabelConfig\",\n        value: function getLabelConfig() {\n          return {\n            x: this.category,\n            y: this.y,\n            color: this.color,\n            colorIndex: this.colorIndex,\n            key: this.name || this.category,\n            series: this.series,\n            point: this,\n            percentage: this.percentage,\n            total: this.total || this.stackTotal\n          };\n        }\n      }, {\n        key: \"getNestedProperty\",\n        value: function getNestedProperty(b) {\n          if (b) return 0 === b.indexOf(\"custom.\") ? m(b, this.options) : this[b];\n        }\n      }, {\n        key: \"getZone\",\n        value: function getZone() {\n          var b = this.series;\n          var a = b.zones;\n          b = b.zoneAxis || \"y\";\n          var c,\n            d = 0;\n          for (c = a[d]; this[b] >= c.value;) c = a[++d];\n          this.nonZonedColor || (this.nonZonedColor = this.color);\n          this.color = c && c.color && !this.options.color ? c.color : this.nonZonedColor;\n          return c;\n        }\n      }, {\n        key: \"hasNewShapeType\",\n        value: function hasNewShapeType() {\n          return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n        }\n      }, {\n        key: \"init\",\n        value: function init(b, a, c) {\n          this.series = b;\n          this.applyOptions(a, c);\n          this.id = v(this.id) ? this.id : q();\n          this.resolveColor();\n          b.chart.pointCount++;\n          t(this, \"afterInit\");\n          return this;\n        }\n      }, {\n        key: \"isValid\",\n        value: function isValid() {\n          return null !== this.x && e(this.y);\n        }\n      }, {\n        key: \"optionsToObject\",\n        value: function optionsToObject(b) {\n          var a = this.series;\n          var c = a.options.keys,\n            d = c || a.pointArrayMap || [\"y\"],\n            k = d.length;\n          var g = {},\n            q = 0,\n            r = 0;\n          if (e(b) || null === b) g[d[0]] = b;else if (h(b)) for (!c && b.length > k && (a = typeof b[0], \"string\" === a ? g.name = b[0] : \"number\" === a && (g.x = b[0]), q++); r < k;) c && \"undefined\" === typeof b[q] || (0 < d[r].indexOf(\".\") ? G.prototype.setNestedProperty(g, b[q], d[r]) : g[d[r]] = b[q]), q++, r++;else \"object\" === typeof b && (g = b, b.dataLabels && (a._hasPointLabels = !0), b.marker && (a._hasPointMarkers = !0));\n          return g;\n        }\n      }, {\n        key: \"pos\",\n        value: function pos(b) {\n          var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.plotY;\n          if (!this.destroyed) {\n            var c = this.plotX,\n              f = this.series,\n              _d9 = f.chart,\n              _k6 = f.xAxis,\n              _g4 = f.yAxis;\n            var _h6 = 0,\n              _q = 0;\n            if (e(c) && e(a)) return b && (_h6 = _k6 ? _k6.pos : _d9.plotLeft, _q = _g4 ? _g4.pos : _d9.plotTop), _d9.inverted && _k6 && _g4 ? [_g4.len - a + _q, _k6.len - c + _h6] : [c + _h6, a + _q];\n          }\n        }\n      }, {\n        key: \"resolveColor\",\n        value: function resolveColor() {\n          var b = this.series;\n          var a = b.chart.styledMode;\n          var c;\n          var k = b.chart.options.chart.colorCount;\n          delete this.nonZonedColor;\n          b.options.colorByPoint ? (a || (k = b.options.colors || b.chart.options.colors, c = k[b.colorCounter], k = k.length), a = b.colorCounter, b.colorCounter++, b.colorCounter === k && (b.colorCounter = 0)) : (a || (c = b.color), a = b.colorIndex);\n          this.colorIndex = d(this.options.colorIndex, a);\n          this.color = d(this.options.color, c);\n        }\n      }, {\n        key: \"setNestedProperty\",\n        value: function setNestedProperty(b, a, c) {\n          c.split(\".\").reduce(function (b, c, f, d) {\n            b[c] = d.length - 1 === f ? a : w(b[c], !0) ? b[c] : {};\n            return b[c];\n          }, b);\n          return b;\n        }\n      }, {\n        key: \"shouldDraw\",\n        value: function shouldDraw() {\n          return !this.isNull;\n        }\n      }, {\n        key: \"tooltipFormatter\",\n        value: function tooltipFormatter(b) {\n          var a = this.series,\n            c = a.tooltipOptions,\n            k = d(c.valueDecimals, \"\"),\n            e = c.valuePrefix || \"\",\n            g = c.valueSuffix || \"\";\n          a.chart.styledMode && (b = a.chart.tooltip.styledModeFormat(b));\n          (a.pointArrayMap || [\"y\"]).forEach(function (c) {\n            c = \"{point.\" + c;\n            if (e || g) b = b.replace(RegExp(c + \"}\", \"g\"), e + c + \"}\" + g);\n            b = b.replace(RegExp(c + \"}\", \"g\"), c + \":,.\" + k + \"f}\");\n          });\n          return B(b, {\n            point: this,\n            series: this.series\n          }, a.chart);\n        }\n      }, {\n        key: \"update\",\n        value: function update(b, a, c, k) {\n          function f() {\n            n.applyOptions(b);\n            var f = g && n.hasMockGraphic;\n            f = null === n.y ? !f : f;\n            g && f && (n.graphic = g.destroy(), delete n.hasMockGraphic);\n            w(b, !0) && (g && g.element && b && b.marker && \"undefined\" !== typeof b.marker.symbol && (n.graphic = g.destroy()), b && b.dataLabels && n.dataLabel && (n.dataLabel = n.dataLabel.destroy()), n.connector && (n.connector = n.connector.destroy()));\n            r = n.index;\n            e.updateParallelArrays(n, r);\n            q.data[r] = w(q.data[r], !0) || w(b, !0) ? n.options : d(b, q.data[r]);\n            e.isDirty = e.isDirtyData = !0;\n            !e.fixedBox && e.hasCartesianSeries && (h.isDirtyBox = !0);\n            \"point\" === q.legendType && (h.isDirtyLegend = !0);\n            a && h.redraw(c);\n          }\n          var n = this,\n            e = n.series,\n            g = n.graphic,\n            h = e.chart,\n            q = e.options;\n          var r;\n          a = d(a, !0);\n          !1 === k ? f() : n.firePointEvent(\"update\", {\n            options: b\n          }, f);\n        }\n      }, {\n        key: \"remove\",\n        value: function remove(b, a) {\n          this.series.removePoint(this.series.data.indexOf(this), b, a);\n        }\n      }, {\n        key: \"select\",\n        value: function select(b, a) {\n          var c = this,\n            f = c.series,\n            k = f.chart;\n          this.selectedStaging = b = d(b, !c.selected);\n          c.firePointEvent(b ? \"select\" : \"unselect\", {\n            accumulate: a\n          }, function () {\n            c.selected = c.options.selected = b;\n            f.options.data[f.data.indexOf(c)] = c.options;\n            c.setState(b && \"select\");\n            a || k.getSelectedPoints().forEach(function (b) {\n              var a = b.series;\n              b.selected && b !== c && (b.selected = b.options.selected = !1, a.options.data[a.data.indexOf(b)] = b.options, b.setState(k.hoverPoints && a.options.inactiveOtherPoints ? \"inactive\" : \"\"), b.firePointEvent(\"unselect\"));\n            });\n          });\n          delete this.selectedStaging;\n        }\n      }, {\n        key: \"onMouseOver\",\n        value: function onMouseOver(b) {\n          var a = this.series.chart,\n            c = a.pointer;\n          b = b ? c.normalize(b) : c.getChartCoordinatesFromPoint(this, a.inverted);\n          c.runPointActions(b, this);\n        }\n      }, {\n        key: \"onMouseOut\",\n        value: function onMouseOut() {\n          var b = this.series.chart;\n          this.firePointEvent(\"mouseOut\");\n          this.series.options.inactiveOtherPoints || (b.hoverPoints || []).forEach(function (b) {\n            b.setState();\n          });\n          b.hoverPoints = b.hoverPoint = null;\n        }\n      }, {\n        key: \"importEvents\",\n        value: function importEvents() {\n          if (!this.hasImportedEvents) {\n            var b = this,\n              _a9 = E(b.series.options.point, b.options).events;\n            b.events = _a9;\n            F(_a9, function (c, a) {\n              g(c) && u(b, a, c);\n            });\n            this.hasImportedEvents = !0;\n          }\n        }\n      }, {\n        key: \"setState\",\n        value: function setState(b, f) {\n          var c = this.series;\n          var k = this.state,\n            g = c.options.states[b || \"normal\"] || {},\n            h = H.plotOptions[c.type].marker && c.options.marker;\n          var q = h && !1 === h.enabled,\n            r = h && h.states && h.states[b || \"normal\"] || {},\n            l = !1 === r.enabled,\n            m = this.marker || {},\n            w = c.chart,\n            v = h && c.markerAttribs;\n          var G = c.halo;\n          var u;\n          var x;\n          var E = c.stateMarkerGraphic;\n          b = b || \"\";\n          if (!(b === this.state && !f || this.selected && \"select\" !== b || !1 === g.enabled || b && (l || q && !1 === r.enabled) || b && m.states && m.states[b] && !1 === m.states[b].enabled)) {\n            this.state = b;\n            v && (u = c.markerAttribs(this, b));\n            if (this.graphic && !this.hasMockGraphic) {\n              k && this.graphic.removeClass(\"highcharts-point-\" + k);\n              b && this.graphic.addClass(\"highcharts-point-\" + b);\n              if (!w.styledMode) {\n                k = c.pointAttribs(this, b);\n                x = d(w.options.chart.animation, g.animation);\n                var _a10 = k.opacity;\n                c.options.inactiveOtherPoints && e(_a10) && ((this.dataLabels || []).forEach(function (b) {\n                  b && !b.hasClass(\"highcharts-data-label-hidden\") && b.animate({\n                    opacity: _a10\n                  }, x);\n                }), this.connector && this.connector.animate({\n                  opacity: _a10\n                }, x));\n                this.graphic.animate(k, x);\n              }\n              u && this.graphic.animate(u, d(w.options.chart.animation, r.animation, h.animation));\n              E && E.hide();\n            } else {\n              if (b && r) {\n                h = m.symbol || c.symbol;\n                E && E.currentSymbol !== h && (E = E.destroy());\n                if (u) if (E) E[f ? \"animate\" : \"attr\"]({\n                  x: u.x,\n                  y: u.y\n                });else h && (c.stateMarkerGraphic = E = w.renderer.symbol(h, u.x, u.y, u.width, u.height).add(c.markerGroup), E.currentSymbol = h);\n                !w.styledMode && E && \"inactive\" !== this.state && E.attr(c.pointAttribs(this, b));\n              }\n              E && (E[b && this.isInside ? \"show\" : \"hide\"](), E.element.point = this, E.addClass(this.getClassName(), !0));\n            }\n            g = g.halo;\n            u = (E = this.graphic || E) && E.visibility || \"inherit\";\n            g && g.size && E && \"hidden\" !== u && !this.isCluster ? (G || (c.halo = G = w.renderer.path().add(E.parentGroup)), G.show()[f ? \"animate\" : \"attr\"]({\n              d: this.haloPath(g.size)\n            }), G.attr({\n              \"class\": \"highcharts-halo highcharts-color-\" + d(this.colorIndex, c.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n              visibility: u,\n              zIndex: -1\n            }), G.point = this, w.styledMode || G.attr(p({\n              fill: this.color || c.color,\n              \"fill-opacity\": g.opacity\n            }, a.filterUserAttributes(g.attributes || {})))) : G && G.point && G.point.haloPath && G.animate({\n              d: G.point.haloPath(0)\n            }, null, G.hide);\n            t(this, \"afterSetState\", {\n              state: b\n            });\n          }\n        }\n      }, {\n        key: \"haloPath\",\n        value: function haloPath(b) {\n          var a = this.pos();\n          return a ? this.series.chart.renderer.symbols.circle(Math.floor(a[0]) - b, a[1] - b, 2 * b, 2 * b) : [];\n        }\n      }]);\n      return G;\n    }();\n    \"\";\n    return G;\n  });\n  M(a, \"Core/Pointer.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    var x = a.parse,\n      C = y.charts,\n      z = y.noop,\n      H = I.addEvent,\n      B = I.attr,\n      u = I.css,\n      v = I.defined,\n      l = I.extend,\n      p = I.find,\n      t = I.fireEvent,\n      m = I.isNumber,\n      h = I.isObject,\n      g = I.objectEach,\n      e = I.offset,\n      w = I.pick,\n      E = I.splat;\n    var F = /*#__PURE__*/function () {\n      function F(a, k) {\n        _classCallCheck(this, F);\n        this.lastValidTouch = {};\n        this.pinchDown = [];\n        this.runChartClick = !1;\n        this.eventsToUnbind = [];\n        this.chart = a;\n        this.hasDragged = !1;\n        this.options = k;\n        this.init(a, k);\n      }\n      _createClass(F, [{\n        key: \"applyInactiveState\",\n        value: function applyInactiveState(a) {\n          var d = [],\n            e;\n          (a || []).forEach(function (a) {\n            e = a.series;\n            d.push(e);\n            e.linkedParent && d.push(e.linkedParent);\n            e.linkedSeries && (d = d.concat(e.linkedSeries));\n            e.navigatorSeries && d.push(e.navigatorSeries);\n          });\n          this.chart.series.forEach(function (a) {\n            -1 === d.indexOf(a) ? a.setState(\"inactive\", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState(\"inactive\");\n          });\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var a = this;\n          this.eventsToUnbind.forEach(function (a) {\n            return a();\n          });\n          this.eventsToUnbind = [];\n          y.chartCount || (F.unbindDocumentMouseUp && (F.unbindDocumentMouseUp = F.unbindDocumentMouseUp()), F.unbindDocumentTouchEnd && (F.unbindDocumentTouchEnd = F.unbindDocumentTouchEnd()));\n          clearInterval(a.tooltipTimeout);\n          g(a, function (d, e) {\n            a[e] = void 0;\n          });\n        }\n      }, {\n        key: \"getSelectionMarkerAttrs\",\n        value: function getSelectionMarkerAttrs(a, k) {\n          var _this8 = this;\n          var d = {\n            args: {\n              chartX: a,\n              chartY: k\n            },\n            attrs: {},\n            shapeType: \"rect\"\n          };\n          t(this, \"getSelectionMarkerAttrs\", d, function (d) {\n            var e = _this8.chart,\n              _this8$mouseDownX = _this8.mouseDownX,\n              b = _this8$mouseDownX === void 0 ? 0 : _this8$mouseDownX,\n              _this8$mouseDownY = _this8.mouseDownY,\n              f = _this8$mouseDownY === void 0 ? 0 : _this8$mouseDownY,\n              c = _this8.zoomHor,\n              n = _this8.zoomVert;\n            d = d.attrs;\n            var g;\n            d.x = e.plotLeft;\n            d.y = e.plotTop;\n            d.width = c ? 1 : e.plotWidth;\n            d.height = n ? 1 : e.plotHeight;\n            c && (g = a - b, d.width = Math.abs(g), d.x = (0 < g ? 0 : g) + b);\n            n && (g = k - f, d.height = Math.abs(g), d.y = (0 < g ? 0 : g) + f);\n          });\n          return d;\n        }\n      }, {\n        key: \"drag\",\n        value: function drag(a) {\n          var d = this.chart,\n            e = d.options.chart;\n          var g = d.plotLeft;\n          var l = d.plotTop,\n            b = d.plotWidth,\n            f = d.plotHeight,\n            c = this.mouseDownX || 0,\n            n = this.mouseDownY || 0,\n            m = h(e.panning) ? e.panning && e.panning.enabled : e.panning,\n            p = e.panKey && a[e.panKey + \"Key\"];\n          var t = a.chartX,\n            w = a.chartY,\n            v = this.selectionMarker;\n          if (!v || !v.touch) if (t < g ? t = g : t > g + b && (t = g + b), w < l ? w = l : w > l + f && (w = l + f), this.hasDragged = Math.sqrt(Math.pow(c - t, 2) + Math.pow(n - w, 2)), 10 < this.hasDragged) {\n            g = d.isInsidePlot(c - g, n - l, {\n              visiblePlotOnly: !0\n            });\n            var _this$getSelectionMar = this.getSelectionMarkerAttrs(t, w),\n              _b24 = _this$getSelectionMar.shapeType,\n              _f8 = _this$getSelectionMar.attrs;\n            !d.hasCartesianSeries && !d.mapView || !this.zoomX && !this.zoomY || !g || p || v || (this.selectionMarker = v = d.renderer[_b24](), v.attr({\n              \"class\": \"highcharts-selection-marker\",\n              zIndex: 7\n            }).add(), d.styledMode || v.attr({\n              fill: e.selectionMarkerFill || x(\"#334eff\").setOpacity(.25).get()\n            }));\n            v && v.attr(_f8);\n            g && !v && m && d.pan(a, e.panning);\n          }\n        }\n      }, {\n        key: \"dragStart\",\n        value: function dragStart(a) {\n          var d = this.chart;\n          d.mouseIsDown = a.type;\n          d.cancelClick = !1;\n          d.mouseDownX = this.mouseDownX = a.chartX;\n          d.mouseDownY = this.mouseDownY = a.chartY;\n        }\n      }, {\n        key: \"getSelectionBox\",\n        value: function getSelectionBox(a) {\n          var d = {\n            args: {\n              marker: a\n            },\n            result: {}\n          };\n          t(this, \"getSelectionBox\", d, function (d) {\n            d.result = {\n              x: a.attr ? +a.attr(\"x\") : a.x,\n              y: a.attr ? +a.attr(\"y\") : a.y,\n              width: a.attr ? a.attr(\"width\") : a.width,\n              height: a.attr ? a.attr(\"height\") : a.height\n            };\n          });\n          return d.result;\n        }\n      }, {\n        key: \"drop\",\n        value: function drop(a) {\n          var d = this,\n            e = this.chart,\n            g = this.hasPinched;\n          if (this.selectionMarker) {\n            var _this$getSelectionBox = this.getSelectionBox(this.selectionMarker),\n              k = _this$getSelectionBox.x,\n              b = _this$getSelectionBox.y,\n              f = _this$getSelectionBox.width,\n              c = _this$getSelectionBox.height,\n              n = {\n                originalEvent: a,\n                xAxis: [],\n                yAxis: [],\n                x: k,\n                y: b,\n                width: f,\n                height: c\n              };\n            var _h7 = !!e.mapView;\n            if (this.hasDragged || g) e.axes.forEach(function (e) {\n              if (e.zoomEnabled && v(e.min) && (g || d[{\n                xAxis: \"zoomX\",\n                yAxis: \"zoomY\"\n              }[e.coll]]) && m(k) && m(b) && m(f) && m(c)) {\n                var q = e.horiz;\n                var _d10 = \"touchend\" === a.type ? e.minPixelPadding : 0,\n                  _g5 = e.toValue((q ? k : b) + _d10);\n                q = e.toValue((q ? k + f : b + c) - _d10);\n                n[e.coll].push({\n                  axis: e,\n                  min: Math.min(_g5, q),\n                  max: Math.max(_g5, q)\n                });\n                _h7 = !0;\n              }\n            }), _h7 && t(e, \"selection\", n, function (b) {\n              e.zoom(l(b, g ? {\n                animation: !1\n              } : null));\n            });\n            m(e.index) && (this.selectionMarker = this.selectionMarker.destroy());\n            g && this.scaleGroups();\n          }\n          e && m(e.index) && (u(e.container, {\n            cursor: e._cursor\n          }), e.cancelClick = 10 < this.hasDragged, e.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n        }\n      }, {\n        key: \"findNearestKDPoint\",\n        value: function findNearestKDPoint(a, k, e) {\n          var d;\n          a.forEach(function (a) {\n            var b = !(a.noSharedTooltip && k) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n            a = a.searchPoint(e, b);\n            if ((b = h(a, !0) && a.series) && !(b = !h(d, !0))) {\n              {\n                b = d.distX - a.distX;\n                var f = d.dist - a.dist,\n                  c = (a.series.group && a.series.group.zIndex) - (d.series.group && d.series.group.zIndex);\n                b = 0 !== b && k ? b : 0 !== f ? f : 0 !== c ? c : d.series.index > a.series.index ? -1 : 1;\n              }\n              b = 0 < b;\n            }\n            b && (d = a);\n          });\n          return d;\n        }\n      }, {\n        key: \"getChartCoordinatesFromPoint\",\n        value: function getChartCoordinatesFromPoint(a, k) {\n          var d = a.series;\n          var e = d.xAxis;\n          d = d.yAxis;\n          var g = a.shapeArgs;\n          if (e && d) {\n            var b = w(a.clientX, a.plotX),\n              f = a.plotY || 0;\n            a.isNode && g && m(g.x) && m(g.y) && (b = g.x, f = g.y);\n            return k ? {\n              chartX: d.len + d.pos - f,\n              chartY: e.len + e.pos - b\n            } : {\n              chartX: b + e.pos,\n              chartY: f + d.pos\n            };\n          }\n          if (g && g.x && g.y) return {\n            chartX: g.x,\n            chartY: g.y\n          };\n        }\n      }, {\n        key: \"getChartPosition\",\n        value: function getChartPosition() {\n          if (this.chartPosition) return this.chartPosition;\n          var a = this.chart.container;\n          var k = e(a);\n          this.chartPosition = {\n            left: k.left,\n            top: k.top,\n            scaleX: 1,\n            scaleY: 1\n          };\n          var g = a.offsetWidth;\n          a = a.offsetHeight;\n          2 < g && 2 < a && (this.chartPosition.scaleX = k.width / g, this.chartPosition.scaleY = k.height / a);\n          return this.chartPosition;\n        }\n      }, {\n        key: \"getCoordinates\",\n        value: function getCoordinates(a) {\n          var d = {\n            xAxis: [],\n            yAxis: []\n          };\n          this.chart.axes.forEach(function (k) {\n            d[k.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n              axis: k,\n              value: k.toValue(a[k.horiz ? \"chartX\" : \"chartY\"])\n            });\n          });\n          return d;\n        }\n      }, {\n        key: \"getHoverData\",\n        value: function getHoverData(a, k, e, g, l, b) {\n          var f = [];\n          g = !(!g || !a);\n          var c = function c(b) {\n            return b.visible && !(!l && b.directTouch) && w(b.options.enableMouseTracking, !0);\n          };\n          var d,\n            q = {\n              chartX: b ? b.chartX : void 0,\n              chartY: b ? b.chartY : void 0,\n              shared: l\n            };\n          t(this, \"beforeGetHoverData\", q);\n          d = k && !k.stickyTracking ? [k] : e.filter(function (b) {\n            return b.stickyTracking && (q.filter || c)(b);\n          });\n          var r = g || !b ? a : this.findNearestKDPoint(d, l, b);\n          k = r && r.series;\n          r && (l && !k.noSharedTooltip ? (d = e.filter(function (b) {\n            return q.filter ? q.filter(b) : c(b) && !b.noSharedTooltip;\n          }), d.forEach(function (b) {\n            var c = p(b.points, function (b) {\n              return b.x === r.x && !b.isNull;\n            });\n            h(c) && (b.boosted && b.boost && (c = b.boost.getPoint(c)), f.push(c));\n          })) : f.push(r));\n          q = {\n            hoverPoint: r\n          };\n          t(this, \"afterGetHoverData\", q);\n          return {\n            hoverPoint: q.hoverPoint,\n            hoverSeries: k,\n            hoverPoints: f\n          };\n        }\n      }, {\n        key: \"getPointFromEvent\",\n        value: function getPointFromEvent(a) {\n          a = a.target;\n          var d;\n          for (; a && !d;) d = a.point, a = a.parentNode;\n          return d;\n        }\n      }, {\n        key: \"onTrackerMouseOut\",\n        value: function onTrackerMouseOut(a) {\n          a = a.relatedTarget;\n          var d = this.chart.hoverSeries;\n          this.isDirectTouch = !1;\n          if (!(!d || !a || d.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + d.index) && this.inClass(a, \"highcharts-tracker\"))) d.onMouseOut();\n        }\n      }, {\n        key: \"inClass\",\n        value: function inClass(a, k) {\n          var d;\n          for (; a;) {\n            if (d = B(a, \"class\")) {\n              if (-1 !== d.indexOf(k)) return !0;\n              if (-1 !== d.indexOf(\"highcharts-container\")) return !1;\n            }\n            a = a.parentElement;\n          }\n        }\n      }, {\n        key: \"init\",\n        value: function init(a, k) {\n          this.options = k;\n          this.chart = a;\n          this.runChartClick = !(!k.chart.events || !k.chart.events.click);\n          this.pinchDown = [];\n          this.lastValidTouch = {};\n          this.setDOMEvents();\n          t(this, \"afterInit\");\n        }\n      }, {\n        key: \"normalize\",\n        value: function normalize(a, k) {\n          var d = a.touches,\n            e = d ? d.length ? d.item(0) : w(d.changedTouches, a.changedTouches)[0] : a;\n          k || (k = this.getChartPosition());\n          d = e.pageX - k.left;\n          e = e.pageY - k.top;\n          d /= k.scaleX;\n          e /= k.scaleY;\n          return l(a, {\n            chartX: Math.round(d),\n            chartY: Math.round(e)\n          });\n        }\n      }, {\n        key: \"onContainerClick\",\n        value: function onContainerClick(a) {\n          var d = this.chart,\n            e = d.hoverPoint;\n          a = this.normalize(a);\n          var g = d.plotLeft,\n            h = d.plotTop;\n          d.cancelClick || (e && this.inClass(a.target, \"highcharts-tracker\") ? (t(e.series, \"click\", l(a, {\n            point: e\n          })), d.hoverPoint && e.firePointEvent(\"click\", a)) : (l(a, this.getCoordinates(a)), d.isInsidePlot(a.chartX - g, a.chartY - h, {\n            visiblePlotOnly: !0\n          }) && t(d, \"click\", a)));\n        }\n      }, {\n        key: \"onContainerMouseDown\",\n        value: function onContainerMouseDown(a) {\n          var d = 1 === ((a.buttons || a.button) & 1);\n          a = this.normalize(a);\n          if (y.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);\n          if (\"undefined\" === typeof a.button || d) this.zoomOption(a), d && a.preventDefault && a.preventDefault(), this.dragStart(a);\n        }\n      }, {\n        key: \"onContainerMouseLeave\",\n        value: function onContainerMouseLeave(a) {\n          var d = C[w(F.hoverChartIndex, -1)];\n          a = this.normalize(a);\n          d && a.relatedTarget && !this.inClass(a.relatedTarget, \"highcharts-tooltip\") && (d.pointer.reset(), d.pointer.chartPosition = void 0);\n        }\n      }, {\n        key: \"onContainerMouseEnter\",\n        value: function onContainerMouseEnter(a) {\n          delete this.chartPosition;\n        }\n      }, {\n        key: \"onContainerMouseMove\",\n        value: function onContainerMouseMove(a) {\n          var d = this.chart,\n            e = d.tooltip;\n          a = this.normalize(a);\n          this.setHoverChartIndex();\n          (\"mousedown\" === d.mouseIsDown || this.touchSelect(a)) && this.drag(a);\n          d.openMenu || !this.inClass(a.target, \"highcharts-tracker\") && !d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop, {\n            visiblePlotOnly: !0\n          }) || e && e.shouldStickOnContact(a) || (this.inClass(a.target, \"highcharts-no-tooltip\") ? this.reset(!1, 0) : this.runPointActions(a));\n        }\n      }, {\n        key: \"onDocumentTouchEnd\",\n        value: function onDocumentTouchEnd(a) {\n          var d = C[w(F.hoverChartIndex, -1)];\n          d && d.pointer.drop(a);\n        }\n      }, {\n        key: \"onContainerTouchMove\",\n        value: function onContainerTouchMove(a) {\n          if (this.touchSelect(a)) this.onContainerMouseMove(a);else this.touch(a);\n        }\n      }, {\n        key: \"onContainerTouchStart\",\n        value: function onContainerTouchStart(a) {\n          if (this.touchSelect(a)) this.onContainerMouseDown(a);else this.zoomOption(a), this.touch(a, !0);\n        }\n      }, {\n        key: \"onDocumentMouseMove\",\n        value: function onDocumentMouseMove(a) {\n          var d = this.chart,\n            e = d.tooltip,\n            g = this.chartPosition;\n          a = this.normalize(a, g);\n          !g || d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop, {\n            visiblePlotOnly: !0\n          }) || e && e.shouldStickOnContact(a) || this.inClass(a.target, \"highcharts-tracker\") || this.reset();\n        }\n      }, {\n        key: \"onDocumentMouseUp\",\n        value: function onDocumentMouseUp(a) {\n          var d = C[w(F.hoverChartIndex, -1)];\n          d && d.pointer.drop(a);\n        }\n      }, {\n        key: \"pinch\",\n        value: function pinch(a) {\n          var d = this,\n            e = d.chart,\n            g = d.pinchDown,\n            h = a.touches || [],\n            b = h.length,\n            f = d.lastValidTouch,\n            c = d.hasZoom,\n            n = {},\n            m = 1 === b && (d.inClass(a.target, \"highcharts-tracker\") && e.runTrackerClick || d.runChartClick),\n            p = {};\n          var v = d.chart.tooltip;\n          v = 1 === b && w(v && v.options.followTouchMove, !0);\n          var u = d.selectionMarker;\n          1 < b ? d.initiated = !0 : v && (d.initiated = !1);\n          c && d.initiated && !m && !1 !== a.cancelable && a.preventDefault();\n          [].map.call(h, function (b) {\n            return d.normalize(b);\n          });\n          \"touchstart\" === a.type ? ([].forEach.call(h, function (b, a) {\n            g[a] = {\n              chartX: b.chartX,\n              chartY: b.chartY\n            };\n          }), f.x = [g[0].chartX, g[1] && g[1].chartX], f.y = [g[0].chartY, g[1] && g[1].chartY], e.axes.forEach(function (b) {\n            if (b.zoomEnabled) {\n              var _a11 = e.bounds[b.horiz ? \"h\" : \"v\"],\n                _c11 = b.minPixelPadding,\n                _f9 = b.toPixels(Math.min(w(b.options.min, b.dataMin), b.dataMin)),\n                _d11 = b.toPixels(Math.max(w(b.options.max, b.dataMax), b.dataMax)),\n                _n5 = Math.max(_f9, _d11);\n              _a11.min = Math.min(b.pos, Math.min(_f9, _d11) - _c11);\n              _a11.max = Math.max(b.pos + b.len, _n5 + _c11);\n            }\n          }), d.res = !0) : v ? this.runPointActions(d.normalize(a)) : g.length && (t(e, \"touchpan\", {\n            originalEvent: a\n          }, function () {\n            u || (d.selectionMarker = u = l({\n              destroy: z,\n              touch: !0\n            }, e.plotBox));\n            d.pinchTranslate(g, h, n, u, p, f);\n            d.hasPinched = c;\n            d.scaleGroups(n, p);\n          }), d.res && (d.res = !1, this.reset(!1, 0)));\n        }\n      }, {\n        key: \"pinchTranslate\",\n        value: function pinchTranslate(a, e, g, h, l, b) {\n          this.zoomHor && this.pinchTranslateDirection(!0, a, e, g, h, l, b);\n          this.zoomVert && this.pinchTranslateDirection(!1, a, e, g, h, l, b);\n        }\n      }, {\n        key: \"pinchTranslateDirection\",\n        value: function pinchTranslateDirection(a, e, g, h, l, b, f, c) {\n          var d = this.chart,\n            k = a ? \"x\" : \"y\",\n            q = a ? \"X\" : \"Y\",\n            m = \"chart\" + q,\n            r = a ? \"width\" : \"height\",\n            p = d[\"plot\" + (a ? \"Left\" : \"Top\")],\n            t = d.inverted,\n            w = d.bounds[a ? \"h\" : \"v\"],\n            v = 1 === e.length,\n            u = e[0][m],\n            x = !v && e[1][m];\n          e = function e() {\n            \"number\" === typeof N && 20 < Math.abs(u - x) && (F = c || Math.abs(J - N) / Math.abs(u - x));\n            E = (p - J) / F + u;\n            G = d[\"plot\" + (a ? \"Width\" : \"Height\")] / F;\n          };\n          var G,\n            E,\n            F = c || 1,\n            J = g[0][m],\n            N = !v && g[1][m],\n            O;\n          e();\n          g = E;\n          g < w.min ? (g = w.min, O = !0) : g + G > w.max && (g = w.max - G, O = !0);\n          O ? (J -= .8 * (J - f[k][0]), \"number\" === typeof N && (N -= .8 * (N - f[k][1])), e()) : f[k] = [J, N];\n          t || (b[k] = E - p, b[r] = G);\n          b = t ? 1 / F : F;\n          l[r] = G;\n          l[k] = g;\n          h[t ? a ? \"scaleY\" : \"scaleX\" : \"scale\" + q] = F;\n          h[\"translate\" + q] = b * p + (J - b * u);\n        }\n      }, {\n        key: \"reset\",\n        value: function reset(a, e) {\n          var d = this.chart,\n            k = d.hoverSeries,\n            g = d.hoverPoint,\n            b = d.hoverPoints,\n            f = d.tooltip,\n            c = f && f.shared ? b : g;\n          a && c && E(c).forEach(function (b) {\n            b.series.isCartesian && \"undefined\" === typeof b.plotX && (a = !1);\n          });\n          if (a) f && c && E(c).length && (f.refresh(c), f.shared && b ? b.forEach(function (b) {\n            b.setState(b.state, !0);\n            b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));\n          }) : g && (g.setState(g.state, !0), d.axes.forEach(function (b) {\n            b.crosshair && g.series[b.coll] === b && b.drawCrosshair(null, g);\n          })));else {\n            if (g) g.onMouseOut();\n            b && b.forEach(function (b) {\n              b.setState();\n            });\n            if (k) k.onMouseOut();\n            f && f.hide(e);\n            this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n            d.axes.forEach(function (b) {\n              b.hideCrosshair();\n            });\n            this.hoverX = d.hoverPoints = d.hoverPoint = null;\n          }\n        }\n      }, {\n        key: \"runPointActions\",\n        value: function runPointActions(a, e, g) {\n          var d = this.chart,\n            k = d.tooltip && d.tooltip.options.enabled ? d.tooltip : void 0,\n            b = k ? k.shared : !1;\n          var f = e || d.hoverPoint,\n            c = f && f.series || d.hoverSeries;\n          e = this.getHoverData(f, c, d.series, (!a || \"touchmove\" !== a.type) && (!!e || c && c.directTouch && this.isDirectTouch), b, a);\n          f = e.hoverPoint;\n          c = e.hoverSeries;\n          var n = e.hoverPoints;\n          e = c && c.tooltipOptions.followPointer && !c.tooltipOptions.split;\n          var h = b && c && !c.noSharedTooltip;\n          if (f && (g || f !== d.hoverPoint || k && k.isHidden)) {\n            (d.hoverPoints || []).forEach(function (b) {\n              -1 === n.indexOf(b) && b.setState();\n            });\n            if (d.hoverSeries !== c) c.onMouseOver();\n            this.applyInactiveState(n);\n            (n || []).forEach(function (b) {\n              b.setState(\"hover\");\n            });\n            d.hoverPoint && d.hoverPoint.firePointEvent(\"mouseOut\");\n            if (!f.series) return;\n            d.hoverPoints = n;\n            d.hoverPoint = f;\n            f.firePointEvent(\"mouseOver\", void 0, function () {\n              k && f && k.refresh(h ? n : f, a);\n            });\n          } else e && k && !k.isHidden && (g = k.getAnchor([{}], a), d.isInsidePlot(g[0], g[1], {\n            visiblePlotOnly: !0\n          }) && k.updatePosition({\n            plotX: g[0],\n            plotY: g[1]\n          }));\n          this.unDocMouseMove || (this.unDocMouseMove = H(d.container.ownerDocument, \"mousemove\", function (b) {\n            var a = C[F.hoverChartIndex];\n            if (a) a.pointer.onDocumentMouseMove(b);\n          }), this.eventsToUnbind.push(this.unDocMouseMove));\n          d.axes.forEach(function (b) {\n            var c = w((b.crosshair || {}).snap, !0);\n            var f;\n            c && ((f = d.hoverPoint) && f.series[b.coll] === b || (f = p(n, function (a) {\n              return a.series && a.series[b.coll] === b;\n            })));\n            f || !c ? b.drawCrosshair(a, f) : b.hideCrosshair();\n          });\n        }\n      }, {\n        key: \"scaleGroups\",\n        value: function scaleGroups(a, e) {\n          var d = this.chart;\n          d.series.forEach(function (k) {\n            var g = a || k.getPlotBox();\n            k.group && (k.xAxis && k.xAxis.zoomEnabled || d.mapView) && (k.group.attr(g), k.markerGroup && (k.markerGroup.attr(g), k.markerGroup.clip(e ? d.clipRect : null)), k.dataLabelsGroup && k.dataLabelsGroup.attr(g));\n          });\n          d.clipRect.attr(e || d.clipBox);\n        }\n      }, {\n        key: \"setDOMEvents\",\n        value: function setDOMEvents() {\n          var _this9 = this;\n          var a = this.chart.container,\n            e = a.ownerDocument;\n          a.onmousedown = this.onContainerMouseDown.bind(this);\n          a.onmousemove = this.onContainerMouseMove.bind(this);\n          a.onclick = this.onContainerClick.bind(this);\n          this.eventsToUnbind.push(H(a, \"mouseenter\", this.onContainerMouseEnter.bind(this)));\n          this.eventsToUnbind.push(H(a, \"mouseleave\", this.onContainerMouseLeave.bind(this)));\n          F.unbindDocumentMouseUp || (F.unbindDocumentMouseUp = H(e, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n          var g = this.chart.renderTo.parentElement;\n          for (; g && \"BODY\" !== g.tagName;) this.eventsToUnbind.push(H(g, \"scroll\", function () {\n            delete _this9.chartPosition;\n          })), g = g.parentElement;\n          y.hasTouch && (this.eventsToUnbind.push(H(a, \"touchstart\", this.onContainerTouchStart.bind(this), {\n            passive: !1\n          })), this.eventsToUnbind.push(H(a, \"touchmove\", this.onContainerTouchMove.bind(this), {\n            passive: !1\n          })), F.unbindDocumentTouchEnd || (F.unbindDocumentTouchEnd = H(e, \"touchend\", this.onDocumentTouchEnd.bind(this), {\n            passive: !1\n          })));\n        }\n      }, {\n        key: \"setHoverChartIndex\",\n        value: function setHoverChartIndex() {\n          var a = this.chart,\n            e = y.charts[w(F.hoverChartIndex, -1)];\n          if (e && e !== a) e.pointer.onContainerMouseLeave({\n            relatedTarget: a.container\n          });\n          e && e.mouseIsDown || (F.hoverChartIndex = a.index);\n        }\n      }, {\n        key: \"touch\",\n        value: function touch(a, e) {\n          var d = this.chart;\n          var g, k;\n          this.setHoverChartIndex();\n          1 === a.touches.length ? (a = this.normalize(a), (k = d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop, {\n            visiblePlotOnly: !0\n          })) && !d.openMenu ? (e && this.runPointActions(a), \"touchmove\" === a.type && (e = this.pinchDown, g = e[0] ? 4 <= Math.sqrt(Math.pow(e[0].chartX - a.chartX, 2) + Math.pow(e[0].chartY - a.chartY, 2)) : !1), w(g, !0) && this.pinch(a)) : e && this.reset()) : 2 === a.touches.length && this.pinch(a);\n        }\n      }, {\n        key: \"touchSelect\",\n        value: function touchSelect(a) {\n          return !(!this.chart.zooming.singleTouch || !a.touches || 1 !== a.touches.length);\n        }\n      }, {\n        key: \"zoomOption\",\n        value: function zoomOption(a) {\n          var d = this.chart,\n            e = d.inverted;\n          var g = d.zooming.type || \"\";\n          /touch/.test(a.type) && (g = w(d.zooming.pinchType, g));\n          this.zoomX = a = /x/.test(g);\n          this.zoomY = g = /y/.test(g);\n          this.zoomHor = a && !e || g && e;\n          this.zoomVert = g && !e || a && e;\n          this.hasZoom = a || g;\n        }\n      }]);\n      return F;\n    }();\n    (function (a) {\n      var d = [],\n        e = [];\n      a.compose = function (d) {\n        I.pushUnique(e, d) && H(d, \"beforeRender\", function () {\n          this.pointer = new a(this, this.options);\n        });\n      };\n      a.dissolve = function () {\n        for (var _a12 = 0, _e4 = d.length; _a12 < _e4; ++_a12) d[_a12]();\n        d.length = 0;\n      };\n    })(F || (F = {}));\n    \"\";\n    return F;\n  });\n  M(a, \"Core/Legend/Legend.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Templating.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z) {\n    var x = a.animObject,\n      B = a.setAnimation,\n      u = y.format,\n      v = I.marginNames,\n      l = C.distribute,\n      p = z.addEvent,\n      t = z.createElement,\n      m = z.css,\n      h = z.defined,\n      g = z.discardElement,\n      e = z.find,\n      w = z.fireEvent,\n      E = z.isNumber,\n      F = z.merge,\n      d = z.pick,\n      k = z.relativeLength,\n      r = z.stableSort,\n      q = z.syncTimeout;\n    var G = /*#__PURE__*/function () {\n      function G(b, a) {\n        _classCallCheck(this, G);\n        this.allItems = [];\n        this.contentGroup = this.box = void 0;\n        this.display = !1;\n        this.group = void 0;\n        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;\n        this.options = void 0;\n        this.padding = 0;\n        this.pages = [];\n        this.proximate = !1;\n        this.scrollGroup = void 0;\n        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;\n        this.chart = b;\n        this.init(b, a);\n      }\n      _createClass(G, [{\n        key: \"init\",\n        value: function init(b, a) {\n          var _this10 = this;\n          this.chart = b;\n          this.setOptions(a);\n          a.enabled && (this.render(), p(this.chart, \"endResize\", function () {\n            this.legend.positionCheckboxes();\n          }), p(this.chart, \"render\", function () {\n            _this10.proximate && (_this10.proximatePositions(), _this10.positionItems());\n          }));\n        }\n      }, {\n        key: \"setOptions\",\n        value: function setOptions(b) {\n          var a = d(b.padding, 8);\n          this.options = b;\n          this.chart.styledMode || (this.itemStyle = b.itemStyle, this.itemHiddenStyle = F(this.itemStyle, b.itemHiddenStyle));\n          this.itemMarginTop = b.itemMarginTop;\n          this.itemMarginBottom = b.itemMarginBottom;\n          this.padding = a;\n          this.initialItemY = a - 5;\n          this.symbolWidth = d(b.symbolWidth, 16);\n          this.pages = [];\n          this.proximate = \"proximate\" === b.layout && !this.chart.inverted;\n          this.baseline = void 0;\n        }\n      }, {\n        key: \"update\",\n        value: function update(b, a) {\n          var c = this.chart;\n          this.setOptions(F(!0, this.options, b));\n          this.destroy();\n          c.isDirtyLegend = c.isDirtyBox = !0;\n          d(a, !0) && c.redraw();\n          w(this, \"afterUpdate\");\n        }\n      }, {\n        key: \"colorizeItem\",\n        value: function colorizeItem(b, a) {\n          var _ref = b.legendItem || {},\n            c = _ref.group,\n            f = _ref.label,\n            d = _ref.line,\n            e = _ref.symbol;\n          if (c) c[a ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n          if (!this.chart.styledMode) {\n            var _c12 = this.itemHiddenStyle,\n              _g6 = _c12.color,\n              _k7 = a ? b.color || _g6 : _g6,\n              n = b.options && b.options.marker;\n            var _h8 = {\n              fill: _k7\n            };\n            null === f || void 0 === f ? void 0 : f.css(F(a ? this.itemStyle : _c12));\n            null === d || void 0 === d ? void 0 : d.attr({\n              stroke: _k7\n            });\n            e && (n && e.isMarker && (_h8 = b.pointAttribs(), a || (_h8.stroke = _h8.fill = _g6)), e.attr(_h8));\n          }\n          w(this, \"afterColorizeItem\", {\n            item: b,\n            visible: a\n          });\n        }\n      }, {\n        key: \"positionItems\",\n        value: function positionItems() {\n          this.allItems.forEach(this.positionItem, this);\n          this.chart.isResizing || this.positionCheckboxes();\n        }\n      }, {\n        key: \"positionItem\",\n        value: function positionItem(b) {\n          var _this11 = this;\n          var _ref2 = b.legendItem || {},\n            a = _ref2.group,\n            _ref2$x = _ref2.x,\n            c = _ref2$x === void 0 ? 0 : _ref2$x,\n            _ref2$y = _ref2.y,\n            d = _ref2$y === void 0 ? 0 : _ref2$y;\n          var e = this.options,\n            g = e.symbolPadding;\n          var k = !e.rtl;\n          e = b.checkbox;\n          a && a.element && (g = {\n            translateX: k ? c : this.legendWidth - c - 2 * g - 4,\n            translateY: d\n          }, a[h(a.translateY) ? \"animate\" : \"attr\"](g, void 0, function () {\n            w(_this11, \"afterPositionItem\", {\n              item: b\n            });\n          }));\n          e && (e.x = c, e.y = d);\n        }\n      }, {\n        key: \"destroyItem\",\n        value: function destroyItem(b) {\n          var a = b.checkbox,\n            c = b.legendItem || {};\n          for (var _i = 0, _arr = [\"group\", \"label\", \"line\", \"symbol\"]; _i < _arr.length; _i++) {\n            var _b25 = _arr[_i];\n            c[_b25] && (c[_b25] = c[_b25].destroy());\n          }\n          a && g(a);\n          b.legendItem = void 0;\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var _iterator2 = _createForOfIteratorHelper(this.getAllItems()),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var b = _step2.value;\n              this.destroyItem(b);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          var _iterator3 = _createForOfIteratorHelper(\"clipRect up down pager nav box title group\".split(\" \")),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _b26 = _step3.value;\n              this[_b26] && (this[_b26] = this[_b26].destroy());\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          this.display = null;\n        }\n      }, {\n        key: \"positionCheckboxes\",\n        value: function positionCheckboxes() {\n          var b = this.group && this.group.alignAttr,\n            a = this.clipHeight || this.legendHeight,\n            c = this.titleHeight;\n          var d;\n          b && (d = b.translateY, this.allItems.forEach(function (f) {\n            var e = f.checkbox;\n            var g;\n            e && (g = d + c + e.y + (this.scrollOffset || 0) + 3, m(e, {\n              left: b.translateX + f.checkboxOffset + e.x - 20 + \"px\",\n              top: g + \"px\",\n              display: this.proximate || g > d - 6 && g < d + a - 6 ? \"\" : \"none\"\n            }));\n          }, this));\n        }\n      }, {\n        key: \"renderTitle\",\n        value: function renderTitle() {\n          var b = this.options;\n          var a = this.padding,\n            c = b.title;\n          var d = 0;\n          c.text && (this.title || (this.title = this.chart.renderer.label(c.text, a - 3, a - 4, void 0, void 0, void 0, b.useHTML, void 0, \"legend-title\").attr({\n            zIndex: 1\n          }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)), c.width || this.title.css({\n            width: this.maxLegendWidth + \"px\"\n          }), b = this.title.getBBox(), d = b.height, this.offsetWidth = b.width, this.contentGroup.attr({\n            translateY: d\n          }));\n          this.titleHeight = d;\n        }\n      }, {\n        key: \"setText\",\n        value: function setText(b) {\n          var a = this.options;\n          b.legendItem.label.attr({\n            text: a.labelFormat ? u(a.labelFormat, b, this.chart) : a.labelFormatter.call(b)\n          });\n        }\n      }, {\n        key: \"renderItem\",\n        value: function renderItem(b) {\n          var a = b.legendItem = b.legendItem || {};\n          var c = this.chart,\n            e = c.renderer;\n          var g = this.options,\n            k = this.symbolWidth,\n            h = g.symbolPadding || 0,\n            l = this.itemStyle,\n            m = this.itemHiddenStyle,\n            q = \"horizontal\" === g.layout ? d(g.itemDistance, 20) : 0,\n            r = !g.rtl,\n            p = !b.series,\n            t = !p && b.series.drawLegendSymbol ? b.series : b;\n          var w = t.options;\n          var v = this.createCheckboxForItem && w && w.showCheckbox,\n            u = g.useHTML,\n            x = b.options.className;\n          var J = a.label;\n          w = k + h + q + (v ? 20 : 0);\n          J || (a.group = e.g(\"legend-item\").addClass(\"highcharts-\" + t.type + \"-series highcharts-color-\" + b.colorIndex + (x ? \" \" + x : \"\") + (p ? \" highcharts-series-\" + b.index : \"\")).attr({\n            zIndex: 1\n          }).add(this.scrollGroup), a.label = J = e.text(\"\", r ? k + h : -h, this.baseline || 0, u), c.styledMode || J.css(F(b.visible ? l : m)), J.attr({\n            align: r ? \"left\" : \"right\",\n            zIndex: 2\n          }).add(a.group), this.baseline || (this.fontMetrics = e.fontMetrics(J), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, J.attr(\"y\", this.baseline), this.symbolHeight = d(g.symbolHeight, this.fontMetrics.f), g.squareSymbol && (this.symbolWidth = d(g.symbolWidth, Math.max(this.symbolHeight, 16)), w = this.symbolWidth + h + q + (v ? 20 : 0), r && J.attr(\"x\", this.symbolWidth + h))), t.drawLegendSymbol(this, b), this.setItemEvents && this.setItemEvents(b, J, u));\n          v && !b.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(b);\n          this.colorizeItem(b, b.visible);\n          !c.styledMode && l.width || J.css({\n            width: (g.itemWidth || this.widthOption || c.spacingBox.width) - w + \"px\"\n          });\n          this.setText(b);\n          c = J.getBBox();\n          e = this.fontMetrics && this.fontMetrics.h || 0;\n          b.itemWidth = b.checkboxOffset = g.itemWidth || a.labelWidth || c.width + w;\n          this.maxItemWidth = Math.max(this.maxItemWidth, b.itemWidth);\n          this.totalItemWidth += b.itemWidth;\n          this.itemHeight = b.itemHeight = Math.round(a.labelHeight || (c.height > 1.5 * e ? c.height : e));\n        }\n      }, {\n        key: \"layoutItem\",\n        value: function layoutItem(b) {\n          var a = this.options;\n          var c = this.padding,\n            e = \"horizontal\" === a.layout,\n            g = b.itemHeight,\n            k = this.itemMarginBottom,\n            h = this.itemMarginTop,\n            l = e ? d(a.itemDistance, 20) : 0,\n            m = this.maxLegendWidth;\n          a = a.alignColumns && this.totalItemWidth > m ? this.maxItemWidth : b.itemWidth;\n          var q = b.legendItem || {};\n          e && this.itemX - c + a > m && (this.itemX = c, this.lastLineHeight && (this.itemY += h + this.lastLineHeight + k), this.lastLineHeight = 0);\n          this.lastItemY = h + this.itemY + k;\n          this.lastLineHeight = Math.max(g, this.lastLineHeight);\n          q.x = this.itemX;\n          q.y = this.itemY;\n          e ? this.itemX += a : (this.itemY += h + g + k, this.lastLineHeight = g);\n          this.offsetWidth = this.widthOption || Math.max((e ? this.itemX - c - (b.checkbox ? 0 : l) : a) + c, this.offsetWidth);\n        }\n      }, {\n        key: \"getAllItems\",\n        value: function getAllItems() {\n          var b = [];\n          this.chart.series.forEach(function (a) {\n            var c = a && a.options;\n            a && d(c.showInLegend, h(c.linkedTo) ? !1 : void 0, !0) && (b = b.concat((a.legendItem || {}).labels || (\"point\" === c.legendType ? a.data : a)));\n          });\n          w(this, \"afterGetAllItems\", {\n            allItems: b\n          });\n          return b;\n        }\n      }, {\n        key: \"getAlignment\",\n        value: function getAlignment() {\n          var b = this.options;\n          return this.proximate ? b.align.charAt(0) + \"tv\" : b.floating ? \"\" : b.align.charAt(0) + b.verticalAlign.charAt(0) + b.layout.charAt(0);\n        }\n      }, {\n        key: \"adjustMargins\",\n        value: function adjustMargins(b, a) {\n          var c = this.chart,\n            f = this.options,\n            e = this.getAlignment();\n          e && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (g, k) {\n            g.test(e) && !h(b[k]) && (c[v[k]] = Math.max(c[v[k]], c.legend[(k + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][k] * f[k % 2 ? \"x\" : \"y\"] + d(f.margin, 12) + a[k] + (c.titleOffset[k] || 0)));\n          });\n        }\n      }, {\n        key: \"proximatePositions\",\n        value: function proximatePositions() {\n          var b = this.chart,\n            a = [],\n            c = \"left\" === this.options.align;\n          this.allItems.forEach(function (d) {\n            var f;\n            var g = c;\n            var k;\n            d.yAxis && (d.xAxis.options.reversed && (g = !g), d.points && (f = e(g ? d.points : d.points.slice(0).reverse(), function (b) {\n              return E(b.plotY);\n            })), g = this.itemMarginTop + d.legendItem.label.getBBox().height + this.itemMarginBottom, k = d.yAxis.top - b.plotTop, d.visible ? (f = f ? f.plotY : d.yAxis.height, f += k - .3 * g) : f = k + d.yAxis.height, a.push({\n              target: f,\n              size: g,\n              item: d\n            }));\n          }, this);\n          var d;\n          var _iterator4 = _createForOfIteratorHelper(l(a, b.plotHeight)),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _c13 = _step4.value;\n              d = _c13.item.legendItem || {}, E(_c13.pos) && (d.y = b.plotTop - b.spacing[0] + _c13.pos);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var b = this.chart,\n            a = b.renderer,\n            c = this.options,\n            d = this.padding;\n          var e = this.getAllItems();\n          var g,\n            h = this.group,\n            l = this.box;\n          this.itemX = d;\n          this.itemY = this.initialItemY;\n          this.lastItemY = this.offsetWidth = 0;\n          this.widthOption = k(c.width, b.spacingBox.width - d);\n          var m = b.spacingBox.width - 2 * d - c.x;\n          -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (m /= 2);\n          this.maxLegendWidth = this.widthOption || m;\n          h || (this.group = h = a.g(\"legend\").addClass(c.className || \"\").attr({\n            zIndex: 7\n          }).add(), this.contentGroup = a.g().attr({\n            zIndex: 1\n          }).add(h), this.scrollGroup = a.g().add(this.contentGroup));\n          this.renderTitle();\n          r(e, function (b, a) {\n            return (b.options && b.options.legendIndex || 0) - (a.options && a.options.legendIndex || 0);\n          });\n          c.reversed && e.reverse();\n          this.allItems = e;\n          this.display = m = !!e.length;\n          this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n          e.forEach(this.renderItem, this);\n          e.forEach(this.layoutItem, this);\n          e = (this.widthOption || this.offsetWidth) + d;\n          g = this.lastItemY + this.lastLineHeight + this.titleHeight;\n          g = this.handleOverflow(g);\n          g += d;\n          l || (this.box = l = a.rect().addClass(\"highcharts-legend-box\").attr({\n            r: c.borderRadius\n          }).add(h));\n          b.styledMode || l.attr({\n            stroke: c.borderColor,\n            \"stroke-width\": c.borderWidth || 0,\n            fill: c.backgroundColor || \"none\"\n          }).shadow(c.shadow);\n          if (0 < e && 0 < g) l[l.placed ? \"animate\" : \"attr\"](l.crisp.call({}, {\n            x: 0,\n            y: 0,\n            width: e,\n            height: g\n          }, l.strokeWidth()));\n          h[m ? \"show\" : \"hide\"]();\n          b.styledMode && \"none\" === h.getStyle(\"display\") && (e = g = 0);\n          this.legendWidth = e;\n          this.legendHeight = g;\n          m && this.align();\n          this.proximate || this.positionItems();\n          w(this, \"afterRender\");\n        }\n      }, {\n        key: \"align\",\n        value: function align() {\n          var b = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.chart.spacingBox;\n          var a = this.chart,\n            c = this.options;\n          var d = b.y;\n          /(lth|ct|rth)/.test(this.getAlignment()) && 0 < a.titleOffset[0] ? d += a.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < a.titleOffset[2] && (d -= a.titleOffset[2]);\n          d !== b.y && (b = F(b, {\n            y: d\n          }));\n          a.hasRendered || (this.group.placed = !1);\n          this.group.align(F(c, {\n            width: this.legendWidth,\n            height: this.legendHeight,\n            verticalAlign: this.proximate ? \"top\" : c.verticalAlign\n          }), !0, b);\n        }\n      }, {\n        key: \"handleOverflow\",\n        value: function handleOverflow(b) {\n          var a = this,\n            c = this.chart,\n            e = c.renderer,\n            g = this.options;\n          var k = g.y;\n          var h = \"top\" === g.verticalAlign,\n            l = this.padding,\n            m = g.maxHeight,\n            q = g.navigation,\n            r = d(q.animation, !0),\n            p = q.arrowSize || 12,\n            t = this.pages,\n            w = this.allItems,\n            v = function v(b) {\n              \"number\" === typeof b ? E.attr({\n                height: b\n              }) : E && (a.clipRect = E.destroy(), a.contentGroup.clip());\n              a.contentGroup.div && (a.contentGroup.div.style.clip = b ? \"rect(\" + l + \"px,9999px,\" + (l + b) + \"px,0)\" : \"auto\");\n            },\n            u = function u(b) {\n              a[b] = e.circle(0, 0, 1.3 * p).translate(p / 2, p / 2).add(O);\n              c.styledMode || a[b].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n              return a[b];\n            };\n          var x, J, N;\n          k = c.spacingBox.height + (h ? -k : k) - l;\n          var O = this.nav,\n            E = this.clipRect;\n          \"horizontal\" !== g.layout || \"middle\" === g.verticalAlign || g.floating || (k /= 2);\n          m && (k = Math.min(k, m));\n          t.length = 0;\n          b && 0 < k && b > k && !1 !== q.enabled ? (this.clipHeight = x = Math.max(k - 20 - this.titleHeight - l, 0), this.currentPage = d(this.currentPage, 1), this.fullHeight = b, w.forEach(function (b, a) {\n            N = b.legendItem || {};\n            b = N.y || 0;\n            var c = Math.round(N.label.getBBox().height);\n            var d = t.length;\n            if (!d || b - t[d - 1] > x && (J || b) !== t[d - 1]) t.push(J || b), d++;\n            N.pageIx = d - 1;\n            J && ((w[a - 1].legendItem || {}).pageIx = d - 1);\n            a === w.length - 1 && b + c - t[d - 1] > x && b > t[d - 1] && (t.push(b), N.pageIx = d);\n            b !== J && (J = b);\n          }), E || (E = a.clipRect = e.clipRect(0, l - 2, 9999, 0), a.contentGroup.clip(E)), v(x), O || (this.nav = O = e.g().attr({\n            zIndex: 1\n          }).add(this.group), this.up = e.symbol(\"triangle\", 0, 0, p, p).add(O), u(\"upTracker\").on(\"click\", function () {\n            a.scroll(-1, r);\n          }), this.pager = e.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), !c.styledMode && q.style && this.pager.css(q.style), this.pager.add(O), this.down = e.symbol(\"triangle-down\", 0, 0, p, p).add(O), u(\"downTracker\").on(\"click\", function () {\n            a.scroll(1, r);\n          })), a.scroll(0), b = k) : O && (v(), this.nav = O.destroy(), this.scrollGroup.attr({\n            translateY: 1\n          }), this.clipHeight = 0);\n          return b;\n        }\n      }, {\n        key: \"scroll\",\n        value: function scroll(b, a) {\n          var _this12 = this;\n          var c = this.chart,\n            f = this.pages,\n            e = f.length,\n            g = this.clipHeight,\n            k = this.options.navigation,\n            h = this.pager,\n            l = this.padding;\n          var m = this.currentPage + b;\n          m > e && (m = e);\n          0 < m && (\"undefined\" !== typeof a && B(a, c), this.nav.attr({\n            translateX: l,\n            translateY: g + this.padding + 7 + this.titleHeight,\n            visibility: \"inherit\"\n          }), [this.up, this.upTracker].forEach(function (b) {\n            b.attr({\n              \"class\": 1 === m ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n            });\n          }), h.attr({\n            text: m + \"/\" + e\n          }), [this.down, this.downTracker].forEach(function (b) {\n            b.attr({\n              x: 18 + this.pager.getBBox().width,\n              \"class\": m === e ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n            });\n          }, this), c.styledMode || (this.up.attr({\n            fill: 1 === m ? k.inactiveColor : k.activeColor\n          }), this.upTracker.css({\n            cursor: 1 === m ? \"default\" : \"pointer\"\n          }), this.down.attr({\n            fill: m === e ? k.inactiveColor : k.activeColor\n          }), this.downTracker.css({\n            cursor: m === e ? \"default\" : \"pointer\"\n          })), this.scrollOffset = -f[m - 1] + this.initialItemY, this.scrollGroup.animate({\n            translateY: this.scrollOffset\n          }), this.currentPage = m, this.positionCheckboxes(), b = x(d(a, c.renderer.globalAnimation, !0)), q(function () {\n            w(_this12, \"afterScroll\", {\n              currentPage: m\n            });\n          }, b.duration));\n        }\n      }, {\n        key: \"setItemEvents\",\n        value: function setItemEvents(b, a, c) {\n          var d = this,\n            f = b.legendItem || {},\n            e = d.chart.renderer.boxWrapper,\n            g = b instanceof L,\n            k = \"highcharts-legend-\" + (g ? \"point\" : \"series\") + \"-active\",\n            h = d.chart.styledMode;\n          c = c ? [a, f.symbol] : [f.group];\n          var l = function l(a) {\n            d.allItems.forEach(function (c) {\n              b !== c && [c].concat(c.linkedSeries || []).forEach(function (b) {\n                b.setState(a, !g);\n              });\n            });\n          };\n          var _iterator5 = _createForOfIteratorHelper(c),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _f10 = _step5.value;\n              if (_f10) _f10.on(\"mouseover\", function () {\n                b.visible && l(\"inactive\");\n                b.setState(\"hover\");\n                b.visible && e.addClass(k);\n                h || a.css(d.options.itemHoverStyle);\n              }).on(\"mouseout\", function () {\n                d.chart.styledMode || a.css(F(b.visible ? d.itemStyle : d.itemHiddenStyle));\n                l(\"\");\n                e.removeClass(k);\n                b.setState();\n              }).on(\"click\", function (a) {\n                var c = function c() {\n                  b.setVisible && b.setVisible();\n                  l(b.visible ? \"inactive\" : \"\");\n                };\n                e.removeClass(k);\n                a = {\n                  browserEvent: a\n                };\n                b.firePointEvent ? b.firePointEvent(\"legendItemClick\", a, c) : w(b, \"legendItemClick\", a, c);\n              });\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      }, {\n        key: \"createCheckboxForItem\",\n        value: function createCheckboxForItem(b) {\n          b.checkbox = t(\"input\", {\n            type: \"checkbox\",\n            className: \"highcharts-legend-checkbox\",\n            checked: b.selected,\n            defaultChecked: b.selected\n          }, this.options.itemCheckboxStyle, this.chart.container);\n          p(b.checkbox, \"click\", function (a) {\n            w(b.series || b, \"checkboxClick\", {\n              checked: a.target.checked,\n              item: b\n            }, function () {\n              b.select();\n            });\n          });\n        }\n      }]);\n      return G;\n    }();\n    (function (b) {\n      var a = [];\n      b.compose = function (c) {\n        z.pushUnique(a, c) && p(c, \"beforeMargins\", function () {\n          this.legend = new b(this, this.options.legend);\n        });\n      };\n    })(G || (G = {}));\n    \"\";\n    return G;\n  });\n  M(a, \"Core/Legend/LegendSymbol.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    var x = a.extend,\n      I = a.merge,\n      L = a.pick;\n    var C;\n    (function (a) {\n      a.lineMarker = function (a, B) {\n        B = this.legendItem = this.legendItem || {};\n        var u = this.options;\n        var v = a.symbolWidth,\n          l = a.symbolHeight,\n          p = l / 2,\n          t = this.chart.renderer,\n          m = B.group;\n        a = a.baseline - Math.round(.3 * a.fontMetrics.b);\n        var h = {},\n          g = u.marker,\n          e = 0;\n        this.chart.styledMode || (h = {\n          \"stroke-width\": Math.min(u.lineWidth || 0, 24)\n        }, u.dashStyle ? h.dashstyle = u.dashStyle : \"square\" !== u.linecap && (h[\"stroke-linecap\"] = \"round\"));\n        B.line = t.path().addClass(\"highcharts-graph\").attr(h).add(m);\n        h[\"stroke-linecap\"] && (e = Math.min(B.line.strokeWidth(), v) / 2);\n        v && B.line.attr({\n          d: [[\"M\", e, a], [\"L\", v - e, a]]\n        });\n        g && !1 !== g.enabled && v && (u = Math.min(L(g.radius, p), p), 0 === this.symbol.indexOf(\"url\") && (g = I(g, {\n          width: l,\n          height: l\n        }), u = 0), B.symbol = B = t.symbol(this.symbol, v / 2 - u, a - u, 2 * u, 2 * u, x({\n          context: \"legend\"\n        }, g)).addClass(\"highcharts-point\").add(m), B.isMarker = !0);\n      };\n      a.rectangle = function (a, x) {\n        x = x.legendItem || {};\n        var u = a.symbolHeight,\n          v = a.options.squareSymbol;\n        x.symbol = this.chart.renderer.rect(v ? (a.symbolWidth - u) / 2 : 0, a.baseline - u + 1, v ? u : a.symbolWidth, u, L(a.options.symbolRadius, u / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(x.group);\n      };\n    })(C || (C = {}));\n    return C;\n  });\n  M(a, \"Core/Series/SeriesDefaults.js\", [], function () {\n    return {\n      lineWidth: 1,\n      allowPointSelect: !1,\n      crisp: !0,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      enableMouseTracking: !0,\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: \"#ffffff\",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 150\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        animation: {},\n        align: \"center\",\n        borderWidth: 0,\n        defer: !0,\n        formatter: function formatter() {\n          var a = this.series.chart.numberFormatter;\n          return \"number\" !== typeof this.y ? \"\" : a(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"0.7em\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 150\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 150\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    };\n  });\n  M(a, \"Core/Series/SeriesRegistry.js\", [a[\"Core/Globals.js\"], a[\"Core/Defaults.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L) {\n    var x = y.defaultOptions,\n      z = L.extendClass,\n      H = L.merge;\n    var B;\n    (function (u) {\n      function v(a, p) {\n        var l = x.plotOptions || {},\n          m = p.defaultOptions,\n          h = p.prototype;\n        h.type = a;\n        h.pointClass || (h.pointClass = I);\n        m && (l[a] = m);\n        u.seriesTypes[a] = p;\n      }\n      u.seriesTypes = a.seriesTypes;\n      u.registerSeriesType = v;\n      u.seriesType = function (a, p, t, m, h) {\n        var g = x.plotOptions || {};\n        p = p || \"\";\n        g[a] = H(g[p], t);\n        v(a, z(u.seriesTypes[p] || function () {}, m));\n        u.seriesTypes[a].prototype.type = a;\n        h && (u.seriesTypes[a].prototype.pointClass = z(I, h));\n        return u.seriesTypes[a];\n      };\n    })(B || (B = {}));\n    return B;\n  });\n  M(a, \"Core/Series/Series.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Defaults.js\"], a[\"Core/Foundation.js\"], a[\"Core/Globals.js\"], a[\"Core/Legend/LegendSymbol.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Series/SeriesDefaults.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z, H, B, u, v) {\n    var l = a.animObject,\n      p = a.setAnimation,\n      t = y.defaultOptions,\n      m = I.registerEventOptions,\n      h = L.hasTouch,\n      g = L.svg,\n      e = L.win,\n      w = B.seriesTypes,\n      x = v.arrayMax,\n      F = v.arrayMin,\n      d = v.clamp,\n      k = v.correctFloat,\n      r = v.defined,\n      q = v.diffObjects,\n      G = v.erase,\n      b = v.error,\n      f = v.extend,\n      c = v.find,\n      n = v.fireEvent,\n      P = v.getClosestDistance,\n      D = v.getNestedProperty,\n      K = v.insertItem,\n      X = v.isArray,\n      T = v.isNumber,\n      Z = v.isString,\n      V = v.merge,\n      Y = v.objectEach,\n      A = v.pick,\n      M = v.removeEvent,\n      ia = v.splat,\n      ba = v.syncTimeout;\n    var aa = /*#__PURE__*/function () {\n      function aa() {\n        _classCallCheck(this, aa);\n        this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;\n      }\n      _createClass(aa, [{\n        key: \"init\",\n        value: function init(b, a) {\n          n(this, \"init\", {\n            options: a\n          });\n          var c = this,\n            d = b.series;\n          this.eventsToUnbind = [];\n          c.chart = b;\n          c.options = c.setOptions(a);\n          a = c.options;\n          c.linkedSeries = [];\n          c.bindAxes();\n          f(c, {\n            name: a.name,\n            state: \"\",\n            visible: !1 !== a.visible,\n            selected: !0 === a.selected\n          });\n          m(this, a);\n          var e = a.events;\n          if (e && e.click || a.point && a.point.events && a.point.events.click || a.allowPointSelect) b.runTrackerClick = !0;\n          c.getColor();\n          c.getSymbol();\n          c.parallelArrays.forEach(function (b) {\n            c[b + \"Data\"] || (c[b + \"Data\"] = []);\n          });\n          c.isCartesian && (b.hasCartesianSeries = !0);\n          var g;\n          d.length && (g = d[d.length - 1]);\n          c._i = A(g && g._i, -1) + 1;\n          c.opacity = c.options.opacity;\n          b.orderItems(\"series\", K(this, d));\n          a.dataSorting && a.dataSorting.enabled ? c.setDataSortingOptions() : c.points || c.data || c.setData(a.data, !1);\n          n(this, \"afterInit\");\n        }\n      }, {\n        key: \"is\",\n        value: function is(b) {\n          return w[b] && this instanceof w[b];\n        }\n      }, {\n        key: \"bindAxes\",\n        value: function bindAxes() {\n          var a = this,\n            c = a.options,\n            d = a.chart;\n          var f;\n          n(this, \"bindAxes\", null, function () {\n            (a.axisTypes || []).forEach(function (e) {\n              d[e].forEach(function (b) {\n                f = b.options;\n                if (A(c[e], 0) === b.index || \"undefined\" !== typeof c[e] && c[e] === f.id) K(a, b.series), a[e] = b, b.isDirty = !0;\n              });\n              a[e] || a.optionalAxis === e || b(18, !0, d);\n            });\n          });\n          n(this, \"afterBindAxes\");\n        }\n      }, {\n        key: \"updateParallelArrays\",\n        value: function updateParallelArrays(b, a, c) {\n          var d = b.series,\n            f = T(a) ? function (c) {\n              var f = \"y\" === c && d.toYData ? d.toYData(b) : b[c];\n              d[c + \"Data\"][a] = f;\n            } : function (b) {\n              Array.prototype[a].apply(d[b + \"Data\"], c);\n            };\n          d.parallelArrays.forEach(f);\n        }\n      }, {\n        key: \"hasData\",\n        value: function hasData() {\n          return this.visible && \"undefined\" !== typeof this.dataMax && \"undefined\" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n        }\n      }, {\n        key: \"autoIncrement\",\n        value: function autoIncrement(b) {\n          var a = this.options;\n          var c = a.pointIntervalUnit,\n            d = a.relativeXValue,\n            f = this.chart.time;\n          var e = this.xIncrement,\n            g;\n          e = A(e, a.pointStart, 0);\n          this.pointInterval = g = A(this.pointInterval, a.pointInterval, 1);\n          d && T(b) && (g *= b);\n          c && (a = new f.Date(e), \"day\" === c ? f.set(\"Date\", a, f.get(\"Date\", a) + g) : \"month\" === c ? f.set(\"Month\", a, f.get(\"Month\", a) + g) : \"year\" === c && f.set(\"FullYear\", a, f.get(\"FullYear\", a) + g), g = a.getTime() - e);\n          if (d && T(b)) return e + g;\n          this.xIncrement = e + g;\n          return e;\n        }\n      }, {\n        key: \"setDataSortingOptions\",\n        value: function setDataSortingOptions() {\n          var b = this.options;\n          f(this, {\n            requireSorting: !1,\n            sorted: !1,\n            enabledDataSorting: !0,\n            allowDG: !1\n          });\n          r(b.pointRange) || (b.pointRange = 1);\n        }\n      }, {\n        key: \"setOptions\",\n        value: function setOptions(b) {\n          var a, c;\n          var d = this.chart;\n          var f = d.options.plotOptions,\n            e = d.userOptions || {};\n          var g = V(b);\n          b = d.styledMode;\n          var k = {\n            plotOptions: f,\n            userOptions: g\n          };\n          n(this, \"setOptions\", k);\n          var h = k.plotOptions[this.type];\n          e = e.plotOptions || {};\n          var l = e.series || {},\n            m = t.plotOptions[this.type] || {},\n            q = e[this.type] || {};\n          this.userOptions = k.userOptions;\n          f = V(h, f.series, q, g);\n          this.tooltipOptions = V(t.tooltip, null === (a = t.plotOptions.series) || void 0 === a ? void 0 : a.tooltip, null === m || void 0 === m ? void 0 : m.tooltip, d.userOptions.tooltip, null === (c = e.series) || void 0 === c ? void 0 : c.tooltip, q.tooltip, g.tooltip);\n          this.stickyTracking = A(g.stickyTracking, q.stickyTracking, l.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : f.stickyTracking);\n          null === h.marker && delete f.marker;\n          this.zoneAxis = f.zoneAxis;\n          c = this.zones = (f.zones || []).slice();\n          !f.negativeColor && !f.negativeFillColor || f.zones || (a = {\n            value: f[this.zoneAxis + \"Threshold\"] || f.threshold || 0,\n            className: \"highcharts-negative\"\n          }, b || (a.color = f.negativeColor, a.fillColor = f.negativeFillColor), c.push(a));\n          c.length && r(c[c.length - 1].value) && c.push(b ? {} : {\n            color: this.color,\n            fillColor: this.fillColor\n          });\n          n(this, \"afterSetOptions\", {\n            options: f\n          });\n          return f;\n        }\n      }, {\n        key: \"getName\",\n        value: function getName() {\n          return A(this.options.name, \"Series \" + (this.index + 1));\n        }\n      }, {\n        key: \"getCyclic\",\n        value: function getCyclic(b, a, c) {\n          var d = this.chart,\n            f = \"\".concat(b, \"Index\"),\n            e = \"\".concat(b, \"Counter\"),\n            g = (null === c || void 0 === c ? void 0 : c.length) || d.options.chart.colorCount;\n          if (!a) {\n            var k = A(\"color\" === b ? this.options.colorIndex : void 0, this[f]);\n            r(k) || (d.series.length || (d[e] = 0), k = d[e] % g, d[e] += 1);\n            c && (a = c[k]);\n          }\n          \"undefined\" !== typeof k && (this[f] = k);\n          this[b] = a;\n        }\n      }, {\n        key: \"getColor\",\n        value: function getColor() {\n          this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.color = \"#cccccc\" : this.getCyclic(\"color\", this.options.color || t.plotOptions[this.type].color, this.chart.options.colors);\n        }\n      }, {\n        key: \"getPointsCollection\",\n        value: function getPointsCollection() {\n          return (this.hasGroupedData ? this.points : this.data) || [];\n        }\n      }, {\n        key: \"getSymbol\",\n        value: function getSymbol() {\n          this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n        }\n      }, {\n        key: \"findPointIndex\",\n        value: function findPointIndex(b, a) {\n          var d = b.id,\n            f = b.x,\n            e = this.points;\n          var g = this.options.dataSorting,\n            k;\n          var h, n;\n          if (d) g = this.chart.get(d), g instanceof z && (k = g);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (k = function k(a) {\n            return !a.touched && a.index === b.index;\n          }, g && g.matchByName ? k = function k(a) {\n            return !a.touched && a.name === b.name;\n          } : this.options.relativeXValue && (k = function k(a) {\n            return !a.touched && a.options.x === b.x;\n          }), k = c(e, k), !k) return;\n          k && (n = k && k.index, \"undefined\" !== typeof n && (h = !0));\n          \"undefined\" === typeof n && T(f) && (n = this.xData.indexOf(f, a));\n          -1 !== n && \"undefined\" !== typeof n && this.cropped && (n = n >= this.cropStart ? n - this.cropStart : n);\n          !h && T(n) && e[n] && e[n].touched && (n = void 0);\n          return n;\n        }\n      }, {\n        key: \"updateData\",\n        value: function updateData(b, a) {\n          var c = this.options,\n            d = c.dataSorting,\n            f = this.points,\n            e = [],\n            g = this.requireSorting,\n            k = b.length === f.length;\n          var n,\n            h,\n            l,\n            m = !0;\n          this.xIncrement = null;\n          b.forEach(function (b, a) {\n            var h = r(b) && this.pointClass.prototype.optionsToObject.call({\n              series: this\n            }, b) || {};\n            var m = h.x;\n            if (h.id || T(m)) {\n              if (h = this.findPointIndex(h, l), -1 === h || \"undefined\" === typeof h ? e.push(b) : f[h] && b !== c.data[h] ? (f[h].update(b, !1, null, !1), f[h].touched = !0, g && (l = h + 1)) : f[h] && (f[h].touched = !0), !k || a !== h || d && d.enabled || this.hasDerivedData) n = !0;\n            } else e.push(b);\n          }, this);\n          if (n) for (b = f.length; b--;) (h = f[b]) && !h.touched && h.remove && h.remove(!1, a);else !k || d && d.enabled ? m = !1 : (b.forEach(function (b, a) {\n            b === f[a].y || f[a].destroyed || f[a].update(b, !1, null, !1);\n          }), e.length = 0);\n          f.forEach(function (b) {\n            b && (b.touched = !1);\n          });\n          if (!m) return !1;\n          e.forEach(function (b) {\n            this.addPoint(b, !1, null, null, !1);\n          }, this);\n          null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = x(this.xData), this.autoIncrement());\n          return !0;\n        }\n      }, {\n        key: \"setData\",\n        value: function setData(a) {\n          var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n          var d = arguments.length > 2 ? arguments[2] : undefined;\n          var f = arguments.length > 3 ? arguments[3] : undefined;\n          var e;\n          var g = this,\n            k = g.points,\n            h = k && k.length || 0,\n            n = g.options,\n            l = g.chart,\n            m = n.dataSorting,\n            q = g.xAxis,\n            p = n.turboThreshold,\n            r = this.xData,\n            t = this.yData;\n          var w = g.pointArrayMap;\n          w = w && w.length;\n          var J = n.keys;\n          var v,\n            u = 0,\n            O = 1,\n            x = null;\n          if (!l.options.chart.allowMutatingData) {\n            n.data && delete g.options.data;\n            g.userOptions.data && delete g.userOptions.data;\n            var N = V(!0, a);\n          }\n          a = N || a || [];\n          N = a.length;\n          m && m.enabled && (a = this.sortData(a));\n          l.options.chart.allowMutatingData && !1 !== f && N && h && !g.cropped && !g.hasGroupedData && g.visible && !g.boosted && (v = this.updateData(a, d));\n          if (!v) {\n            g.xIncrement = null;\n            g.colorCounter = 0;\n            this.parallelArrays.forEach(function (b) {\n              g[b + \"Data\"].length = 0;\n            });\n            if (p && N > p) {\n              if (x = g.getFirstValidPoint(a), T(x)) for (d = 0; d < N; d++) r[d] = this.autoIncrement(), t[d] = a[d];else if (X(x)) {\n                if (w) {\n                  if (x.length === w) for (d = 0; d < N; d++) r[d] = this.autoIncrement(), t[d] = a[d];else for (d = 0; d < N; d++) f = a[d], r[d] = f[0], t[d] = f.slice(1, w + 1);\n                } else if (J && (u = J.indexOf(\"x\"), O = J.indexOf(\"y\"), u = 0 <= u ? u : 0, O = 0 <= O ? O : 1), 1 === x.length && (O = 0), u === O) for (d = 0; d < N; d++) r[d] = this.autoIncrement(), t[d] = a[d][O];else for (d = 0; d < N; d++) f = a[d], r[d] = f[u], t[d] = f[O];\n              } else b(12, !1, l);\n            } else for (d = 0; d < N; d++) f = {\n              series: g\n            }, g.pointClass.prototype.applyOptions.apply(f, [a[d]]), g.updateParallelArrays(f, d);\n            t && Z(t[0]) && b(14, !0, l);\n            g.data = [];\n            g.options.data = g.userOptions.data = a;\n            for (d = h; d--;) null === (e = k[d]) || void 0 === e ? void 0 : e.destroy();\n            q && (q.minRange = q.userMinRange);\n            g.isDirty = l.isDirtyBox = !0;\n            g.isDirtyData = !!k;\n            d = !1;\n          }\n          \"point\" === n.legendType && (this.processData(), this.generatePoints());\n          c && l.redraw(d);\n        }\n      }, {\n        key: \"sortData\",\n        value: function sortData(b) {\n          var a = this,\n            c = a.options.dataSorting.sortKey || \"y\",\n            d = function d(b, a) {\n              return r(a) && b.pointClass.prototype.optionsToObject.call({\n                series: b\n              }, a) || {};\n            };\n          b.forEach(function (c, f) {\n            b[f] = d(a, c);\n            b[f].index = f;\n          }, this);\n          b.concat().sort(function (b, a) {\n            b = D(c, b);\n            a = D(c, a);\n            return a < b ? -1 : a > b ? 1 : 0;\n          }).forEach(function (b, a) {\n            b.x = a;\n          }, this);\n          a.linkedSeries && a.linkedSeries.forEach(function (a) {\n            var c = a.options,\n              f = c.data;\n            c.dataSorting && c.dataSorting.enabled || !f || (f.forEach(function (c, e) {\n              f[e] = d(a, c);\n              b[e] && (f[e].x = b[e].x, f[e].index = e);\n            }), a.setData(f, !1));\n          });\n          return b;\n        }\n      }, {\n        key: \"getProcessedData\",\n        value: function getProcessedData(a) {\n          var c = this;\n          var d = c.xAxis,\n            f = c.options;\n          var e = f.cropThreshold,\n            g = a || c.getExtremesFromAll || f.getExtremesFromAll,\n            k = null === d || void 0 === d ? void 0 : d.logarithmic,\n            h = c.isCartesian;\n          var n = 0;\n          var l;\n          a = c.xData;\n          f = c.yData;\n          var m = !1;\n          var q = a.length;\n          if (d) {\n            var r = d.getExtremes();\n            l = r.min;\n            r = r.max;\n            m = !(!d.categories || d.names.length);\n          }\n          if (h && c.sorted && !g && (!e || q > e || c.forceCrop)) if (a[q - 1] < l || a[0] > r) a = [], f = [];else if (c.yData && (a[0] < l || a[q - 1] > r)) {\n            var p = this.cropData(c.xData, c.yData, l, r);\n            a = p.xData;\n            f = p.yData;\n            n = p.start;\n            p = !0;\n          }\n          d = P([k ? a.map(k.log2lin) : a], function () {\n            return c.requireSorting && !m && b(15, !1, c.chart);\n          });\n          return {\n            xData: a,\n            yData: f,\n            cropped: p,\n            cropStart: n,\n            closestPointRange: d\n          };\n        }\n      }, {\n        key: \"processData\",\n        value: function processData(b) {\n          var a = this.xAxis;\n          if (this.isCartesian && !this.isDirty && !a.isDirty && !this.yAxis.isDirty && !b) return !1;\n          b = this.getProcessedData();\n          this.cropped = b.cropped;\n          this.cropStart = b.cropStart;\n          this.processedXData = b.xData;\n          this.processedYData = b.yData;\n          this.closestPointRange = this.basePointRange = b.closestPointRange;\n          n(this, \"afterProcessData\");\n        }\n      }, {\n        key: \"cropData\",\n        value: function cropData(b, a, c, d, f) {\n          var e = b.length;\n          var g,\n            k = 0,\n            h = e;\n          f = A(f, this.cropShoulder);\n          for (g = 0; g < e; g++) if (b[g] >= c) {\n            k = Math.max(0, g - f);\n            break;\n          }\n          for (c = g; c < e; c++) if (b[c] > d) {\n            h = c + f;\n            break;\n          }\n          return {\n            xData: b.slice(k, h),\n            yData: a.slice(k, h),\n            start: k,\n            end: h\n          };\n        }\n      }, {\n        key: \"generatePoints\",\n        value: function generatePoints() {\n          var b = this.options;\n          var a = this.processedData || b.data,\n            c = this.processedXData,\n            d = this.processedYData,\n            e = this.pointClass,\n            g = c.length,\n            k = this.cropStart || 0,\n            h = this.hasGroupedData,\n            l = b.keys,\n            m = [];\n          b = b.dataGrouping && b.dataGrouping.groupAll ? k : 0;\n          var q;\n          var r,\n            p,\n            t = this.data;\n          if (!t && !h) {\n            var w = [];\n            w.length = a.length;\n            t = this.data = w;\n          }\n          l && h && (this.options.keys = !1);\n          for (p = 0; p < g; p++) w = k + p, h ? (r = new e().init(this, [c[p]].concat(ia(d[p]))), r.dataGroup = this.groupMap[b + p], r.dataGroup.options && (r.options = r.dataGroup.options, f(r, r.dataGroup.options), delete r.dataLabels)) : (r = t[w]) || \"undefined\" === typeof a[w] || (t[w] = r = new e().init(this, a[w], c[p])), r && (r.index = h ? b + p : w, m[p] = r);\n          this.options.keys = l;\n          if (t && (g !== (q = t.length) || h)) for (p = 0; p < q; p++) p !== k || h || (p += g), t[p] && (t[p].destroyElements(), t[p].plotX = void 0);\n          this.data = t;\n          this.points = m;\n          n(this, \"afterGeneratePoints\");\n        }\n      }, {\n        key: \"getXExtremes\",\n        value: function getXExtremes(b) {\n          return {\n            min: F(b),\n            max: x(b)\n          };\n        }\n      }, {\n        key: \"getExtremes\",\n        value: function getExtremes(b, a) {\n          var c = this.xAxis;\n          var d = this.yAxis;\n          var f = this.processedXData || this.xData,\n            e = [],\n            g = this.requireSorting ? this.cropShoulder : 0;\n          d = d ? d.positiveValuesOnly : !1;\n          var k,\n            h = 0,\n            l = 0,\n            m = 0;\n          b = b || this.stackedYData || this.processedYData || [];\n          var q = b.length;\n          if (c) {\n            var p = c.getExtremes();\n            h = p.min;\n            l = p.max;\n          }\n          for (k = 0; k < q; k++) {\n            var r = f[k];\n            p = b[k];\n            var t = (T(p) || X(p)) && (p.length || 0 < p || !d);\n            r = a || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !c || (f[k + g] || r) >= h && (f[k - g] || r) <= l;\n            if (t && r) if (t = p.length) for (; t--;) T(p[t]) && (e[m++] = p[t]);else e[m++] = p;\n          }\n          b = {\n            activeYData: e,\n            dataMin: F(e),\n            dataMax: x(e)\n          };\n          n(this, \"afterGetExtremes\", {\n            dataExtremes: b\n          });\n          return b;\n        }\n      }, {\n        key: \"applyExtremes\",\n        value: function applyExtremes() {\n          var b = this.getExtremes();\n          this.dataMin = b.dataMin;\n          this.dataMax = b.dataMax;\n          return b;\n        }\n      }, {\n        key: \"getFirstValidPoint\",\n        value: function getFirstValidPoint(b) {\n          var a = b.length;\n          var c = 0,\n            d = null;\n          for (; null === d && c < a;) d = b[c], c++;\n          return d;\n        }\n      }, {\n        key: \"translate\",\n        value: function translate() {\n          var b;\n          this.processedXData || this.processData();\n          this.generatePoints();\n          var a = this.options;\n          var c = a.stacking,\n            f = this.xAxis,\n            e = f.categories,\n            g = this.enabledDataSorting,\n            h = this.yAxis,\n            l = this.points,\n            m = l.length,\n            q = this.pointPlacementToXValue(),\n            p = !!q,\n            t = a.threshold;\n          a = a.startFromThreshold ? t : 0;\n          var w,\n            v,\n            u,\n            x,\n            D = Number.MAX_VALUE;\n          for (w = 0; w < m; w++) {\n            var _n6 = l[w],\n              _m3 = _n6.x;\n            var J = void 0,\n              Q = void 0,\n              R = _n6.y,\n              O = _n6.low;\n            var E = c && (null === (b = h.stacking) || void 0 === b ? void 0 : b.stacks[(this.negStacks && R < (a ? 0 : t) ? \"-\" : \"\") + this.stackKey]);\n            v = f.translate(_m3, !1, !1, !1, !0, q);\n            _n6.plotX = T(v) ? k(d(v, -1E5, 1E5)) : void 0;\n            c && this.visible && E && E[_m3] && (x = this.getStackIndicator(x, _m3, this.index), !_n6.isNull && x.key && (J = E[_m3], Q = J.points[x.key]), J && X(Q) && (O = Q[0], R = Q[1], O === a && x.key === E[_m3].base && (O = A(T(t) ? t : h.min)), h.positiveValuesOnly && r(O) && 0 >= O && (O = void 0), _n6.total = _n6.stackTotal = A(J.total), _n6.percentage = r(_n6.y) && J.total ? _n6.y / J.total * 100 : void 0, _n6.stackY = R, this.irregularWidths || J.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis)));\n            _n6.yBottom = r(O) ? d(h.translate(O, !1, !0, !1, !0), -1E5, 1E5) : void 0;\n            this.dataModify && (R = this.dataModify.modifyValue(R, w));\n            var N = void 0;\n            T(R) && void 0 !== _n6.plotX && (N = h.translate(R, !1, !0, !1, !0), N = T(N) ? d(N, -1E5, 1E5) : void 0);\n            _n6.plotY = N;\n            _n6.isInside = this.isPointInside(_n6);\n            _n6.clientX = p ? k(f.translate(_m3, !1, !1, !1, !0, q)) : v;\n            _n6.negative = (_n6.y || 0) < (t || 0);\n            _n6.category = A(e && e[_n6.x], _n6.x);\n            _n6.isNull || !1 === _n6.visible || (\"undefined\" !== typeof u && (D = Math.min(D, Math.abs(v - u))), u = v);\n            _n6.zone = this.zones.length ? _n6.getZone() : void 0;\n            !_n6.graphic && this.group && g && (_n6.isNew = !0);\n          }\n          this.closestPointRangePx = D;\n          n(this, \"afterTranslate\");\n        }\n      }, {\n        key: \"getValidPoints\",\n        value: function getValidPoints(b, a, c) {\n          var d = this.chart;\n          return (b || this.points || []).filter(function (b) {\n            var f = b.plotX,\n              e = b.plotY;\n            return !c && (b.isNull || !T(e)) || a && !d.isInsidePlot(f, e, {\n              inverted: d.inverted\n            }) ? !1 : !1 !== b.visible;\n          });\n        }\n      }, {\n        key: \"getClipBox\",\n        value: function getClipBox() {\n          var b = this.chart,\n            a = this.xAxis,\n            c = this.yAxis,\n            d = V(b.clipBox);\n          a && a.len !== b.plotSizeX && (d.width = a.len);\n          c && c.len !== b.plotSizeY && (d.height = c.len);\n          return d;\n        }\n      }, {\n        key: \"getSharedClipKey\",\n        value: function getSharedClipKey() {\n          return this.sharedClipKey = (this.options.xAxis || 0) + \",\" + (this.options.yAxis || 0);\n        }\n      }, {\n        key: \"setClip\",\n        value: function setClip() {\n          var b = this.chart,\n            a = this.group,\n            c = this.markerGroup,\n            d = b.sharedClips,\n            f = b.renderer,\n            e = this.getClipBox(),\n            g = this.getSharedClipKey();\n          var k = d[g];\n          k ? k.animate(e) : d[g] = k = f.clipRect(e);\n          a && a.clip(!1 === this.options.clip ? void 0 : k);\n          c && c.clip();\n        }\n      }, {\n        key: \"animate\",\n        value: function animate(b) {\n          var a = this.chart,\n            c = this.group,\n            d = this.markerGroup,\n            f = a.inverted;\n          var e = l(this.options.animation),\n            g = [this.getSharedClipKey(), e.duration, e.easing, e.defer].join();\n          var k = a.sharedClips[g],\n            n = a.sharedClips[g + \"m\"];\n          if (b && c) e = this.getClipBox(), k ? k.attr(\"height\", e.height) : (e.width = 0, f && (e.x = a.plotHeight), k = a.renderer.clipRect(e), a.sharedClips[g] = k, n = a.renderer.clipRect({\n            x: -99,\n            y: -99,\n            width: f ? a.plotWidth + 199 : 99,\n            height: f ? 99 : a.plotHeight + 199\n          }), a.sharedClips[g + \"m\"] = n), c.clip(k), d && d.clip(n);else if (k && !k.hasClass(\"highcharts-animating\")) {\n            g = this.getClipBox();\n            var _b27 = e.step;\n            d && d.element.childNodes.length && (e.step = function (a, c) {\n              _b27 && _b27.apply(c, arguments);\n              \"width\" === c.prop && n && n.element && n.attr(f ? \"height\" : \"width\", a + 99);\n            });\n            k.addClass(\"highcharts-animating\").animate(g, e);\n          }\n        }\n      }, {\n        key: \"afterAnimate\",\n        value: function afterAnimate() {\n          var _this13 = this;\n          this.setClip();\n          Y(this.chart.sharedClips, function (b, a, c) {\n            b && !_this13.chart.container.querySelector(\"[clip-path=\\\"url(#\".concat(b.id, \")\\\"]\")) && (b.destroy(), delete c[a]);\n          });\n          this.finishedAnimating = !0;\n          n(this, \"afterAnimate\");\n        }\n      }, {\n        key: \"drawPoints\",\n        value: function drawPoints() {\n          var b = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.points;\n          var a = this.chart,\n            c = a.styledMode,\n            d = this.colorAxis,\n            f = this.options,\n            e = f.marker,\n            g = this[this.specialGroup || \"markerGroup\"],\n            k = this.xAxis,\n            n = A(e.enabled, !k || k.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius);\n          var h, l, m, q;\n          var p, r;\n          if (!1 !== e.enabled || this._hasPointMarkers) for (h = 0; h < b.length; h++) {\n            l = b[h];\n            q = (m = l.graphic) ? \"animate\" : \"attr\";\n            var t = l.marker || {};\n            p = !!l.marker;\n            if ((n && \"undefined\" === typeof t.enabled || t.enabled) && !l.isNull && !1 !== l.visible) {\n              var _b28 = A(t.symbol, this.symbol, \"rect\");\n              r = this.markerAttribs(l, l.selected && \"select\");\n              this.enabledDataSorting && (l.startXPos = k.reversed ? -(r.width || 0) : k.width);\n              var _f11 = !1 !== l.isInside;\n              !m && _f11 && (0 < (r.width || 0) || l.hasImage) && (l.graphic = m = a.renderer.symbol(_b28, r.x, r.y, r.width, r.height, p ? t : e).add(g), this.enabledDataSorting && a.hasRendered && (m.attr({\n                x: l.startXPos\n              }), q = \"animate\"));\n              m && \"animate\" === q && m[_f11 ? \"show\" : \"hide\"](_f11).animate(r);\n              if (m) if (t = this.pointAttribs(l, c || !l.selected ? void 0 : \"select\"), c) d && m.css({\n                fill: t.fill\n              });else m[q](t);\n              m && m.addClass(l.getClassName(), !0);\n            } else m && (l.graphic = m.destroy());\n          }\n        }\n      }, {\n        key: \"markerAttribs\",\n        value: function markerAttribs(b, a) {\n          var c = this.options;\n          var d = c.marker;\n          var f = b.marker || {},\n            e = f.symbol || d.symbol,\n            g = {};\n          var k = A(f.radius, d && d.radius);\n          a && (d = d.states[a], a = f.states && f.states[a], k = A(a && a.radius, d && d.radius, k && k + (d && d.radiusPlus || 0)));\n          b.hasImage = e && 0 === e.indexOf(\"url\");\n          b.hasImage && (k = 0);\n          b = b.pos();\n          T(k) && b && (g.x = b[0] - k, g.y = b[1] - k, c.crisp && (g.x = Math.floor(g.x)));\n          k && (g.width = g.height = 2 * k);\n          return g;\n        }\n      }, {\n        key: \"pointAttribs\",\n        value: function pointAttribs(b, a) {\n          var c = this.options.marker,\n            d = b && b.options;\n          var f = d && d.marker || {};\n          var e = d && d.color,\n            g = b && b.color;\n          var k = b && b.zone && b.zone.color;\n          var n = this.color;\n          b = A(f.lineWidth, c.lineWidth);\n          d = 1;\n          n = e || k || g || n;\n          e = f.fillColor || c.fillColor || n;\n          g = f.lineColor || c.lineColor || n;\n          a = a || \"normal\";\n          c = c.states[a] || {};\n          a = f.states && f.states[a] || {};\n          b = A(a.lineWidth, c.lineWidth, b + A(a.lineWidthPlus, c.lineWidthPlus, 0));\n          e = a.fillColor || c.fillColor || e;\n          g = a.lineColor || c.lineColor || g;\n          d = A(a.opacity, c.opacity, d);\n          return {\n            stroke: g,\n            \"stroke-width\": b,\n            fill: e,\n            opacity: d\n          };\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy(b) {\n          var a = this,\n            c = a.chart,\n            d = /AppleWebKit\\/533/.test(e.navigator.userAgent),\n            f = a.data || [];\n          var g, k, h, l;\n          n(a, \"destroy\", {\n            keepEventsForUpdate: b\n          });\n          this.removeEvents(b);\n          (a.axisTypes || []).forEach(function (b) {\n            (l = a[b]) && l.series && (G(l.series, a), l.isDirty = l.forceRedraw = !0);\n          });\n          a.legendItem && a.chart.legend.destroyItem(a);\n          for (k = f.length; k--;) (h = f[k]) && h.destroy && h.destroy();\n          a.clips && a.clips.forEach(function (b) {\n            return b.destroy();\n          });\n          v.clearTimeout(a.animationTimeout);\n          Y(a, function (b, a) {\n            b instanceof u && !b.survive && (g = d && \"group\" === a ? \"hide\" : \"destroy\", b[g]());\n          });\n          c.hoverSeries === a && (c.hoverSeries = void 0);\n          G(c.series, a);\n          c.orderItems(\"series\");\n          Y(a, function (c, d) {\n            b && \"hcEvents\" === d || delete a[d];\n          });\n        }\n      }, {\n        key: \"applyZones\",\n        value: function applyZones() {\n          var b = this,\n            a = this.chart,\n            c = a.renderer,\n            f = this.zones,\n            e = this.clips || [],\n            g = this.graph,\n            k = this.area,\n            n = Math.max(a.plotWidth, a.plotHeight),\n            h = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            l = a.inverted;\n          var m,\n            q,\n            p,\n            r,\n            t,\n            w,\n            v,\n            u,\n            x,\n            D,\n            E,\n            G = !1;\n          f.length && (g || k) && h && \"undefined\" !== typeof h.min ? (t = h.reversed, w = h.horiz, g && !this.showLine && g.hide(), k && k.hide(), r = h.getExtremes(), f.forEach(function (f, Q) {\n            m = t ? w ? a.plotWidth : 0 : w ? 0 : h.toPixels(r.min) || 0;\n            m = d(A(q, m), 0, n);\n            q = d(Math.round(h.toPixels(A(f.value, r.max), !0) || 0), 0, n);\n            G && (m = q = h.toPixels(r.max));\n            v = Math.abs(m - q);\n            u = Math.min(m, q);\n            x = Math.max(m, q);\n            h.isXAxis ? (p = {\n              x: l ? x : u,\n              y: 0,\n              width: v,\n              height: n\n            }, w || (p.x = a.plotHeight - p.x)) : (p = {\n              x: 0,\n              y: l ? x : u,\n              width: n,\n              height: v\n            }, w && (p.y = a.plotWidth - p.y));\n            e[Q] ? e[Q].animate(p) : e[Q] = c.clipRect(p);\n            D = b[\"zone-area-\" + Q];\n            E = b[\"zone-graph-\" + Q];\n            g && E && E.clip(e[Q]);\n            k && D && D.clip(e[Q]);\n            G = f.value > r.max;\n            b.resetZones && 0 === q && (q = void 0);\n          }), this.clips = e) : b.visible && (g && g.show(), k && k.show());\n        }\n      }, {\n        key: \"plotGroup\",\n        value: function plotGroup(b, a, c, d, f) {\n          var e = this[b];\n          var g = !e;\n          c = {\n            visibility: c,\n            zIndex: d || .1\n          };\n          \"undefined\" === typeof this.opacity || this.chart.styledMode || \"inactive\" === this.state || (c.opacity = this.opacity);\n          g && (this[b] = e = this.chart.renderer.g().add(f));\n          e.addClass(\"highcharts-\" + a + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (r(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (e.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n          e.attr(c)[g ? \"attr\" : \"animate\"](this.getPlotBox(a));\n          return e;\n        }\n      }, {\n        key: \"getPlotBox\",\n        value: function getPlotBox(b) {\n          var a = this.xAxis,\n            c = this.yAxis;\n          var d = this.chart;\n          b = d.inverted && !d.polar && a && !1 !== this.invertible && \"series\" === b;\n          d.inverted && (a = c, c = this.xAxis);\n          return {\n            translateX: a ? a.left : d.plotLeft,\n            translateY: c ? c.top : d.plotTop,\n            rotation: b ? 90 : 0,\n            rotationOriginX: b ? (a.len - c.len) / 2 : 0,\n            rotationOriginY: b ? (a.len + c.len) / 2 : 0,\n            scaleX: b ? -1 : 1,\n            scaleY: 1\n          };\n        }\n      }, {\n        key: \"removeEvents\",\n        value: function removeEvents(b) {\n          b || M(this);\n          this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (b) {\n            b();\n          }), this.eventsToUnbind.length = 0);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var b = this;\n          var a = b.chart;\n          var c = b.options,\n            d = l(c.animation),\n            f = b.visible ? \"inherit\" : \"hidden\",\n            e = c.zIndex,\n            g = b.hasRendered;\n          a = a.seriesGroup;\n          var k = b.finishedAnimating ? 0 : d.duration;\n          n(this, \"render\");\n          b.plotGroup(\"group\", \"series\", f, e, a);\n          b.markerGroup = b.plotGroup(\"markerGroup\", \"markers\", f, e, a);\n          !1 !== c.clip && b.setClip();\n          b.animate && k && b.animate(!0);\n          b.drawGraph && (b.drawGraph(), b.applyZones());\n          b.visible && b.drawPoints();\n          b.drawDataLabels && b.drawDataLabels();\n          b.redrawPoints && b.redrawPoints();\n          b.drawTracker && c.enableMouseTracking && b.drawTracker();\n          b.animate && k && b.animate();\n          g || (k && d.defer && (k += d.defer), b.animationTimeout = ba(function () {\n            b.afterAnimate();\n          }, k || 0));\n          b.isDirty = !1;\n          b.hasRendered = !0;\n          n(b, \"afterRender\");\n        }\n      }, {\n        key: \"redraw\",\n        value: function redraw() {\n          var b = this.isDirty || this.isDirtyData;\n          this.translate();\n          this.render();\n          b && delete this.kdTree;\n        }\n      }, {\n        key: \"searchPoint\",\n        value: function searchPoint(b, a) {\n          var c = this.xAxis,\n            d = this.yAxis,\n            f = this.chart.inverted;\n          return this.searchKDTree({\n            clientX: f ? c.len - b.chartY + c.pos : b.chartX - c.pos,\n            plotY: f ? d.len - b.chartX + d.pos : b.chartY - d.pos\n          }, a, b);\n        }\n      }, {\n        key: \"buildKDTree\",\n        value: function buildKDTree(b) {\n          function a(b, d, f) {\n            var e = b && b.length;\n            var g;\n            if (e) return g = c.kdAxisArray[d % f], b.sort(function (b, a) {\n              return b[g] - a[g];\n            }), e = Math.floor(e / 2), {\n              point: b[e],\n              left: a(b.slice(0, e), d + 1, f),\n              right: a(b.slice(e + 1), d + 1, f)\n            };\n          }\n          this.buildingKdTree = !0;\n          var c = this,\n            d = -1 < c.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n          delete c.kdTree;\n          ba(function () {\n            c.kdTree = a(c.getValidPoints(null, !c.directTouch), d, d);\n            c.buildingKdTree = !1;\n          }, c.options.kdNow || b && \"touchstart\" === b.type ? 0 : 1);\n        }\n      }, {\n        key: \"searchKDTree\",\n        value: function searchKDTree(b, a, c) {\n          function d(b, a, c, n) {\n            var h = a.point;\n            var l = f.kdAxisArray[c % n];\n            var m = h;\n            var q = r(b[e]) && r(h[e]) ? Math.pow(b[e] - h[e], 2) : null;\n            var p = r(b[g]) && r(h[g]) ? Math.pow(b[g] - h[g], 2) : null;\n            p = (q || 0) + (p || 0);\n            h.dist = r(p) ? Math.sqrt(p) : Number.MAX_VALUE;\n            h.distX = r(q) ? Math.sqrt(q) : Number.MAX_VALUE;\n            l = b[l] - h[l];\n            p = 0 > l ? \"left\" : \"right\";\n            q = 0 > l ? \"right\" : \"left\";\n            a[p] && (p = d(b, a[p], c + 1, n), m = p[k] < m[k] ? p : h);\n            a[q] && Math.sqrt(l * l) < m[k] && (b = d(b, a[q], c + 1, n), m = b[k] < m[k] ? b : m);\n            return m;\n          }\n          var f = this,\n            e = this.kdAxisArray[0],\n            g = this.kdAxisArray[1],\n            k = a ? \"distX\" : \"dist\";\n          a = -1 < f.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n          this.kdTree || this.buildingKdTree || this.buildKDTree(c);\n          if (this.kdTree) return d(b, this.kdTree, a, a);\n        }\n      }, {\n        key: \"pointPlacementToXValue\",\n        value: function pointPlacementToXValue() {\n          var _this$options = this.options,\n            b = _this$options.pointPlacement,\n            a = _this$options.pointRange,\n            c = this.xAxis;\n          var d = b;\n          \"between\" === d && (d = c.reversed ? -.5 : .5);\n          return T(d) ? d * (a || c.pointRange) : 0;\n        }\n      }, {\n        key: \"isPointInside\",\n        value: function isPointInside(b) {\n          var a = this.chart,\n            c = this.xAxis,\n            d = this.yAxis;\n          return \"undefined\" !== typeof b.plotY && \"undefined\" !== typeof b.plotX && 0 <= b.plotY && b.plotY <= (d ? d.len : a.plotHeight) && 0 <= b.plotX && b.plotX <= (c ? c.len : a.plotWidth);\n        }\n      }, {\n        key: \"drawTracker\",\n        value: function drawTracker() {\n          var b = this,\n            a = b.options,\n            c = a.trackByArea,\n            d = [].concat(c ? b.areaPath : b.graphPath),\n            f = b.chart,\n            e = f.pointer,\n            k = f.renderer,\n            l = f.options.tooltip.snap,\n            m = b.tracker,\n            q = function q(c) {\n              if (a.enableMouseTracking && f.hoverSeries !== b) b.onMouseOver();\n            },\n            p = \"rgba(192,192,192,\" + (g ? .0001 : .002) + \")\";\n          m ? m.attr({\n            d: d\n          }) : b.graph && (b.tracker = k.path(d).attr({\n            visibility: b.visible ? \"inherit\" : \"hidden\",\n            zIndex: 2\n          }).addClass(c ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(b.group), f.styledMode || b.tracker.attr({\n            \"stroke-linecap\": \"round\",\n            \"stroke-linejoin\": \"round\",\n            stroke: p,\n            fill: c ? p : \"none\",\n            \"stroke-width\": b.graph.strokeWidth() + (c ? 0 : 2 * l)\n          }), [b.tracker, b.markerGroup, b.dataLabelsGroup].forEach(function (b) {\n            if (b && (b.addClass(\"highcharts-tracker\").on(\"mouseover\", q).on(\"mouseout\", function (b) {\n              e.onTrackerMouseOut(b);\n            }), a.cursor && !f.styledMode && b.css({\n              cursor: a.cursor\n            }), h)) b.on(\"touchstart\", q);\n          }));\n          n(this, \"afterDrawTracker\");\n        }\n      }, {\n        key: \"addPoint\",\n        value: function addPoint(b, a, c, d, f) {\n          var e = this.options,\n            g = this.data,\n            k = this.chart;\n          var h = this.xAxis;\n          h = h && h.hasNames && h.names;\n          var l = e.data,\n            m = this.xData;\n          var q, p;\n          a = A(a, !0);\n          var r = {\n            series: this\n          };\n          this.pointClass.prototype.applyOptions.apply(r, [b]);\n          var t = r.x;\n          p = m.length;\n          if (this.requireSorting && t < m[p - 1]) for (q = !0; p && m[p - 1] > t;) p--;\n          this.updateParallelArrays(r, \"splice\", [p, 0, 0]);\n          this.updateParallelArrays(r, p);\n          h && r.name && (h[t] = r.name);\n          l.splice(p, 0, b);\n          if (q || this.processedData) this.data.splice(p, 0, null), this.processData();\n          \"point\" === e.legendType && this.generatePoints();\n          c && (g[0] && g[0].remove ? g[0].remove(!1) : (g.shift(), this.updateParallelArrays(r, \"shift\"), l.shift()));\n          !1 !== f && n(this, \"addPoint\", {\n            point: r\n          });\n          this.isDirtyData = this.isDirty = !0;\n          a && k.redraw(d);\n        }\n      }, {\n        key: \"removePoint\",\n        value: function removePoint(b, a, c) {\n          var d = this,\n            f = d.data,\n            e = f[b],\n            g = d.points,\n            k = d.chart,\n            h = function h() {\n              g && g.length === f.length && g.splice(b, 1);\n              f.splice(b, 1);\n              d.options.data.splice(b, 1);\n              d.updateParallelArrays(e || {\n                series: d\n              }, \"splice\", [b, 1]);\n              e && e.destroy();\n              d.isDirty = !0;\n              d.isDirtyData = !0;\n              a && k.redraw();\n            };\n          p(c, k);\n          a = A(a, !0);\n          e ? e.firePointEvent(\"remove\", null, h) : h();\n        }\n      }, {\n        key: \"remove\",\n        value: function remove(b, a, c, d) {\n          function f() {\n            e.destroy(d);\n            g.isDirtyLegend = g.isDirtyBox = !0;\n            g.linkSeries(d);\n            A(b, !0) && g.redraw(a);\n          }\n          var e = this,\n            g = e.chart;\n          !1 !== c ? n(e, \"remove\", null, f) : f();\n        }\n      }, {\n        key: \"update\",\n        value: function update(a, c) {\n          a = q(a, this.userOptions);\n          n(this, \"update\", {\n            options: a\n          });\n          var d = this,\n            e = d.chart;\n          var g = d.userOptions;\n          var k = d.initialType || d.type;\n          var h = e.options.plotOptions;\n          var l = w[k].prototype;\n          var m = d.finishedAnimating && {\n            animation: !1\n          };\n          var p = {};\n          var r,\n            t = [\"colorIndex\", \"eventOptions\", \"navigatorSeries\", \"symbolIndex\", \"baseSeries\"],\n            v = a.type || g.type || e.options.chart.type;\n          var u = !(this.hasDerivedData || v && v !== this.type || \"undefined\" !== typeof a.pointStart || \"undefined\" !== typeof a.pointInterval || \"undefined\" !== typeof a.relativeXValue || a.joinBy || a.mapData || d.hasOptionChanged(\"dataGrouping\") || d.hasOptionChanged(\"pointStart\") || d.hasOptionChanged(\"pointInterval\") || d.hasOptionChanged(\"pointIntervalUnit\") || d.hasOptionChanged(\"keys\"));\n          v = v || k;\n          u && (t.push(\"data\", \"isDirtyData\", \"points\", \"processedData\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"_hasPointLabels\", \"clips\", \"nodes\", \"layout\", \"level\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== a.visible && t.push(\"area\", \"graph\"), d.parallelArrays.forEach(function (b) {\n            t.push(b + \"Data\");\n          }), a.data && (a.dataSorting && f(d.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));\n          a = V(g, m, {\n            index: \"undefined\" === typeof g.index ? d.index : g.index,\n            pointStart: A(h && h.series && h.series.pointStart, g.pointStart, d.xData[0])\n          }, !u && {\n            data: d.options.data\n          }, a);\n          u && a.data && (a.data = d.options.data);\n          t = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(t);\n          t.forEach(function (b) {\n            t[b] = d[b];\n            delete d[b];\n          });\n          h = !1;\n          if (w[v]) {\n            if (h = v !== d.type, d.remove(!1, !1, !1, !0), h) if (Object.setPrototypeOf) Object.setPrototypeOf(d, w[v].prototype);else {\n              m = Object.hasOwnProperty.call(d, \"hcEvents\") && d.hcEvents;\n              for (r in l) d[r] = void 0;\n              f(d, w[v].prototype);\n              m ? d.hcEvents = m : delete d.hcEvents;\n            }\n          } else b(17, !0, e, {\n            missingModuleFor: v\n          });\n          t.forEach(function (b) {\n            d[b] = t[b];\n          });\n          d.init(e, a);\n          if (u && this.points) {\n            a = d.options;\n            if (!1 === a.visible) p.graphic = 1, p.dataLabel = 1;else if (!d._hasPointLabels) {\n              var _a13 = a,\n                _b29 = _a13.marker,\n                _c14 = _a13.dataLabels;\n              g = g.marker || {};\n              !_b29 || !1 !== _b29.enabled && g.symbol === _b29.symbol && g.height === _b29.height && g.width === _b29.width || (p.graphic = 1);\n              _c14 && !1 === _c14.enabled && (p.dataLabel = 1);\n            }\n            var _iterator6 = _createForOfIteratorHelper(this.points),\n              _step6;\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var _b30 = _step6.value;\n                _b30 && _b30.series && (_b30.resolveColor(), Object.keys(p).length && _b30.destroyElements(p), !1 === a.showInLegend && _b30.legendItem && e.legend.destroyItem(_b30));\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n          }\n          d.initialType = k;\n          e.linkSeries();\n          h && d.linkedSeries.length && (d.isDirtyData = !0);\n          n(this, \"afterUpdate\");\n          A(c, !0) && e.redraw(u ? void 0 : !1);\n        }\n      }, {\n        key: \"setName\",\n        value: function setName(b) {\n          this.name = this.options.name = this.userOptions.name = b;\n          this.chart.isDirtyLegend = !0;\n        }\n      }, {\n        key: \"hasOptionChanged\",\n        value: function hasOptionChanged(b) {\n          var a = this.options[b],\n            c = this.chart.options.plotOptions,\n            d = this.userOptions[b];\n          return d ? a !== d : a !== A(c && c[this.type] && c[this.type][b], c && c.series && c.series[b], a);\n        }\n      }, {\n        key: \"onMouseOver\",\n        value: function onMouseOver() {\n          var b = this.chart,\n            a = b.hoverSeries;\n          b.pointer.setHoverChartIndex();\n          if (a && a !== this) a.onMouseOut();\n          this.options.events.mouseOver && n(this, \"mouseOver\");\n          this.setState(\"hover\");\n          b.hoverSeries = this;\n        }\n      }, {\n        key: \"onMouseOut\",\n        value: function onMouseOut() {\n          var b = this.options,\n            a = this.chart,\n            c = a.tooltip,\n            d = a.hoverPoint;\n          a.hoverSeries = null;\n          if (d) d.onMouseOut();\n          this && b.events.mouseOut && n(this, \"mouseOut\");\n          !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();\n          a.series.forEach(function (b) {\n            b.setState(\"\", !0);\n          });\n        }\n      }, {\n        key: \"setState\",\n        value: function setState(b, a) {\n          var c = this;\n          var d = c.options;\n          var f = c.graph,\n            e = d.inactiveOtherPoints,\n            g = d.states,\n            k = A(g[b || \"normal\"] && g[b || \"normal\"].animation, c.chart.options.chart.animation);\n          var h = d.lineWidth,\n            n = 0,\n            l = d.opacity;\n          b = b || \"\";\n          if (c.state !== b && ([c.group, c.markerGroup, c.dataLabelsGroup].forEach(function (a) {\n            a && (c.state && a.removeClass(\"highcharts-series-\" + c.state), b && a.addClass(\"highcharts-series-\" + b));\n          }), c.state = b, !c.chart.styledMode)) {\n            if (g[b] && !1 === g[b].enabled) return;\n            b && (h = g[b].lineWidth || h + (g[b].lineWidthPlus || 0), l = A(g[b].opacity, l));\n            if (f && !f.dashstyle && T(h)) for (d = {\n              \"stroke-width\": h\n            }, f.animate(d, k); c[\"zone-graph-\" + n];) c[\"zone-graph-\" + n].animate(d, k), n += 1;\n            e || [c.group, c.markerGroup, c.dataLabelsGroup, c.labelBySeries].forEach(function (b) {\n              b && b.animate({\n                opacity: l\n              }, k);\n            });\n          }\n          a && e && c.points && c.setAllPointsToState(b || void 0);\n        }\n      }, {\n        key: \"setAllPointsToState\",\n        value: function setAllPointsToState(b) {\n          this.points.forEach(function (a) {\n            a.setState && a.setState(b);\n          });\n        }\n      }, {\n        key: \"setVisible\",\n        value: function setVisible(b, a) {\n          var c = this,\n            d = c.chart,\n            f = d.options.chart.ignoreHiddenSeries,\n            e = c.visible,\n            g = (c.visible = b = c.options.visible = c.userOptions.visible = \"undefined\" === typeof b ? !e : b) ? \"show\" : \"hide\";\n          [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (b) {\n            if (c[b]) c[b][g]();\n          });\n          if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();\n          c.legendItem && d.legend.colorizeItem(c, b);\n          c.isDirty = !0;\n          c.options.stacking && d.series.forEach(function (b) {\n            b.options.stacking && b.visible && (b.isDirty = !0);\n          });\n          c.linkedSeries.forEach(function (a) {\n            a.setVisible(b, !1);\n          });\n          f && (d.isDirtyBox = !0);\n          n(c, g);\n          !1 !== a && d.redraw();\n        }\n      }, {\n        key: \"show\",\n        value: function show() {\n          this.setVisible(!0);\n        }\n      }, {\n        key: \"hide\",\n        value: function hide() {\n          this.setVisible(!1);\n        }\n      }, {\n        key: \"select\",\n        value: function select(b) {\n          this.selected = b = this.options.selected = \"undefined\" === typeof b ? !this.selected : b;\n          this.checkbox && (this.checkbox.checked = b);\n          n(this, b ? \"select\" : \"unselect\");\n        }\n      }, {\n        key: \"shouldShowTooltip\",\n        value: function shouldShowTooltip(b, a) {\n          var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n          c.series = this;\n          c.visiblePlotOnly = !0;\n          return this.chart.isInsidePlot(b, a, c);\n        }\n      }, {\n        key: \"drawLegendSymbol\",\n        value: function drawLegendSymbol(b, a) {\n          var c;\n          null === (c = C[this.options.legendSymbol || \"rectangle\"]) || void 0 === c ? void 0 : c.call(this, b, a);\n        }\n      }]);\n      return aa;\n    }();\n    aa.defaultOptions = H;\n    aa.types = B.seriesTypes;\n    aa.registerType = B.registerSeriesType;\n    f(aa.prototype, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      cropShoulder: 1,\n      directTouch: !1,\n      isCartesian: !0,\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: z,\n      requireSorting: !0,\n      sorted: !0\n    });\n    B.series = aa;\n    \"\";\n    \"\";\n    return aa;\n  });\n  M(a, \"Core/Chart/Chart.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Defaults.js\"], a[\"Core/Templating.js\"], a[\"Core/Foundation.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Time.js\"], a[\"Core/Utilities.js\"], a[\"Core/Renderer/HTML/AST.js\"]], function (a, y, I, L, C, z, H, B, u, v, l, p, t) {\n    var m = a.animate,\n      h = a.animObject,\n      g = a.setAnimation,\n      e = I.defaultOptions,\n      w = I.defaultTime,\n      x = L.numberFormat,\n      F = C.registerEventOptions,\n      d = z.charts,\n      k = z.doc,\n      r = z.marginNames,\n      q = z.svg,\n      G = z.win,\n      b = u.seriesTypes,\n      f = p.addEvent,\n      c = p.attr,\n      n = p.createElement,\n      P = p.css,\n      D = p.defined,\n      K = p.diffObjects,\n      X = p.discardElement,\n      T = p.erase,\n      Z = p.error,\n      V = p.extend,\n      Y = p.find,\n      A = p.fireEvent,\n      M = p.getStyle,\n      ia = p.isArray,\n      ba = p.isNumber,\n      aa = p.isObject,\n      J = p.isString,\n      N = p.merge,\n      O = p.objectEach,\n      S = p.pick,\n      W = p.pInt,\n      ha = p.relativeLength,\n      da = p.removeEvent,\n      fa = p.splat,\n      ka = p.syncTimeout,\n      ca = p.uniqueKey;\n    var ea = /*#__PURE__*/function () {\n      _createClass(ea, null, [{\n        key: \"chart\",\n        value: function chart(b, a, c) {\n          return new ea(b, a, c);\n        }\n      }]);\n      function ea(b, a, c) {\n        _classCallCheck(this, ea);\n        this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;\n        this.sharedClips = {};\n        this.zooming = this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;\n        this.getArgs(b, a, c);\n      }\n      _createClass(ea, [{\n        key: \"getArgs\",\n        value: function getArgs(b, a, c) {\n          J(b) || b.nodeName ? (this.renderTo = b, this.init(a, c)) : this.init(b, a);\n        }\n      }, {\n        key: \"setZoomOptions\",\n        value: function setZoomOptions() {\n          var b = this.options.chart,\n            a = b.zooming;\n          this.zooming = Object.assign(Object.assign({}, a), {\n            type: S(b.zoomType, a.type),\n            key: S(b.zoomKey, a.key),\n            pinchType: S(b.pinchType, a.pinchType),\n            singleTouch: S(b.zoomBySingleTouch, a.singleTouch, !1),\n            resetButton: N(a.resetButton, b.resetZoomButton)\n          });\n        }\n      }, {\n        key: \"init\",\n        value: function init(b, a) {\n          A(this, \"init\", {\n            args: arguments\n          }, function () {\n            var c = N(e, b),\n              f = c.chart;\n            this.userOptions = V({}, b);\n            this.margin = [];\n            this.spacing = [];\n            this.bounds = {\n              h: {},\n              v: {}\n            };\n            this.labelCollectors = [];\n            this.callback = a;\n            this.isResizing = 0;\n            this.options = c;\n            this.axes = [];\n            this.series = [];\n            this.time = b.time && Object.keys(b.time).length ? new l(b.time) : z.time;\n            this.numberFormatter = f.numberFormatter || x;\n            this.styledMode = f.styledMode;\n            this.hasCartesianSeries = f.showAxes;\n            this.index = d.length;\n            d.push(this);\n            z.chartCount++;\n            F(this, f);\n            this.xAxis = [];\n            this.yAxis = [];\n            this.pointCount = this.colorCounter = this.symbolCounter = 0;\n            this.setZoomOptions();\n            A(this, \"afterInit\");\n            this.firstRender();\n          });\n        }\n      }, {\n        key: \"initSeries\",\n        value: function initSeries(a) {\n          var c = this.options.chart;\n          c = a.type || c.type;\n          var d = b[c];\n          d || Z(17, !0, this, {\n            missingModuleFor: c\n          });\n          c = new d();\n          \"function\" === typeof c.init && c.init(this, a);\n          return c;\n        }\n      }, {\n        key: \"setSeriesData\",\n        value: function setSeriesData() {\n          this.getSeriesOrderByLinks().forEach(function (b) {\n            b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);\n          });\n        }\n      }, {\n        key: \"getSeriesOrderByLinks\",\n        value: function getSeriesOrderByLinks() {\n          return this.series.concat().sort(function (b, a) {\n            return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;\n          });\n        }\n      }, {\n        key: \"orderItems\",\n        value: function orderItems(b) {\n          var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          var c = this[b],\n            d = this.options[b] = fa(this.options[b]).slice();\n          b = this.userOptions[b] = this.userOptions[b] ? fa(this.userOptions[b]).slice() : [];\n          this.hasRendered && (d.splice(a), b.splice(a));\n          if (c) for (var _f12 = a, _e5 = c.length; _f12 < _e5; ++_f12) if (a = c[_f12]) a.index = _f12, a instanceof B && (a.name = a.getName()), a.options.isInternal || (d[_f12] = a.options, b[_f12] = a.userOptions);\n        }\n      }, {\n        key: \"isInsidePlot\",\n        value: function isInsidePlot(b, a) {\n          var _this$scrollingContai;\n          var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n          var d = this.inverted,\n            f = this.plotBox,\n            e = this.plotLeft,\n            g = this.plotTop,\n            k = this.scrollablePlotBox;\n          var h = 0;\n          var n = 0;\n          c.visiblePlotOnly && this.scrollingContainer && (_this$scrollingContai = this.scrollingContainer, h = _this$scrollingContai.scrollLeft, n = _this$scrollingContai.scrollTop, _this$scrollingContai);\n          var l = c.series,\n            m = c.visiblePlotOnly && k || f;\n          var q = c.inverted ? a : b;\n          a = c.inverted ? b : a;\n          b = {\n            x: q,\n            y: a,\n            isInsidePlot: !0,\n            options: c\n          };\n          if (!c.ignoreX) {\n            var _a14 = l && (d && !this.polar ? l.yAxis : l.xAxis) || {\n              pos: e,\n              len: Infinity\n            };\n            q = c.paneCoordinates ? _a14.pos + q : e + q;\n            q >= Math.max(h + e, _a14.pos) && q <= Math.min(h + e + m.width, _a14.pos + _a14.len) || (b.isInsidePlot = !1);\n          }\n          !c.ignoreY && b.isInsidePlot && (h = !d && c.axis && !c.axis.isXAxis && c.axis || l && (d ? l.xAxis : l.yAxis) || {\n            pos: g,\n            len: Infinity\n          }, c = c.paneCoordinates ? h.pos + a : g + a, c >= Math.max(n + g, h.pos) && c <= Math.min(n + g + m.height, h.pos + h.len) || (b.isInsidePlot = !1));\n          A(this, \"afterIsInsidePlot\", b);\n          return b.isInsidePlot;\n        }\n      }, {\n        key: \"redraw\",\n        value: function redraw(b) {\n          A(this, \"beforeRedraw\");\n          var a = this.hasCartesianSeries ? this.axes : this.colorAxis || [],\n            c = this.series,\n            d = this.pointer,\n            f = this.legend,\n            e = this.userOptions.legend,\n            k = this.renderer,\n            h = k.isHidden(),\n            n = [];\n          var l,\n            m,\n            q = this.isDirtyBox,\n            p = this.isDirtyLegend,\n            r;\n          k.rootFontSize = k.boxWrapper.getStyle(\"font-size\");\n          this.setResponsive && this.setResponsive(!1);\n          g(this.hasRendered ? b : !1, this);\n          h && this.temporaryDisplay();\n          this.layOutTitles(!1);\n          for (b = c.length; b--;) if (r = c[b], r.options.stacking || r.options.centerInCategory) if (m = !0, r.isDirty) {\n            l = !0;\n            break;\n          }\n          if (l) for (b = c.length; b--;) r = c[b], r.options.stacking && (r.isDirty = !0);\n          c.forEach(function (b) {\n            b.isDirty && (\"point\" === b.options.legendType ? (\"function\" === typeof b.updateTotals && b.updateTotals(), p = !0) : e && (e.labelFormatter || e.labelFormat) && (p = !0));\n            b.isDirtyData && A(b, \"updatedData\");\n          });\n          p && f && f.options.enabled && (f.render(), this.isDirtyLegend = !1);\n          m && this.getStacks();\n          a.forEach(function (b) {\n            b.updateNames();\n            b.setScale();\n          });\n          this.getMargins();\n          a.forEach(function (b) {\n            b.isDirty && (q = !0);\n          });\n          a.forEach(function (b) {\n            var a = b.min + \",\" + b.max;\n            b.extKey !== a && (b.extKey = a, n.push(function () {\n              A(b, \"afterSetExtremes\", V(b.eventArgs, b.getExtremes()));\n              delete b.eventArgs;\n            }));\n            (q || m) && b.redraw();\n          });\n          q && this.drawChartBox();\n          A(this, \"predraw\");\n          c.forEach(function (b) {\n            (q || b.isDirty) && b.visible && b.redraw();\n            b.isDirtyData = !1;\n          });\n          d && d.reset(!0);\n          k.draw();\n          A(this, \"redraw\");\n          A(this, \"render\");\n          h && this.temporaryDisplay(!0);\n          n.forEach(function (b) {\n            b.call();\n          });\n        }\n      }, {\n        key: \"get\",\n        value: function get(b) {\n          function a(a) {\n            return a.id === b || a.options && a.options.id === b;\n          }\n          var c = this.series;\n          var d = Y(this.axes, a) || Y(this.series, a);\n          for (var _b31 = 0; !d && _b31 < c.length; _b31++) d = Y(c[_b31].points || [], a);\n          return d;\n        }\n      }, {\n        key: \"getAxes\",\n        value: function getAxes() {\n          var b = this.options;\n          A(this, \"getAxes\");\n          for (var _i2 = 0, _arr2 = [\"xAxis\", \"yAxis\"]; _i2 < _arr2.length; _i2++) {\n            var _a15 = _arr2[_i2];\n            var _c15 = b[_a15] = fa(b[_a15] || {});\n            var _iterator7 = _createForOfIteratorHelper(_c15),\n              _step7;\n            try {\n              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                var _b32 = _step7.value;\n                new y(this, _b32, _a15);\n              }\n            } catch (err) {\n              _iterator7.e(err);\n            } finally {\n              _iterator7.f();\n            }\n          }\n          A(this, \"afterGetAxes\");\n        }\n      }, {\n        key: \"getSelectedPoints\",\n        value: function getSelectedPoints() {\n          return this.series.reduce(function (b, a) {\n            a.getPointsCollection().forEach(function (a) {\n              S(a.selectedStaging, a.selected) && b.push(a);\n            });\n            return b;\n          }, []);\n        }\n      }, {\n        key: \"getSelectedSeries\",\n        value: function getSelectedSeries() {\n          return this.series.filter(function (b) {\n            return b.selected;\n          });\n        }\n      }, {\n        key: \"setTitle\",\n        value: function setTitle(b, a, c) {\n          this.applyDescription(\"title\", b);\n          this.applyDescription(\"subtitle\", a);\n          this.applyDescription(\"caption\", void 0);\n          this.layOutTitles(c);\n        }\n      }, {\n        key: \"applyDescription\",\n        value: function applyDescription(b, a) {\n          var c = this,\n            d = this.options[b] = N(this.options[b], a);\n          var f = this[b];\n          f && a && (this[b] = f = f.destroy());\n          d && !f && (f = this.renderer.text(d.text, 0, 0, d.useHTML).attr({\n            align: d.align,\n            \"class\": \"highcharts-\" + b,\n            zIndex: d.zIndex || 4\n          }).add(), f.update = function (a, d) {\n            c.applyDescription(b, a);\n            c.layOutTitles(d);\n          }, this.styledMode || f.css(V(\"title\" === b ? {\n            fontSize: this.options.isStock ? \"1em\" : \"1.2em\"\n          } : {}, d.style)), this[b] = f);\n        }\n      }, {\n        key: \"layOutTitles\",\n        value: function layOutTitles() {\n          var b = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n          var a = [0, 0, 0],\n            c = this.renderer,\n            d = this.spacingBox;\n          [\"title\", \"subtitle\", \"caption\"].forEach(function (b) {\n            var f = this[b],\n              e = this.options[b],\n              g = e.verticalAlign || \"top\";\n            b = \"title\" === b ? \"top\" === g ? -3 : 0 : \"top\" === g ? a[0] + 2 : 0;\n            if (f) {\n              f.css({\n                width: (e.width || d.width + (e.widthAdjust || 0)) + \"px\"\n              });\n              var _k8 = c.fontMetrics(f).b,\n                _h9 = Math.round(f.getBBox(e.useHTML).height);\n              f.align(V({\n                y: \"bottom\" === g ? _k8 : b + _k8,\n                height: _h9\n              }, e), !1, \"spacingBox\");\n              e.floating || (\"top\" === g ? a[0] = Math.ceil(a[0] + _h9) : \"bottom\" === g && (a[2] = Math.ceil(a[2] + _h9)));\n            }\n          }, this);\n          a[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (a[0] += this.options.title.margin);\n          a[2] && \"bottom\" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);\n          var f = !this.titleOffset || this.titleOffset.join(\",\") !== a.join(\",\");\n          this.titleOffset = a;\n          A(this, \"afterLayOutTitles\");\n          !this.isDirtyBox && f && (this.isDirtyBox = this.isDirtyLegend = f, this.hasRendered && b && this.isDirtyBox && this.redraw());\n        }\n      }, {\n        key: \"getContainerBox\",\n        value: function getContainerBox() {\n          return {\n            width: M(this.renderTo, \"width\", !0) || 0,\n            height: M(this.renderTo, \"height\", !0) || 0\n          };\n        }\n      }, {\n        key: \"getChartSize\",\n        value: function getChartSize() {\n          var b = this.options.chart;\n          var a = b.width;\n          b = b.height;\n          var c = this.getContainerBox();\n          this.chartWidth = Math.max(0, a || c.width || 600);\n          this.chartHeight = Math.max(0, ha(b, this.chartWidth) || (1 < c.height ? c.height : 400));\n          this.containerBox = c;\n        }\n      }, {\n        key: \"temporaryDisplay\",\n        value: function temporaryDisplay(b) {\n          var a = this.renderTo;\n          if (b) for (; a && a.style;) a.hcOrigStyle && (P(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (k.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;else for (; a && a.style;) {\n            k.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, k.body.appendChild(a));\n            if (\"none\" === M(a, \"display\", !1) || a.hcOricDetached) a.hcOrigStyle = {\n              display: a.style.display,\n              height: a.style.height,\n              overflow: a.style.overflow\n            }, b = {\n              display: \"block\",\n              overflow: \"hidden\"\n            }, a !== this.renderTo && (b.height = 0), P(a, b), a.offsetWidth || a.style.setProperty(\"display\", \"block\", \"important\");\n            a = a.parentNode;\n            if (a === k.body) break;\n          }\n        }\n      }, {\n        key: \"setClassName\",\n        value: function setClassName(b) {\n          this.container.className = \"highcharts-container \" + (b || \"\");\n        }\n      }, {\n        key: \"getContainer\",\n        value: function getContainer() {\n          var b = this.options,\n            a = b.chart;\n          var f = ca();\n          var e,\n            h = this.renderTo;\n          h || (this.renderTo = h = a.renderTo);\n          J(h) && (this.renderTo = h = k.getElementById(h));\n          h || Z(13, !0, this);\n          var l = W(c(h, \"data-highcharts-chart\"));\n          ba(l) && d[l] && d[l].hasRendered && d[l].destroy();\n          c(h, \"data-highcharts-chart\", this.index);\n          h.innerHTML = t.emptyHTML;\n          a.skipClone || h.offsetWidth || this.temporaryDisplay();\n          this.getChartSize();\n          l = this.chartWidth;\n          var m = this.chartHeight;\n          P(h, {\n            overflow: \"hidden\"\n          });\n          this.styledMode || (e = V({\n            position: \"relative\",\n            overflow: \"hidden\",\n            width: l + \"px\",\n            height: m + \"px\",\n            textAlign: \"left\",\n            lineHeight: \"normal\",\n            zIndex: 0,\n            \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n            userSelect: \"none\",\n            \"touch-action\": \"manipulation\",\n            outline: \"none\"\n          }, a.style || {}));\n          this.container = f = n(\"div\", {\n            id: f\n          }, e, h);\n          this._cursor = f.style.cursor;\n          this.renderer = new (a.renderer || !q ? H.getRendererType(a.renderer) : v)(f, l, m, void 0, a.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);\n          this.containerBox = this.getContainerBox();\n          g(void 0, this);\n          this.setClassName(a.className);\n          if (this.styledMode) for (var _a16 in b.defs) this.renderer.definition(b.defs[_a16]);else this.renderer.setStyle(a.style);\n          this.renderer.chartIndex = this.index;\n          A(this, \"afterGetContainer\");\n        }\n      }, {\n        key: \"getMargins\",\n        value: function getMargins(b) {\n          var a = this.spacing,\n            c = this.margin,\n            d = this.titleOffset;\n          this.resetMargins();\n          d[0] && !D(c[0]) && (this.plotTop = Math.max(this.plotTop, d[0] + a[0]));\n          d[2] && !D(c[2]) && (this.marginBottom = Math.max(this.marginBottom, d[2] + a[2]));\n          this.legend && this.legend.display && this.legend.adjustMargins(c, a);\n          A(this, \"getMargins\");\n          b || this.getAxisMargins();\n        }\n      }, {\n        key: \"getAxisMargins\",\n        value: function getAxisMargins() {\n          var b = this,\n            a = b.axisOffset = [0, 0, 0, 0],\n            c = b.colorAxis,\n            d = b.margin,\n            f = function f(b) {\n              b.forEach(function (b) {\n                b.visible && b.getOffset();\n              });\n            };\n          b.hasCartesianSeries ? f(b.axes) : c && c.length && f(c);\n          r.forEach(function (c, f) {\n            D(d[f]) || (b[c] += a[f]);\n          });\n          b.setChartSize();\n        }\n      }, {\n        key: \"getOptions\",\n        value: function getOptions() {\n          return K(this.userOptions, e);\n        }\n      }, {\n        key: \"reflow\",\n        value: function reflow(b) {\n          var a = this;\n          var c = a.options.chart;\n          c = D(c.width) && D(c.height);\n          var d = a.containerBox,\n            f = a.getContainerBox();\n          delete a.pointer.chartPosition;\n          if (!c && !a.isPrinting && d && f.width) {\n            if (f.width !== d.width || f.height !== d.height) p.clearTimeout(a.reflowTimeout), a.reflowTimeout = ka(function () {\n              a.container && a.setSize(void 0, void 0, !1);\n            }, b ? 100 : 0);\n            a.containerBox = f;\n          }\n        }\n      }, {\n        key: \"setReflow\",\n        value: function setReflow() {\n          var b = this;\n          var a = function a(_a17) {\n            var c;\n            (null === (c = b.options) || void 0 === c ? 0 : c.chart.reflow) && b.hasLoaded && b.reflow(_a17);\n          };\n          \"function\" === typeof ResizeObserver ? new ResizeObserver(a).observe(b.renderTo) : (a = f(G, \"resize\", a), f(this, \"destroy\", a));\n        }\n      }, {\n        key: \"setSize\",\n        value: function setSize(b, a, c) {\n          var d = this,\n            f = d.renderer;\n          d.isResizing += 1;\n          g(c, d);\n          c = f.globalAnimation;\n          d.oldChartHeight = d.chartHeight;\n          d.oldChartWidth = d.chartWidth;\n          \"undefined\" !== typeof b && (d.options.chart.width = b);\n          \"undefined\" !== typeof a && (d.options.chart.height = a);\n          d.getChartSize();\n          d.styledMode || (c ? m : P)(d.container, {\n            width: d.chartWidth + \"px\",\n            height: d.chartHeight + \"px\"\n          }, c);\n          d.setChartSize(!0);\n          f.setSize(d.chartWidth, d.chartHeight, c);\n          d.axes.forEach(function (b) {\n            b.isDirty = !0;\n            b.setScale();\n          });\n          d.isDirtyLegend = !0;\n          d.isDirtyBox = !0;\n          d.layOutTitles();\n          d.getMargins();\n          d.redraw(c);\n          d.oldChartHeight = null;\n          A(d, \"resize\");\n          ka(function () {\n            d && A(d, \"endResize\", null, function () {\n              --d.isResizing;\n            });\n          }, h(c).duration);\n        }\n      }, {\n        key: \"setChartSize\",\n        value: function setChartSize(b) {\n          var a = this.inverted;\n          var c = this.renderer;\n          var d = this.chartWidth,\n            f = this.chartHeight;\n          var e = this.options.chart,\n            g = this.spacing,\n            k = this.clipOffset;\n          var h, n, l, m;\n          this.plotLeft = h = Math.round(this.plotLeft);\n          this.plotTop = n = Math.round(this.plotTop);\n          this.plotWidth = l = Math.max(0, Math.round(d - h - this.marginRight));\n          this.plotHeight = m = Math.max(0, Math.round(f - n - this.marginBottom));\n          this.plotSizeX = a ? m : l;\n          this.plotSizeY = a ? l : m;\n          this.plotBorderWidth = e.plotBorderWidth || 0;\n          this.spacingBox = c.spacingBox = {\n            x: g[3],\n            y: g[0],\n            width: d - g[3] - g[1],\n            height: f - g[0] - g[2]\n          };\n          this.plotBox = c.plotBox = {\n            x: h,\n            y: n,\n            width: l,\n            height: m\n          };\n          a = 2 * Math.floor(this.plotBorderWidth / 2);\n          d = Math.ceil(Math.max(a, k[3]) / 2);\n          f = Math.ceil(Math.max(a, k[0]) / 2);\n          this.clipBox = {\n            x: d,\n            y: f,\n            width: Math.floor(this.plotSizeX - Math.max(a, k[1]) / 2 - d),\n            height: Math.max(0, Math.floor(this.plotSizeY - Math.max(a, k[2]) / 2 - f))\n          };\n          b || (this.axes.forEach(function (b) {\n            b.setAxisSize();\n            b.setAxisTranslation();\n          }), c.alignElements());\n          A(this, \"afterSetChartSize\", {\n            skipAxes: b\n          });\n        }\n      }, {\n        key: \"resetMargins\",\n        value: function resetMargins() {\n          A(this, \"resetMargins\");\n          var b = this,\n            a = b.options.chart;\n          [\"margin\", \"spacing\"].forEach(function (c) {\n            var d = a[c],\n              f = aa(d) ? d : [d, d, d, d];\n            [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (d, e) {\n              b[c][e] = S(a[c + d], f[e]);\n            });\n          });\n          r.forEach(function (a, c) {\n            b[a] = S(b.margin[c], b.spacing[c]);\n          });\n          b.axisOffset = [0, 0, 0, 0];\n          b.clipOffset = [0, 0, 0, 0];\n        }\n      }, {\n        key: \"drawChartBox\",\n        value: function drawChartBox() {\n          var b = this.options.chart,\n            a = this.renderer,\n            c = this.chartWidth,\n            d = this.chartHeight,\n            f = this.styledMode,\n            e = this.plotBGImage;\n          var g = b.backgroundColor;\n          var k = b.plotBackgroundColor,\n            h = b.plotBackgroundImage,\n            n = this.plotLeft,\n            l = this.plotTop,\n            m = this.plotWidth,\n            q = this.plotHeight,\n            p = this.plotBox,\n            r = this.clipRect,\n            t = this.clipBox;\n          var w = this.chartBackground,\n            v = this.plotBackground,\n            u = this.plotBorder,\n            x,\n            D,\n            E = \"animate\";\n          w || (this.chartBackground = w = a.rect().addClass(\"highcharts-background\").add(), E = \"attr\");\n          if (f) x = D = w.strokeWidth();else {\n            x = b.borderWidth || 0;\n            D = x + (b.shadow ? 8 : 0);\n            g = {\n              fill: g || \"none\"\n            };\n            if (x || w[\"stroke-width\"]) g.stroke = b.borderColor, g[\"stroke-width\"] = x;\n            w.attr(g).shadow(b.shadow);\n          }\n          w[E]({\n            x: D / 2,\n            y: D / 2,\n            width: c - D - x % 2,\n            height: d - D - x % 2,\n            r: b.borderRadius\n          });\n          E = \"animate\";\n          v || (E = \"attr\", this.plotBackground = v = a.rect().addClass(\"highcharts-plot-background\").add());\n          v[E](p);\n          f || (v.attr({\n            fill: k || \"none\"\n          }).shadow(b.plotShadow), h && (e ? (h !== e.attr(\"href\") && e.attr(\"href\", h), e.animate(p)) : this.plotBGImage = a.image(h, n, l, m, q).add()));\n          r ? r.animate({\n            width: t.width,\n            height: t.height\n          }) : this.clipRect = a.clipRect(t);\n          E = \"animate\";\n          u || (E = \"attr\", this.plotBorder = u = a.rect().addClass(\"highcharts-plot-border\").attr({\n            zIndex: 1\n          }).add());\n          f || u.attr({\n            stroke: b.plotBorderColor,\n            \"stroke-width\": b.plotBorderWidth || 0,\n            fill: \"none\"\n          });\n          u[E](u.crisp({\n            x: n,\n            y: l,\n            width: m,\n            height: q\n          }, -u.strokeWidth()));\n          this.isDirtyBox = !1;\n          A(this, \"afterDrawChartBox\");\n        }\n      }, {\n        key: \"propFromSeries\",\n        value: function propFromSeries() {\n          var a = this,\n            c = a.options.chart,\n            d = a.options.series;\n          var f, e, g;\n          [\"inverted\", \"angular\", \"polar\"].forEach(function (k) {\n            e = b[c.type];\n            g = c[k] || e && e.prototype[k];\n            for (f = d && d.length; !g && f--;) (e = b[d[f].type]) && e.prototype[k] && (g = !0);\n            a[k] = g;\n          });\n        }\n      }, {\n        key: \"linkSeries\",\n        value: function linkSeries(b) {\n          var a = this,\n            c = a.series;\n          c.forEach(function (b) {\n            b.linkedSeries.length = 0;\n          });\n          c.forEach(function (b) {\n            var c = b.options.linkedTo;\n            J(c) && (c = \":previous\" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), b.linkedParent = c, c.enabledDataSorting && b.setDataSortingOptions(), b.visible = S(b.options.visible, c.options.visible, b.visible));\n          });\n          A(this, \"afterLinkSeries\", {\n            isUpdating: b\n          });\n        }\n      }, {\n        key: \"renderSeries\",\n        value: function renderSeries() {\n          this.series.forEach(function (b) {\n            b.translate();\n            b.render();\n          });\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var b = this.axes,\n            a = this.colorAxis,\n            c = this.renderer,\n            d = function d(b) {\n              b.forEach(function (b) {\n                b.visible && b.render();\n              });\n            };\n          var f = 0;\n          this.setTitle();\n          A(this, \"beforeMargins\");\n          this.getStacks && this.getStacks();\n          this.getMargins(!0);\n          this.setChartSize();\n          var e = this.plotWidth;\n          b.some(function (b) {\n            if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return f = 21, !0;\n          });\n          var g = this.plotHeight = Math.max(this.plotHeight - f, 0);\n          b.forEach(function (b) {\n            b.setScale();\n          });\n          this.getAxisMargins();\n          var k = 1.1 < e / this.plotWidth,\n            h = 1.05 < g / this.plotHeight;\n          if (k || h) b.forEach(function (b) {\n            (b.horiz && k || !b.horiz && h) && b.setTickInterval(!0);\n          }), this.getMargins();\n          this.drawChartBox();\n          this.hasCartesianSeries ? d(b) : a && a.length && d(a);\n          this.seriesGroup || (this.seriesGroup = c.g(\"series-group\").attr({\n            zIndex: 3\n          }).shadow(this.options.chart.seriesGroupShadow).add());\n          this.renderSeries();\n          this.addCredits();\n          this.setResponsive && this.setResponsive();\n          this.hasRendered = !0;\n        }\n      }, {\n        key: \"addCredits\",\n        value: function addCredits(b) {\n          var a = this,\n            c = N(!0, this.options.credits, b);\n          c.enabled && !this.credits && (this.credits = this.renderer.text(c.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n            c.href && (G.location.href = c.href);\n          }).attr({\n            align: c.position.align,\n            zIndex: 8\n          }), a.styledMode || this.credits.css(c.style), this.credits.add().align(c.position), this.credits.update = function (b) {\n            a.credits = a.credits.destroy();\n            a.addCredits(b);\n          });\n        }\n      }, {\n        key: \"destroy\",\n        value: function destroy() {\n          var b = this,\n            a = b.axes,\n            c = b.series,\n            f = b.container,\n            e = f && f.parentNode;\n          var g;\n          A(b, \"destroy\");\n          b.renderer.forExport ? T(d, b) : d[b.index] = void 0;\n          z.chartCount--;\n          b.renderTo.removeAttribute(\"data-highcharts-chart\");\n          da(b);\n          for (g = a.length; g--;) a[g] = a[g].destroy();\n          this.scroller && this.scroller.destroy && this.scroller.destroy();\n          for (g = c.length; g--;) c[g] = c[g].destroy();\n          \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (a) {\n            var c = b[a];\n            c && c.destroy && (b[a] = c.destroy());\n          });\n          f && (f.innerHTML = t.emptyHTML, da(f), e && X(f));\n          O(b, function (a, c) {\n            delete b[c];\n          });\n        }\n      }, {\n        key: \"firstRender\",\n        value: function firstRender() {\n          var b = this,\n            a = b.options;\n          b.getContainer();\n          b.resetMargins();\n          b.setChartSize();\n          b.propFromSeries();\n          b.getAxes();\n          var c = ia(a.series) ? a.series : [];\n          a.series = [];\n          c.forEach(function (a) {\n            b.initSeries(a);\n          });\n          b.linkSeries();\n          b.setSeriesData();\n          A(b, \"beforeRender\");\n          b.render();\n          b.pointer.getChartPosition();\n          if (!b.renderer.imgCount && !b.hasLoaded) b.onload();\n          b.temporaryDisplay(!0);\n        }\n      }, {\n        key: \"onload\",\n        value: function onload() {\n          this.callbacks.concat([this.callback]).forEach(function (b) {\n            b && \"undefined\" !== typeof this.index && b.apply(this, [this]);\n          }, this);\n          A(this, \"load\");\n          A(this, \"render\");\n          D(this.index) && this.setReflow();\n          this.warnIfA11yModuleNotLoaded();\n          this.hasLoaded = !0;\n        }\n      }, {\n        key: \"warnIfA11yModuleNotLoaded\",\n        value: function warnIfA11yModuleNotLoaded() {\n          var b = this.options,\n            a = this.title;\n          b && !this.accessibility && (this.renderer.boxWrapper.attr({\n            role: \"img\",\n            \"aria-label\": (a && a.element.textContent || \"\").replace(/</g, \"&lt;\")\n          }), b.accessibility && !1 === b.accessibility.enabled || Z('Highcharts warning: Consider including the \"accessibility.js\" module to make your chart more usable for people with disabilities. Set the \"accessibility.enabled\" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));\n        }\n      }, {\n        key: \"addSeries\",\n        value: function addSeries(b, a, c) {\n          var d = this;\n          var f;\n          b && (a = S(a, !0), A(d, \"addSeries\", {\n            options: b\n          }, function () {\n            f = d.initSeries(b);\n            d.isDirtyLegend = !0;\n            d.linkSeries();\n            f.enabledDataSorting && f.setData(b.data, !1);\n            A(d, \"afterAddSeries\", {\n              series: f\n            });\n            a && d.redraw(c);\n          }));\n          return f;\n        }\n      }, {\n        key: \"addAxis\",\n        value: function addAxis(b, a, c, d) {\n          return this.createAxis(a ? \"xAxis\" : \"yAxis\", {\n            axis: b,\n            redraw: c,\n            animation: d\n          });\n        }\n      }, {\n        key: \"addColorAxis\",\n        value: function addColorAxis(b, a, c) {\n          return this.createAxis(\"colorAxis\", {\n            axis: b,\n            redraw: a,\n            animation: c\n          });\n        }\n      }, {\n        key: \"createAxis\",\n        value: function createAxis(b, a) {\n          b = new y(this, a.axis, b);\n          S(a.redraw, !0) && this.redraw(a.animation);\n          return b;\n        }\n      }, {\n        key: \"showLoading\",\n        value: function showLoading(b) {\n          var a = this,\n            c = a.options,\n            d = c.loading,\n            e = function e() {\n              g && P(g, {\n                left: a.plotLeft + \"px\",\n                top: a.plotTop + \"px\",\n                width: a.plotWidth + \"px\",\n                height: a.plotHeight + \"px\"\n              });\n            };\n          var g = a.loadingDiv,\n            k = a.loadingSpan;\n          g || (a.loadingDiv = g = n(\"div\", {\n            className: \"highcharts-loading highcharts-loading-hidden\"\n          }, null, a.container));\n          k || (a.loadingSpan = k = n(\"span\", {\n            className: \"highcharts-loading-inner\"\n          }, null, g), f(a, \"redraw\", e));\n          g.className = \"highcharts-loading\";\n          t.setElementHTML(k, S(b, c.lang.loading, \"\"));\n          a.styledMode || (P(g, V(d.style, {\n            zIndex: 10\n          })), P(k, d.labelStyle), a.loadingShown || (P(g, {\n            opacity: 0,\n            display: \"\"\n          }), m(g, {\n            opacity: d.style.opacity || .5\n          }, {\n            duration: d.showDuration || 0\n          })));\n          a.loadingShown = !0;\n          e();\n        }\n      }, {\n        key: \"hideLoading\",\n        value: function hideLoading() {\n          var b = this.options,\n            a = this.loadingDiv;\n          a && (a.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || m(a, {\n            opacity: 0\n          }, {\n            duration: b.loading.hideDuration || 100,\n            complete: function complete() {\n              P(a, {\n                display: \"none\"\n              });\n            }\n          }));\n          this.loadingShown = !1;\n        }\n      }, {\n        key: \"update\",\n        value: function update(b, a, c, d) {\n          var f = this,\n            e = {\n              credits: \"addCredits\",\n              title: \"setTitle\",\n              subtitle: \"setSubtitle\",\n              caption: \"setCaption\"\n            },\n            g = b.isResponsiveOptions,\n            k = [];\n          var h, n;\n          A(f, \"update\", {\n            options: b\n          });\n          g || f.setResponsive(!1, !0);\n          b = K(b, f.options);\n          f.userOptions = N(f.userOptions, b);\n          var m = b.chart;\n          if (m) {\n            N(!0, f.options.chart, m);\n            this.setZoomOptions();\n            \"className\" in m && f.setClassName(m.className);\n            if (\"inverted\" in m || \"polar\" in m || \"type\" in m) {\n              f.propFromSeries();\n              var q = !0;\n            }\n            \"alignTicks\" in m && (q = !0);\n            \"events\" in m && F(this, m);\n            O(m, function (b, a) {\n              -1 !== f.propsRequireUpdateSeries.indexOf(\"chart.\" + a) && (h = !0);\n              -1 !== f.propsRequireDirtyBox.indexOf(a) && (f.isDirtyBox = !0);\n              -1 !== f.propsRequireReflow.indexOf(a) && (g ? f.isDirtyBox = !0 : n = !0);\n            });\n            !f.styledMode && m.style && f.renderer.setStyle(f.options.chart.style || {});\n          }\n          !f.styledMode && b.colors && (this.options.colors = b.colors);\n          b.time && (this.time === w && (this.time = new l(b.time)), N(!0, f.options.time, b.time));\n          O(b, function (a, c) {\n            if (f[c] && \"function\" === typeof f[c].update) f[c].update(a, !1);else if (\"function\" === typeof f[e[c]]) f[e[c]](a);else \"colors\" !== c && -1 === f.collectionsWithUpdate.indexOf(c) && N(!0, f.options[c], b[c]);\n            \"chart\" !== c && -1 !== f.propsRequireUpdateSeries.indexOf(c) && (h = !0);\n          });\n          this.collectionsWithUpdate.forEach(function (a) {\n            b[a] && (fa(b[a]).forEach(function (b, d) {\n              var e = D(b.id);\n              var g;\n              e && (g = f.get(b.id));\n              !g && f[a] && (g = f[a][S(b.index, d)]) && (e && D(g.options.id) || g.options.isInternal) && (g = void 0);\n              g && g.coll === a && (g.update(b, !1), c && (g.touched = !0));\n              !g && c && f.collectionsWithInit[a] && (f.collectionsWithInit[a][0].apply(f, [b].concat(f.collectionsWithInit[a][1] || []).concat([!1])).touched = !0);\n            }), c && f[a].forEach(function (b) {\n              b.touched || b.options.isInternal ? delete b.touched : k.push(b);\n            }));\n          });\n          k.forEach(function (b) {\n            b.chart && b.remove && b.remove(!1);\n          });\n          q && f.axes.forEach(function (b) {\n            b.update({}, !1);\n          });\n          h && f.getSeriesOrderByLinks().forEach(function (b) {\n            b.chart && b.update({}, !1);\n          }, this);\n          q = m && m.width;\n          m = m && (J(m.height) ? ha(m.height, q || f.chartWidth) : m.height);\n          n || ba(q) && q !== f.chartWidth || ba(m) && m !== f.chartHeight ? f.setSize(q, m, d) : S(a, !0) && f.redraw(d);\n          A(f, \"afterUpdate\", {\n            options: b,\n            redraw: a,\n            animation: d\n          });\n        }\n      }, {\n        key: \"setSubtitle\",\n        value: function setSubtitle(b, a) {\n          this.applyDescription(\"subtitle\", b);\n          this.layOutTitles(a);\n        }\n      }, {\n        key: \"setCaption\",\n        value: function setCaption(b, a) {\n          this.applyDescription(\"caption\", b);\n          this.layOutTitles(a);\n        }\n      }, {\n        key: \"showResetZoom\",\n        value: function showResetZoom() {\n          function b() {\n            a.zoomOut();\n          }\n          var a = this,\n            c = e.lang,\n            d = a.zooming.resetButton,\n            f = d.theme,\n            g = \"chart\" === d.relativeTo || \"spacingBox\" === d.relativeTo ? null : \"scrollablePlotBox\";\n          A(this, \"beforeShowResetZoom\", null, function () {\n            a.resetZoomButton = a.renderer.button(c.resetZoom, null, null, b, f).attr({\n              align: d.position.align,\n              title: c.resetZoomTitle\n            }).addClass(\"highcharts-reset-zoom\").add().align(d.position, !1, g);\n          });\n          A(this, \"afterShowResetZoom\");\n        }\n      }, {\n        key: \"zoomOut\",\n        value: function zoomOut() {\n          A(this, \"selection\", {\n            resetSelection: !0\n          }, this.zoom);\n        }\n      }, {\n        key: \"zoom\",\n        value: function zoom(b) {\n          var a = this,\n            c = a.pointer;\n          var d = !1,\n            f;\n          !b || b.resetSelection ? (a.axes.forEach(function (b) {\n            f = b.zoom();\n          }), c.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {\n            var e = b.axis;\n            if (c[e.isXAxis ? \"zoomX\" : \"zoomY\"] && D(c.mouseDownX) && D(c.mouseDownY) && a.isInsidePlot(c.mouseDownX - a.plotLeft, c.mouseDownY - a.plotTop, {\n              axis: e\n            }) || !D(a.inverted ? c.mouseDownX : c.mouseDownY)) f = e.zoom(b.min, b.max), e.displayBtn && (d = !0);\n          });\n          var e = a.resetZoomButton;\n          d && !e ? a.showResetZoom() : !d && aa(e) && (a.resetZoomButton = e.destroy());\n          f && a.redraw(S(a.options.chart.animation, b && b.animation, 100 > a.pointCount));\n        }\n      }, {\n        key: \"pan\",\n        value: function pan(b, a) {\n          var c = this,\n            d = c.hoverPoints;\n          a = \"object\" === typeof a ? a : {\n            enabled: a,\n            type: \"x\"\n          };\n          var f = c.options.chart;\n          f && f.panning && (f.panning = a);\n          var e = a.type;\n          var g;\n          A(this, \"pan\", {\n            originalEvent: b\n          }, function () {\n            d && d.forEach(function (b) {\n              b.setState();\n            });\n            var a = c.xAxis;\n            \"xy\" === e ? a = a.concat(c.yAxis) : \"y\" === e && (a = c.yAxis);\n            var f = {};\n            a.forEach(function (a) {\n              if (a.options.panningEnabled && !a.options.isInternal) {\n                var d = a.horiz,\n                  k = b[d ? \"chartX\" : \"chartY\"];\n                d = d ? \"mouseDownX\" : \"mouseDownY\";\n                var h = c[d],\n                  n = a.minPointOffset || 0,\n                  l = a.reversed && !c.inverted || !a.reversed && c.inverted ? -1 : 1,\n                  m = a.getExtremes(),\n                  q = a.toValue(h - k, !0) + n * l,\n                  p = a.toValue(h + a.len - k, !0) - (n * l || a.isXAxis && a.pointRangePadding || 0),\n                  r = p < q;\n                l = a.hasVerticalPanning();\n                h = r ? p : q;\n                q = r ? q : p;\n                var t = a.panningState;\n                !l || a.isXAxis || t && !t.isDirty || a.series.forEach(function (b) {\n                  var a = b.getProcessedData(!0);\n                  a = b.getExtremes(a.yData, !0);\n                  t || (t = {\n                    startMin: Number.MAX_VALUE,\n                    startMax: -Number.MAX_VALUE\n                  });\n                  ba(a.dataMin) && ba(a.dataMax) && (t.startMin = Math.min(S(b.options.threshold, Infinity), a.dataMin, t.startMin), t.startMax = Math.max(S(b.options.threshold, -Infinity), a.dataMax, t.startMax));\n                });\n                l = Math.min(S(t && t.startMin, m.dataMin), n ? m.min : a.toValue(a.toPixels(m.min) - a.minPixelPadding));\n                p = Math.max(S(t && t.startMax, m.dataMax), n ? m.max : a.toValue(a.toPixels(m.max) + a.minPixelPadding));\n                a.panningState = t;\n                a.isOrdinal || (n = l - h, 0 < n && (q += n, h = l), n = q - p, 0 < n && (q = p, h -= n), a.series.length && h !== m.min && q !== m.max && h >= l && q <= p && (a.setExtremes(h, q, !1, !1, {\n                  trigger: \"pan\"\n                }), !c.resetZoomButton && h !== l && q !== p && e.match(\"y\") && (c.showResetZoom(), a.displayBtn = !1), g = !0), f[d] = k);\n              }\n            });\n            O(f, function (b, a) {\n              c[a] = b;\n            });\n            g && c.redraw(!1);\n            P(c.container, {\n              cursor: \"move\"\n            });\n          });\n        }\n      }]);\n      return ea;\n    }();\n    V(ea.prototype, {\n      callbacks: [],\n      collectionsWithInit: {\n        xAxis: [ea.prototype.addAxis, [!0]],\n        yAxis: [ea.prototype.addAxis, [!1]],\n        series: [ea.prototype.addSeries]\n      },\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"series\"],\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \")\n    });\n    \"\";\n    return ea;\n  });\n  M(a, \"Extensions/ScrollablePlotArea.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z) {\n    var x = a.stop,\n      B = z.addEvent,\n      u = z.createElement,\n      v = z.defined,\n      l = z.merge,\n      p = z.pick;\n    B(I, \"afterSetChartSize\", function (a) {\n      var m = this.options.chart.scrollablePlotArea,\n        h = m && m.minWidth;\n      m = m && m.minHeight;\n      var g;\n      if (!this.renderer.forExport) {\n        if (h) {\n          if (this.scrollablePixelsX = h = Math.max(0, h - this.chartWidth)) this.scrollablePlotBox = this.renderer.scrollablePlotBox = l(this.plotBox), this.plotBox.width = this.plotWidth += h, this.inverted ? this.clipBox.height += h : this.clipBox.width += h, g = {\n            1: {\n              name: \"right\",\n              value: h\n            }\n          };\n        } else m && (this.scrollablePixelsY = h = Math.max(0, m - this.chartHeight), v(h) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = l(this.plotBox), this.plotBox.height = this.plotHeight += h, this.inverted ? this.clipBox.width += h : this.clipBox.height += h, g = {\n          2: {\n            name: \"bottom\",\n            value: h\n          }\n        }));\n        g && !a.skipAxes && this.axes.forEach(function (a) {\n          g[a.side] ? a.getPlotLinePath = function () {\n            var e = g[a.side].name,\n              h = this[e],\n              l;\n            this[e] = h - g[a.side].value;\n            l = y.prototype.getPlotLinePath.apply(this, arguments);\n            this[e] = h;\n            return l;\n          } : (a.setAxisSize(), a.setAxisTranslation());\n        });\n      }\n    });\n    B(I, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n    I.prototype.setUpScrolling = function () {\n      var _this14 = this;\n      var a = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (a.overflowX = \"auto\");\n      this.scrollablePixelsY && (a.overflowY = \"auto\");\n      this.scrollingParent = u(\"div\", {\n        className: \"highcharts-scrolling-parent\"\n      }, {\n        position: \"relative\"\n      }, this.renderTo);\n      this.scrollingContainer = u(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, a, this.scrollingParent);\n      var l;\n      B(this.scrollingContainer, \"scroll\", function () {\n        _this14.pointer && (delete _this14.pointer.chartPosition, _this14.hoverPoint && (l = _this14.hoverPoint), _this14.pointer.runPointActions(void 0, l, !0));\n      });\n      this.innerContainer = u(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n    I.prototype.moveFixedElements = function () {\n      var a = this.container,\n        l = this.fixedRenderer,\n        h = \".highcharts-breadcrumbs-group .highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title\".split(\" \"),\n        g;\n      this.scrollablePixelsX && !this.inverted ? g = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? g = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? g = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (g = \".highcharts-yaxis\");\n      g && h.push(\"\".concat(g, \":not(.highcharts-radial-axis)\"), \"\".concat(g, \"-labels:not(.highcharts-radial-axis-labels)\"));\n      h.forEach(function (e) {\n        [].forEach.call(a.querySelectorAll(e), function (a) {\n          (a.namespaceURI === l.SVG_NS ? l.box : l.box.parentNode).appendChild(a);\n          a.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n    I.prototype.applyFixed = function () {\n      var a = !this.fixedDiv,\n        l = this.options.chart,\n        h = l.scrollablePlotArea,\n        g = C.getRendererType();\n      a ? (this.fixedDiv = u(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: (l.style && l.style.zIndex || 0) + 2,\n        top: 0\n      }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = l = new g(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = l.path().attr({\n        fill: this.options.chart.backgroundColor || \"#fff\",\n        \"fill-opacity\": p(h.opacity, .85),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), B(this, \"afterShowResetZoom\", this.moveFixedElements), B(this, \"afterApplyDrilldown\", this.moveFixedElements), B(this, \"afterLayOutTitles\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      if (this.scrollableDirty || a) this.scrollableDirty = !1, this.moveFixedElements();\n      l = this.chartWidth + (this.scrollablePixelsX || 0);\n      g = this.chartHeight + (this.scrollablePixelsY || 0);\n      x(this.container);\n      this.container.style.width = l + \"px\";\n      this.container.style.height = g + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: l,\n        height: g,\n        viewBox: [0, 0, l, g].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: l,\n        height: g\n      });\n      this.scrollingContainer.style.height = this.chartHeight + \"px\";\n      a && (h.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * h.scrollPositionX), h.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * h.scrollPositionY));\n      g = this.axisOffset;\n      a = this.plotTop - g[0] - 1;\n      h = this.plotLeft - g[3] - 1;\n      l = this.plotTop + this.plotHeight + g[2] + 1;\n      g = this.plotLeft + this.plotWidth + g[1] + 1;\n      var e = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n        w = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);\n      a = this.scrollablePixelsX ? [[\"M\", 0, a], [\"L\", this.plotLeft - 1, a], [\"L\", this.plotLeft - 1, l], [\"L\", 0, l], [\"Z\"], [\"M\", e, a], [\"L\", this.chartWidth, a], [\"L\", this.chartWidth, l], [\"L\", e, l], [\"Z\"]] : this.scrollablePixelsY ? [[\"M\", h, 0], [\"L\", h, this.plotTop - 1], [\"L\", g, this.plotTop - 1], [\"L\", g, 0], [\"Z\"], [\"M\", h, w], [\"L\", h, this.chartHeight], [\"L\", g, this.chartHeight], [\"L\", g, w], [\"Z\"]] : [[\"M\", 0, 0]];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: a\n      });\n    };\n    B(y, \"afterInit\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    B(L, \"show\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    \"\";\n  });\n  M(a, \"Core/Axis/Stacking/StackItem.js\", [a[\"Core/Templating.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    var x = a.format,\n      C = y.series,\n      z = I.destroyObjectProperties,\n      H = I.fireEvent,\n      B = I.isNumber,\n      u = I.pick;\n    var v = /*#__PURE__*/function () {\n      function v(a, p, t, m, h) {\n        _classCallCheck(this, v);\n        var g = a.chart.inverted,\n          e = a.reversed;\n        this.axis = a;\n        a = this.isNegative = !!t !== !!e;\n        this.options = p = p || {};\n        this.x = m;\n        this.cumulative = this.total = null;\n        this.points = {};\n        this.hasValidPoints = !1;\n        this.stack = h;\n        this.rightCliff = this.leftCliff = 0;\n        this.alignOptions = {\n          align: p.align || (g ? a ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: p.verticalAlign || (g ? \"middle\" : a ? \"bottom\" : \"top\"),\n          y: p.y,\n          x: p.x\n        };\n        this.textAlign = p.textAlign || (g ? a ? \"right\" : \"left\" : \"center\");\n      }\n      _createClass(v, [{\n        key: \"destroy\",\n        value: function destroy() {\n          z(this, this.axis);\n        }\n      }, {\n        key: \"render\",\n        value: function render(a) {\n          var l = this.axis.chart,\n            t = this.options;\n          var m = t.format;\n          m = m ? x(m, this, l) : t.formatter.call(this);\n          this.label ? this.label.attr({\n            text: m,\n            visibility: \"hidden\"\n          }) : (this.label = l.renderer.label(m, null, void 0, t.shape, void 0, void 0, t.useHTML, !1, \"stack-labels\"), m = {\n            r: t.borderRadius || 0,\n            text: m,\n            padding: u(t.padding, 5),\n            visibility: \"hidden\"\n          }, l.styledMode || (m.fill = t.backgroundColor, m.stroke = t.borderColor, m[\"stroke-width\"] = t.borderWidth, this.label.css(t.style || {})), this.label.attr(m), this.label.added || this.label.add(a));\n          this.label.labelrank = l.plotSizeY;\n          H(this, \"afterRender\");\n        }\n      }, {\n        key: \"setOffset\",\n        value: function setOffset(a, p, t, m, h, g) {\n          var e = this.alignOptions,\n            l = this.axis,\n            v = this.label,\n            x = this.options,\n            d = this.textAlign,\n            k = l.chart;\n          t = this.getStackBox({\n            xOffset: a,\n            width: p,\n            boxBottom: t,\n            boxTop: m,\n            defaultX: h,\n            xAxis: g\n          });\n          var r = e.verticalAlign;\n          if (v && t) {\n            m = v.getBBox();\n            h = v.padding;\n            g = \"justify\" === u(x.overflow, \"justify\");\n            e.x = x.x || 0;\n            e.y = x.y || 0;\n            var _this$adjustStackPosi = this.adjustStackPosition({\n                labelBox: m,\n                verticalAlign: r,\n                textAlign: d\n              }),\n              _a18 = _this$adjustStackPosi.x,\n              _p2 = _this$adjustStackPosi.y;\n            t.x -= _a18;\n            t.y -= _p2;\n            v.align(e, !1, t);\n            (r = k.isInsidePlot(v.alignAttr.x + e.x + _a18, v.alignAttr.y + e.y + _p2)) || (g = !1);\n            g && C.prototype.justifyDataLabel.call(l, v, e, v.alignAttr, m, t);\n            v.attr({\n              x: v.alignAttr.x,\n              y: v.alignAttr.y,\n              rotation: x.rotation,\n              rotationOriginX: m.width / 2,\n              rotationOriginY: m.height / 2\n            });\n            u(!g && x.crop, !0) && (r = B(v.x) && B(v.y) && k.isInsidePlot(v.x - h + v.width, v.y) && k.isInsidePlot(v.x + h, v.y));\n            v[r ? \"show\" : \"hide\"]();\n          }\n          H(this, \"afterSetOffset\", {\n            xOffset: a,\n            width: p\n          });\n        }\n      }, {\n        key: \"adjustStackPosition\",\n        value: function adjustStackPosition(_ref3) {\n          var a = _ref3.labelBox,\n            p = _ref3.verticalAlign,\n            t = _ref3.textAlign;\n          var l = {\n            bottom: 0,\n            middle: 1,\n            top: 2,\n            right: 1,\n            center: 0,\n            left: -1\n          };\n          return {\n            x: a.width / 2 + a.width / 2 * l[t],\n            y: a.height / 2 * l[p]\n          };\n        }\n      }, {\n        key: \"getStackBox\",\n        value: function getStackBox(a) {\n          var l = this.axis;\n          var t = l.chart,\n            _a19 = a,\n            m = _a19.boxTop,\n            h = _a19.defaultX,\n            g = _a19.xOffset,\n            e = _a19.width,\n            w = _a19.boxBottom;\n          var v = l.stacking.usePercentage ? 100 : u(m, this.total, 0);\n          v = l.toPixels(v);\n          a = a.xAxis || t.xAxis[0];\n          var x = u(h, a.translate(this.x)) + g;\n          l = l.toPixels(w || B(l.min) && l.logarithmic && l.logarithmic.lin2log(l.min) || 0);\n          l = Math.abs(v - l);\n          var d = this.isNegative;\n          return t.inverted ? {\n            x: (d ? v : v - l) - t.plotLeft,\n            y: a.height - x - e,\n            width: l,\n            height: e\n          } : {\n            x: x + a.transB - t.plotLeft,\n            y: (d ? v - l : v) - t.plotTop,\n            width: e,\n            height: l\n          };\n        }\n      }]);\n      return v;\n    }();\n    \"\";\n    return v;\n  });\n  M(a, \"Core/Axis/Stacking/StackingAxis.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Axis/Stacking/StackItem.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C) {\n    function x() {\n      var b = this,\n        a = b.inverted;\n      b.yAxis.forEach(function (b) {\n        b.stacking && b.stacking.stacks && b.hasVisibleSeries && (b.stacking.oldStacks = b.stacking.stacks);\n      });\n      b.series.forEach(function (c) {\n        var d = c.xAxis && c.xAxis.options || {};\n        !c.options.stacking || !0 !== c.visible && !1 !== b.options.chart.ignoreHiddenSeries || (c.stackKey = [c.type, q(c.options.stack, \"\"), a ? d.top : d.left, a ? d.height : d.width].join());\n      });\n    }\n    function H() {\n      var b = this.stacking;\n      if (b) {\n        var a = b.stacks;\n        r(a, function (b, c) {\n          E(b);\n          a[c] = null;\n        });\n        b && b.stackTotalGroup && b.stackTotalGroup.destroy();\n      }\n    }\n    function B() {\n      \"yAxis\" !== this.coll || this.stacking || (this.stacking = new G(this));\n    }\n    function u(b, a, d, e) {\n      !w(b) || b.x !== a || e && b.stackKey !== e ? b = {\n        x: a,\n        index: 0,\n        key: e,\n        stackKey: e\n      } : b.index++;\n      b.key = [d, a, b.index].join();\n      return b;\n    }\n    function v() {\n      var b = this,\n        a = b.stackKey,\n        d = b.yAxis.stacking.stacks,\n        e = b.processedXData,\n        g = b[b.options.stacking + \"Stacker\"];\n      var k;\n      g && [a, \"-\" + a].forEach(function (a) {\n        var c = e.length;\n        var f;\n        for (; c--;) {\n          var h = e[c];\n          k = b.getStackIndicator(k, h, b.index, a);\n          (f = (h = d[a] && d[a][h]) && h.points[k.key]) && g.call(b, f, h, c);\n        }\n      });\n    }\n    function l(b, a, d) {\n      a = a.total ? 100 / a.total : 0;\n      b[0] = e(b[0] * a);\n      b[1] = e(b[1] * a);\n      this.stackedYData[d] = b[1];\n    }\n    function p() {\n      var b = this.yAxis.stacking;\n      this.options.centerInCategory && (this.is(\"column\") || this.is(\"columnrange\")) && !this.options.stacking && 1 < this.chart.series.length ? h.setStackedPoints.call(this, \"group\") : b && r(b.stacks, function (a, d) {\n        \"group\" === d.slice(-5) && (r(a, function (b) {\n          return b.destroy();\n        }), delete b.stacks[d]);\n      });\n    }\n    function t(b) {\n      var a = this.chart;\n      var f = b || this.options.stacking;\n      if (f && (!0 === this.visible || !1 === a.options.chart.ignoreHiddenSeries)) {\n        var g = this.processedXData,\n          k = this.processedYData,\n          h = [],\n          l = k.length,\n          m = this.options,\n          p = m.threshold,\n          r = q(m.startFromThreshold && p, 0);\n        m = m.stack;\n        b = b ? \"\".concat(this.type, \",\").concat(f) : this.stackKey;\n        var t = \"-\" + b,\n          v = this.negStacks;\n        a = \"group\" === f ? a.yAxis[0] : this.yAxis;\n        var u = a.stacking.stacks,\n          x = a.stacking.oldStacks,\n          E,\n          G;\n        a.stacking.stacksTouched += 1;\n        for (G = 0; G < l; G++) {\n          var F = g[G];\n          var B = k[G];\n          var y = this.getStackIndicator(y, F, this.index);\n          var C = y.key;\n          var z = (E = v && B < (r ? 0 : p)) ? t : b;\n          u[z] || (u[z] = {});\n          u[z][F] || (x[z] && x[z][F] ? (u[z][F] = x[z][F], u[z][F].total = null) : u[z][F] = new L(a, a.options.stackLabels, !!E, F, m));\n          z = u[z][F];\n          null !== B ? (z.points[C] = z.points[this.index] = [q(z.cumulative, r)], w(z.cumulative) || (z.base = C), z.touched = a.stacking.stacksTouched, 0 < y.index && !1 === this.singleStacks && (z.points[C][0] = z.points[this.index + \",\" + F + \",0\"][0])) : z.points[C] = z.points[this.index] = null;\n          \"percent\" === f ? (E = E ? b : t, v && u[E] && u[E][F] ? (E = u[E][F], z.total = E.total = Math.max(E.total, z.total) + Math.abs(B) || 0) : z.total = e(z.total + (Math.abs(B) || 0))) : \"group\" === f ? (d(B) && (B = B[0]), null !== B && (z.total = (z.total || 0) + 1)) : z.total = e(z.total + (B || 0));\n          z.cumulative = \"group\" === f ? (z.total || 1) - 1 : e(q(z.cumulative, r) + (B || 0));\n          null !== B && (z.points[C].push(z.cumulative), h[G] = z.cumulative, z.hasValidPoints = !0);\n        }\n        \"percent\" === f && (a.stacking.usePercentage = !0);\n        \"group\" !== f && (this.stackedYData = h);\n        a.stacking.oldStacks = {};\n      }\n    }\n    var m = a.getDeferredAnimation,\n      h = I.series.prototype,\n      g = C.addEvent,\n      e = C.correctFloat,\n      w = C.defined,\n      E = C.destroyObjectProperties,\n      F = C.fireEvent,\n      d = C.isArray,\n      k = C.isNumber,\n      r = C.objectEach,\n      q = C.pick;\n    var G = /*#__PURE__*/function () {\n      function G(b) {\n        _classCallCheck(this, G);\n        this.oldStacks = {};\n        this.stacks = {};\n        this.stacksTouched = 0;\n        this.axis = b;\n      }\n      _createClass(G, [{\n        key: \"buildStacks\",\n        value: function buildStacks() {\n          var b = this.axis,\n            a = b.series,\n            d = b.options.reversedStacks,\n            e = a.length;\n          var g, k;\n          this.usePercentage = !1;\n          for (k = e; k--;) g = a[d ? k : e - k - 1], g.setStackedPoints(), g.setGroupedPoints();\n          for (k = 0; k < e; k++) a[k].modifyStacks();\n          F(b, \"afterBuildStacks\");\n        }\n      }, {\n        key: \"cleanStacks\",\n        value: function cleanStacks() {\n          var b;\n          this.oldStacks && (b = this.stacks = this.oldStacks);\n          r(b, function (b) {\n            r(b, function (b) {\n              b.cumulative = b.total;\n            });\n          });\n        }\n      }, {\n        key: \"resetStacks\",\n        value: function resetStacks() {\n          var _this15 = this;\n          r(this.stacks, function (b) {\n            r(b, function (a, d) {\n              k(a.touched) && a.touched < _this15.stacksTouched ? (a.destroy(), delete b[d]) : (a.total = null, a.cumulative = null);\n            });\n          });\n        }\n      }, {\n        key: \"renderStackTotals\",\n        value: function renderStackTotals() {\n          var b = this.axis;\n          var a = b.chart,\n            d = a.renderer,\n            e = this.stacks;\n          b = m(a, b.options.stackLabels && b.options.stackLabels.animation || !1);\n          var g = this.stackTotalGroup = this.stackTotalGroup || d.g(\"stack-labels\").attr({\n            zIndex: 6,\n            opacity: 0\n          }).add();\n          g.translate(a.plotLeft, a.plotTop);\n          r(e, function (b) {\n            r(b, function (b) {\n              b.render(g);\n            });\n          });\n          g.animate({\n            opacity: 1\n          }, b);\n        }\n      }]);\n      return G;\n    }();\n    var b;\n    (function (b) {\n      var a = [];\n      b.compose = function (b, c, d) {\n        C.pushUnique(a, b) && (g(b, \"init\", B), g(b, \"destroy\", H));\n        C.pushUnique(a, c) && (c.prototype.getStacks = x);\n        C.pushUnique(a, d) && (b = d.prototype, b.getStackIndicator = u, b.modifyStacks = v, b.percentStacker = l, b.setGroupedPoints = p, b.setStackedPoints = t);\n      };\n    })(b || (b = {}));\n    return b;\n  });\n  M(a, \"Series/Line/LineSeries.js\", [a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    var x = I.defined,\n      C = I.merge;\n    var z = /*#__PURE__*/function (_a20) {\n      _inherits(z, _a20);\n      function z() {\n        var _this16;\n        _classCallCheck(this, z);\n        _this16 = _possibleConstructorReturn(this, _getPrototypeOf(z).apply(this, arguments));\n        _this16.points = _this16.options = _this16.data = void 0;\n        return _this16;\n      }\n      _createClass(z, [{\n        key: \"drawGraph\",\n        value: function drawGraph() {\n          var a = this,\n            x = this.options,\n            u = (this.gappedPath || this.getGraphPath).call(this),\n            v = this.chart.styledMode;\n          var l = [[\"graph\", \"highcharts-graph\"]];\n          v || l[0].push(x.lineColor || this.color || \"#cccccc\", x.dashStyle);\n          l = a.getZonesGraphs(l);\n          l.forEach(function (l, t) {\n            var m = l[0];\n            var h = a[m];\n            var g = h ? \"animate\" : \"attr\";\n            h ? (h.endX = a.preventGraphAnimation ? null : u.xMap, h.animate({\n              d: u\n            })) : u.length && (a[m] = h = a.chart.renderer.path(u).addClass(l[1]).attr({\n              zIndex: 1\n            }).add(a.group));\n            h && !v && (m = {\n              stroke: l[2],\n              \"stroke-width\": x.lineWidth || 0,\n              fill: a.fillGraph && a.color || \"none\"\n            }, l[3] ? m.dashstyle = l[3] : \"square\" !== x.linecap && (m[\"stroke-linecap\"] = m[\"stroke-linejoin\"] = \"round\"), h[g](m).shadow(2 > t && x.shadow));\n            h && (h.startX = u.xMap, h.isArea = u.isArea);\n          });\n        }\n      }, {\n        key: \"getGraphPath\",\n        value: function getGraphPath(a, B, u) {\n          var v = this,\n            l = v.options,\n            p = [],\n            t = [];\n          var m,\n            h = l.step;\n          a = a || v.points;\n          var g = a.reversed;\n          g && a.reverse();\n          (h = {\n            right: 1,\n            center: 2\n          }[h] || h && 3) && g && (h = 4 - h);\n          a = this.getValidPoints(a, !1, !(l.connectNulls && !B && !u));\n          a.forEach(function (e, g) {\n            var w = e.plotX,\n              F = e.plotY,\n              d = a[g - 1],\n              k = e.isNull || \"number\" !== typeof F;\n            (e.leftCliff || d && d.rightCliff) && !u && (m = !0);\n            k && !x(B) && 0 < g ? m = !l.connectNulls : k && !B ? m = !0 : (0 === g || m ? g = [[\"M\", e.plotX, e.plotY]] : v.getPointSpline ? g = [v.getPointSpline(a, e, g)] : h ? (g = 1 === h ? [[\"L\", d.plotX, F]] : 2 === h ? [[\"L\", (d.plotX + w) / 2, d.plotY], [\"L\", (d.plotX + w) / 2, F]] : [[\"L\", w, d.plotY]], g.push([\"L\", w, F])) : g = [[\"L\", w, F]], t.push(e.x), h && (t.push(e.x), 2 === h && t.push(e.x)), p.push.apply(p, g), m = !1);\n          });\n          p.xMap = t;\n          return v.graphPath = p;\n        }\n      }, {\n        key: \"getZonesGraphs\",\n        value: function getZonesGraphs(a) {\n          this.zones.forEach(function (x, u) {\n            u = [\"zone-graph-\" + u, \"highcharts-graph highcharts-zone-graph-\" + u + \" \" + (x.className || \"\")];\n            this.chart.styledMode || u.push(x.color || this.color, x.dashStyle || this.options.dashStyle);\n            a.push(u);\n          }, this);\n          return a;\n        }\n      }]);\n      return z;\n    }(a);\n    z.defaultOptions = C(a.defaultOptions, {\n      legendSymbol: \"lineMarker\"\n    });\n    y.registerSeriesType(\"line\", z);\n    \"\";\n    return z;\n  });\n  M(a, \"Series/Area/AreaSeries.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    var x = y.seriesTypes.line,\n      C = I.extend,\n      z = I.merge,\n      H = I.objectEach,\n      B = I.pick;\n    var u = /*#__PURE__*/function (_x3) {\n      _inherits(u, _x3);\n      function u() {\n        var _this17;\n        _classCallCheck(this, u);\n        _this17 = _possibleConstructorReturn(this, _getPrototypeOf(u).apply(this, arguments));\n        _this17.points = _this17.options = _this17.data = void 0;\n        return _this17;\n      }\n      _createClass(u, [{\n        key: \"drawGraph\",\n        value: function drawGraph() {\n          this.areaPath = [];\n          _get(_getPrototypeOf(u.prototype), \"drawGraph\", this).apply(this);\n          var a = this,\n            l = this.areaPath,\n            p = this.options,\n            t = [[\"area\", \"highcharts-area\", this.color, p.fillColor]];\n          this.zones.forEach(function (l, h) {\n            t.push([\"zone-area-\" + h, \"highcharts-area highcharts-zone-area-\" + h + \" \" + l.className, l.color || a.color, l.fillColor || p.fillColor]);\n          });\n          t.forEach(function (m) {\n            var h = m[0],\n              g = {};\n            var e = a[h];\n            var t = e ? \"animate\" : \"attr\";\n            e ? (e.endX = a.preventGraphAnimation ? null : l.xMap, e.animate({\n              d: l\n            })) : (g.zIndex = 0, e = a[h] = a.chart.renderer.path(l).addClass(m[1]).add(a.group), e.isArea = !0);\n            a.chart.styledMode || (m[3] ? g.fill = m[3] : (g.fill = m[2], g[\"fill-opacity\"] = B(p.fillOpacity, .75)));\n            e[t](g);\n            e.startX = l.xMap;\n            e.shiftUnit = p.step ? 2 : 1;\n          });\n        }\n      }, {\n        key: \"getGraphPath\",\n        value: function getGraphPath(a) {\n          var l = x.prototype.getGraphPath,\n            p = this.options;\n          var t = p.stacking,\n            m = this.yAxis,\n            h = [],\n            g = [],\n            e = this.index,\n            w = m.stacking.stacks[this.stackKey],\n            v = p.threshold,\n            u = Math.round(m.getThreshold(p.threshold));\n          p = B(p.connectNulls, \"percent\" === t);\n          var d = function d(_d12, b, f) {\n            var c = a[_d12];\n            _d12 = t && w[c.x].points[e];\n            var n = c[f + \"Null\"] || 0;\n            f = c[f + \"Cliff\"] || 0;\n            var l, q;\n            c = !0;\n            f || n ? (l = (n ? _d12[0] : _d12[1]) + f, q = _d12[0] + f, c = !!n) : !t && a[b] && a[b].isNull && (l = q = v);\n            \"undefined\" !== typeof l && (g.push({\n              plotX: k,\n              plotY: null === l ? u : m.getThreshold(l),\n              isNull: c,\n              isCliff: !0\n            }), h.push({\n              plotX: k,\n              plotY: null === q ? u : m.getThreshold(q),\n              doCurve: !1\n            }));\n          };\n          var k;\n          a = a || this.points;\n          t && (a = this.getStackPoints(a));\n          for (var _e6 = 0, b = a.length; _e6 < b; ++_e6) {\n            t || (a[_e6].leftCliff = a[_e6].rightCliff = a[_e6].leftNull = a[_e6].rightNull = void 0);\n            var r = a[_e6].isNull;\n            k = B(a[_e6].rectPlotX, a[_e6].plotX);\n            var q = t ? B(a[_e6].yBottom, u) : u;\n            if (!r || p) p || d(_e6, _e6 - 1, \"left\"), r && !t && p || (g.push(a[_e6]), h.push({\n              x: _e6,\n              plotX: k,\n              plotY: q\n            })), p || d(_e6, _e6 + 1, \"right\");\n          }\n          d = l.call(this, g, !0, !0);\n          h.reversed = !0;\n          r = l.call(this, h, !0, !0);\n          (q = r[0]) && \"M\" === q[0] && (r[0] = [\"L\", q[1], q[2]]);\n          r = d.concat(r);\n          r.length && r.push([\"Z\"]);\n          l = l.call(this, g, !1, p);\n          r.xMap = d.xMap;\n          this.areaPath = r;\n          return l;\n        }\n      }, {\n        key: \"getStackPoints\",\n        value: function getStackPoints(a) {\n          var l = this,\n            p = [],\n            t = [],\n            m = this.xAxis,\n            h = this.yAxis,\n            g = h.stacking.stacks[this.stackKey],\n            e = {},\n            w = h.series,\n            v = w.length,\n            u = h.options.reversedStacks ? 1 : -1,\n            d = w.indexOf(l);\n          a = a || this.points;\n          if (this.options.stacking) {\n            for (var _d13 = 0; _d13 < a.length; _d13++) a[_d13].leftNull = a[_d13].rightNull = void 0, e[a[_d13].x] = a[_d13];\n            H(g, function (a, d) {\n              null !== a.total && t.push(d);\n            });\n            t.sort(function (a, d) {\n              return a - d;\n            });\n            var k = w.map(function (a) {\n              return a.visible;\n            });\n            t.forEach(function (a, q) {\n              var r = 0,\n                b,\n                f;\n              if (e[a] && !e[a].isNull) p.push(e[a]), [-1, 1].forEach(function (c) {\n                var h = 1 === c ? \"rightNull\" : \"leftNull\",\n                  m = g[t[q + c]];\n                var p = 0;\n                if (m) {\n                  var _c16 = d;\n                  for (; 0 <= _c16 && _c16 < v;) {\n                    var _d14 = w[_c16].index;\n                    b = m.points[_d14];\n                    b || (_d14 === l.index ? e[a][h] = !0 : k[_c16] && (f = g[a].points[_d14]) && (p -= f[1] - f[0]));\n                    _c16 += u;\n                  }\n                }\n                e[a][1 === c ? \"rightCliff\" : \"leftCliff\"] = p;\n              });else {\n                var c = d;\n                for (; 0 <= c && c < v;) {\n                  if (b = g[a].points[w[c].index]) {\n                    r = b[1];\n                    break;\n                  }\n                  c += u;\n                }\n                r = B(r, 0);\n                r = h.translate(r, 0, 1, 0, 1);\n                p.push({\n                  isNull: !0,\n                  plotX: m.translate(a, 0, 0, 0, 1),\n                  x: a,\n                  plotY: r,\n                  yBottom: r\n                });\n              }\n            });\n          }\n          return p;\n        }\n      }]);\n      return u;\n    }(x);\n    u.defaultOptions = z(x.defaultOptions, {\n      threshold: 0,\n      legendSymbol: \"rectangle\"\n    });\n    C(u.prototype, {\n      singleStacks: !1\n    });\n    y.registerSeriesType(\"area\", u);\n    \"\";\n    return u;\n  });\n  M(a, \"Series/Spline/SplineSeries.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    var x = a.seriesTypes.line,\n      L = y.merge,\n      C = y.pick;\n    var z = /*#__PURE__*/function (_x4) {\n      _inherits(z, _x4);\n      function z() {\n        var _this18;\n        _classCallCheck(this, z);\n        _this18 = _possibleConstructorReturn(this, _getPrototypeOf(z).apply(this, arguments));\n        _this18.points = _this18.options = _this18.data = void 0;\n        return _this18;\n      }\n      _createClass(z, [{\n        key: \"getPointSpline\",\n        value: function getPointSpline(a, x, u) {\n          var v = x.plotX || 0,\n            l = x.plotY || 0,\n            p = a[u - 1];\n          u = a[u + 1];\n          var t, m;\n          var h;\n          if (p && !p.isNull && !1 !== p.doCurve && !x.isCliff && u && !u.isNull && !1 !== u.doCurve && !x.isCliff) {\n            a = p.plotY || 0;\n            var g = u.plotX || 0;\n            u = u.plotY || 0;\n            var e = 0;\n            t = (1.5 * v + (p.plotX || 0)) / 2.5;\n            m = (1.5 * l + a) / 2.5;\n            g = (1.5 * v + g) / 2.5;\n            h = (1.5 * l + u) / 2.5;\n            g !== t && (e = (h - m) * (g - v) / (g - t) + l - h);\n            m += e;\n            h += e;\n            m > a && m > l ? (m = Math.max(a, l), h = 2 * l - m) : m < a && m < l && (m = Math.min(a, l), h = 2 * l - m);\n            h > u && h > l ? (h = Math.max(u, l), m = 2 * l - h) : h < u && h < l && (h = Math.min(u, l), m = 2 * l - h);\n            x.rightContX = g;\n            x.rightContY = h;\n          }\n          x = [\"C\", C(p.rightContX, p.plotX, 0), C(p.rightContY, p.plotY, 0), C(t, v, 0), C(m, l, 0), v, l];\n          p.rightContX = p.rightContY = void 0;\n          return x;\n        }\n      }]);\n      return z;\n    }(x);\n    z.defaultOptions = L(x.defaultOptions);\n    a.registerSeriesType(\"spline\", z);\n    \"\";\n    return z;\n  });\n  M(a, \"Series/AreaSpline/AreaSplineSeries.js\", [a[\"Series/Spline/SplineSeries.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    var _y$seriesTypes = y.seriesTypes,\n      x = _y$seriesTypes.area,\n      C = _y$seriesTypes.area.prototype,\n      z = I.extend,\n      H = I.merge;\n    var B = /*#__PURE__*/function (_a21) {\n      _inherits(B, _a21);\n      function B() {\n        var _this19;\n        _classCallCheck(this, B);\n        _this19 = _possibleConstructorReturn(this, _getPrototypeOf(B).apply(this, arguments));\n        _this19.options = _this19.points = _this19.data = void 0;\n        return _this19;\n      }\n      return B;\n    }(a);\n    B.defaultOptions = H(a.defaultOptions, x.defaultOptions);\n    z(B.prototype, {\n      getGraphPath: C.getGraphPath,\n      getStackPoints: C.getStackPoints,\n      drawGraph: C.drawGraph\n    });\n    y.registerSeriesType(\"areaspline\", B);\n    \"\";\n    return B;\n  });\n  M(a, \"Series/Column/ColumnSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      borderRadius: 3,\n      centerInCategory: !1,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        y: void 0\n      },\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    };\n  });\n  M(a, \"Series/Column/ColumnSeries.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Color/Color.js\"], a[\"Series/Column/ColumnSeriesDefaults.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z, H) {\n    var x = a.animObject,\n      u = y.parse,\n      v = L.hasTouch,\n      l = L.noop,\n      p = H.clamp,\n      t = H.defined,\n      m = H.extend,\n      h = H.fireEvent,\n      g = H.isArray,\n      e = H.isNumber,\n      w = H.merge,\n      E = H.pick,\n      F = H.objectEach;\n    var d = /*#__PURE__*/function (_C) {\n      _inherits(d, _C);\n      function d() {\n        var _this20;\n        _classCallCheck(this, d);\n        _this20 = _possibleConstructorReturn(this, _getPrototypeOf(d).apply(this, arguments));\n        _this20.points = _this20.options = _this20.group = _this20.data = _this20.borderWidth = void 0;\n        return _this20;\n      }\n      _createClass(d, [{\n        key: \"animate\",\n        value: function animate(a) {\n          var d = this,\n            e = this.yAxis,\n            g = e.pos,\n            b = d.options,\n            f = this.chart.inverted,\n            c = {},\n            k = f ? \"translateX\" : \"translateY\";\n          var h;\n          a ? (c.scaleY = .001, a = p(e.toPixels(b.threshold), g, g + e.len), f ? c.translateX = a - e.len : c.translateY = a, d.clipBox && d.setClip(), d.group.attr(c)) : (h = Number(d.group.attr(k)), d.group.animate({\n            scaleY: 1\n          }, m(x(d.options.animation), {\n            step: function step(b, a) {\n              d.group && (c[k] = h + a.pos * (g - h), d.group.attr(c));\n            }\n          })));\n        }\n      }, {\n        key: \"init\",\n        value: function init(a, d) {\n          _get(_getPrototypeOf(d.prototype), \"init\", this).apply(this, arguments);\n          var e = this;\n          a = e.chart;\n          a.hasRendered && a.series.forEach(function (a) {\n            a.type === e.type && (a.isDirty = !0);\n          });\n        }\n      }, {\n        key: \"getColumnMetrics\",\n        value: function getColumnMetrics() {\n          var a = this;\n          var d = a.options;\n          var e = a.xAxis,\n            g = a.yAxis;\n          var b = e.options.reversedStacks;\n          b = e.reversed && !b || !e.reversed && b;\n          var f = {};\n          var c,\n            h = 0;\n          !1 === d.grouping ? h = 1 : a.chart.series.forEach(function (b) {\n            var d = b.yAxis,\n              e = b.options;\n            var k;\n            b.type !== a.type || !b.visible && a.chart.options.chart.ignoreHiddenSeries || g.len !== d.len || g.pos !== d.pos || (e.stacking && \"group\" !== e.stacking ? (c = b.stackKey, \"undefined\" === typeof f[c] && (f[c] = h++), k = f[c]) : !1 !== e.grouping && (k = h++), b.columnIndex = k);\n          });\n          var l = Math.min(Math.abs(e.transA) * (e.ordinal && e.ordinal.slope || d.pointRange || e.closestPointRange || e.tickInterval || 1), e.len),\n            m = l * d.groupPadding,\n            p = (l - 2 * m) / (h || 1);\n          d = Math.min(d.maxPointWidth || e.len, E(d.pointWidth, p * (1 - 2 * d.pointPadding)));\n          a.columnMetrics = {\n            width: d,\n            offset: (p - d) / 2 + (m + ((a.columnIndex || 0) + (b ? 1 : 0)) * p - l / 2) * (b ? -1 : 1),\n            paddedWidth: p,\n            columnCount: h\n          };\n          return a.columnMetrics;\n        }\n      }, {\n        key: \"crispCol\",\n        value: function crispCol(a, d, e, g) {\n          var b = this.borderWidth,\n            f = -(b % 2 ? .5 : 0);\n          b = b % 2 ? .5 : 1;\n          this.options.crisp && (e = Math.round(a + e) + f, a = Math.round(a) + f, e -= a);\n          g = Math.round(d + g) + b;\n          f = .5 >= Math.abs(d) && .5 < g;\n          d = Math.round(d) + b;\n          g -= d;\n          f && g && (--d, g += 1);\n          return {\n            x: a,\n            y: d,\n            width: e,\n            height: g\n          };\n        }\n      }, {\n        key: \"adjustForMissingColumns\",\n        value: function adjustForMissingColumns(a, d, e, h) {\n          var _this21 = this;\n          var b = this.options.stacking;\n          if (!e.isNull && 1 < h.columnCount) {\n            var f = this.yAxis.options.reversedStacks;\n            var c = 0,\n              k = f ? 0 : -h.columnCount;\n            F(this.yAxis.stacking && this.yAxis.stacking.stacks, function (a) {\n              if (\"number\" === typeof e.x) {\n                var _d15 = a[e.x.toString()];\n                _d15 && (a = _d15.points[_this21.index], b ? (a && (c = k), _d15.hasValidPoints && (f ? k++ : k--)) : g(a) && (a = Object.keys(_d15.points).filter(function (b) {\n                  return !b.match(\",\") && _d15.points[b] && 1 < _d15.points[b].length;\n                }).map(parseFloat).sort(function (b, a) {\n                  return a - b;\n                }), c = a.indexOf(_this21.index), k = a.length));\n              }\n            });\n            a = (e.plotX || 0) + ((k - 1) * h.paddedWidth + d) / 2 - d - c * h.paddedWidth;\n          }\n          return a;\n        }\n      }, {\n        key: \"translate\",\n        value: function translate() {\n          var a = this,\n            d = a.chart,\n            g = a.options;\n          var l = a.dense = 2 > a.closestPointRange * a.xAxis.transA;\n          l = a.borderWidth = E(g.borderWidth, l ? 0 : 1);\n          var b = a.xAxis,\n            f = a.yAxis,\n            c = g.threshold,\n            n = E(g.minPointLength, 5),\n            m = a.getColumnMetrics(),\n            w = m.width,\n            v = a.pointXOffset = m.offset,\n            u = a.dataMin,\n            x = a.dataMax;\n          var F = a.barW = Math.max(w, 1 + 2 * l),\n            y = a.translatedThreshold = f.getThreshold(c);\n          d.inverted && (y -= .5);\n          g.pointPadding && (F = Math.ceil(F));\n          C.prototype.translate.apply(a);\n          a.points.forEach(function (k) {\n            var h = E(k.yBottom, y);\n            var l = 999 + Math.abs(h),\n              q = k.plotX || 0;\n            l = p(k.plotY, -l, f.len + l);\n            var r = Math.min(l, h),\n              D = Math.max(l, h) - r,\n              z = w,\n              B = q + v,\n              G = F;\n            n && Math.abs(D) < n && (D = n, q = !f.reversed && !k.negative || f.reversed && k.negative, e(c) && e(x) && k.y === c && x <= c && (f.min || 0) < c && (u !== x || (f.max || 0) <= c) && (q = !q, k.negative = !k.negative), r = Math.abs(r - y) > n ? h - n : y - (q ? n : 0));\n            t(k.options.pointWidth) && (z = G = Math.ceil(k.options.pointWidth), B -= Math.round((z - w) / 2));\n            g.centerInCategory && (B = a.adjustForMissingColumns(B, z, k, m));\n            k.barX = B;\n            k.pointWidth = z;\n            k.tooltipPos = d.inverted ? [p(f.len + f.pos - d.plotLeft - l, f.pos - d.plotLeft, f.len + f.pos - d.plotLeft), b.len + b.pos - d.plotTop - B - G / 2, D] : [b.left - d.plotLeft + B + G / 2, p(l + f.pos - d.plotTop, f.pos - d.plotTop, f.len + f.pos - d.plotTop), D];\n            k.shapeType = a.pointClass.prototype.shapeType || \"roundedRect\";\n            k.shapeArgs = a.crispCol(B, k.isNull ? y : r, G, k.isNull ? 0 : D);\n          });\n          h(this, \"afterColumnTranslate\");\n        }\n      }, {\n        key: \"drawGraph\",\n        value: function drawGraph() {\n          this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n        }\n      }, {\n        key: \"pointAttribs\",\n        value: function pointAttribs(a, d) {\n          var e = this.options;\n          var g = this.pointAttrToOptions || {},\n            b = g.stroke || \"borderColor\";\n          var f = g[\"stroke-width\"] || \"borderWidth\";\n          var c,\n            k = a && a.color || this.color,\n            h = a && a[b] || e[b] || k;\n          g = a && a.options.dashStyle || e.dashStyle;\n          var l = a && a[f] || e[f] || this[f] || 0,\n            m = E(a && a.opacity, e.opacity, 1);\n          a && this.zones.length && (c = a.getZone(), k = a.options.color || c && (c.color || a.nonZonedColor) || this.color, c && (h = c.borderColor || h, g = c.dashStyle || g, l = c.borderWidth || l));\n          d && a && (a = w(e.states[d], a.options.states && a.options.states[d] || {}), d = a.brightness, k = a.color || \"undefined\" !== typeof d && u(k).brighten(a.brightness).get() || k, h = a[b] || h, l = a[f] || l, g = a.dashStyle || g, m = E(a.opacity, m));\n          b = {\n            fill: k,\n            stroke: h,\n            \"stroke-width\": l,\n            opacity: m\n          };\n          g && (b.dashstyle = g);\n          return b;\n        }\n      }, {\n        key: \"drawPoints\",\n        value: function drawPoints() {\n          var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.points;\n          var d = this,\n            g = this.chart,\n            k = d.options,\n            b = g.renderer,\n            f = k.animationLimit || 250;\n          var c;\n          a.forEach(function (a) {\n            var h = a.graphic,\n              l = !!h,\n              n = h && g.pointCount < f ? \"animate\" : \"attr\";\n            if (e(a.plotY) && null !== a.y) {\n              c = a.shapeArgs;\n              h && a.hasNewShapeType() && (h = h.destroy());\n              d.enabledDataSorting && (a.startXPos = d.xAxis.reversed ? -(c ? c.width || 0 : 0) : d.xAxis.width);\n              h || (a.graphic = h = b[a.shapeType](c).add(a.group || d.group)) && d.enabledDataSorting && g.hasRendered && g.pointCount < f && (h.attr({\n                x: a.startXPos\n              }), l = !0, n = \"animate\");\n              if (h && l) h[n](w(c));\n              g.styledMode || h[n](d.pointAttribs(a, a.selected && \"select\")).shadow(!1 !== a.allowShadow && k.shadow);\n              h && (h.addClass(a.getClassName(), !0), h.attr({\n                visibility: a.visible ? \"inherit\" : \"hidden\"\n              }));\n            } else h && (a.graphic = h.destroy());\n          });\n        }\n      }, {\n        key: \"drawTracker\",\n        value: function drawTracker() {\n          var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.points;\n          var d = this,\n            e = d.chart,\n            k = e.pointer,\n            b = function b(a) {\n              var b = k.getPointFromEvent(a);\n              \"undefined\" !== typeof b && d.options.enableMouseTracking && (k.isDirectTouch = !0, b.onMouseOver(a));\n            };\n          var f;\n          a.forEach(function (a) {\n            f = g(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];\n            a.graphic && (a.graphic.element.point = a);\n            f.forEach(function (b) {\n              b.div ? b.div.point = a : b.element.point = a;\n            });\n          });\n          d._hasTracking || (d.trackerGroups.forEach(function (a) {\n            if (d[a]) {\n              d[a].addClass(\"highcharts-tracker\").on(\"mouseover\", b).on(\"mouseout\", function (a) {\n                k.onTrackerMouseOut(a);\n              });\n              if (v) d[a].on(\"touchstart\", b);\n              !e.styledMode && d.options.cursor && d[a].css({\n                cursor: d.options.cursor\n              });\n            }\n          }), d._hasTracking = !0);\n          h(this, \"afterDrawTracker\");\n        }\n      }, {\n        key: \"remove\",\n        value: function remove() {\n          var a = this,\n            d = a.chart;\n          d.hasRendered && d.series.forEach(function (d) {\n            d.type === a.type && (d.isDirty = !0);\n          });\n          C.prototype.remove.apply(a, arguments);\n        }\n      }]);\n      return d;\n    }(C);\n    d.defaultOptions = w(C.defaultOptions, I);\n    m(d.prototype, {\n      cropShoulder: 0,\n      directTouch: !0,\n      getSymbol: l,\n      negStacks: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    z.registerSeriesType(\"column\", d);\n    \"\";\n    return d;\n  });\n  M(a, \"Core/Series/DataLabel.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Templating.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    var x = a.getDeferredAnimation,\n      C = y.format,\n      z = I.defined,\n      H = I.extend,\n      B = I.fireEvent,\n      u = I.isArray,\n      v = I.isString,\n      l = I.merge,\n      p = I.objectEach,\n      t = I.pick,\n      m = I.splat;\n    var h;\n    (function (a) {\n      function e(a, d, c, e, g) {\n        var b = this.chart;\n        var f = this.isCartesian && b.inverted;\n        var k = this.enabledDataSorting;\n        var h = a.plotX,\n          l = a.plotY;\n        var n = c.rotation;\n        var m = c.align;\n        l = z(h) && z(l) && b.isInsidePlot(h, Math.round(l), {\n          inverted: f,\n          paneCoordinates: !0,\n          series: this\n        });\n        var p = \"justify\" === t(c.overflow, k ? \"none\" : \"justify\");\n        f = this.visible && !1 !== a.visible && z(h) && (a.series.forceDL || k && !p || l || t(c.inside, !!this.options.stacking) && e && b.isInsidePlot(h, f ? e.x + 1 : e.y + e.height - 1, {\n          inverted: f,\n          paneCoordinates: !0,\n          series: this\n        }));\n        h = a.pos();\n        if (f && h) {\n          n && d.attr({\n            align: m\n          });\n          m = d.getBBox(!0);\n          var q = [0, 0];\n          var r = b.renderer.fontMetrics(d).b;\n          e = H({\n            x: h[0],\n            y: Math.round(h[1]),\n            width: 0,\n            height: 0\n          }, e);\n          H(c, {\n            width: m.width,\n            height: m.height\n          });\n          n ? (p = !1, q = b.renderer.rotCorr(r, n), r = {\n            x: e.x + (c.x || 0) + e.width / 2 + q.x,\n            y: e.y + (c.y || 0) + {\n              top: 0,\n              middle: .5,\n              bottom: 1\n            }[c.verticalAlign] * e.height\n          }, q = [m.x - Number(d.attr(\"x\")), m.y - Number(d.attr(\"y\"))], k && this.xAxis && !p && this.setDataLabelStartPos(a, d, g, l, r), d[g ? \"attr\" : \"animate\"](r)) : (k && this.xAxis && !p && this.setDataLabelStartPos(a, d, g, l, e), d.align(c, void 0, e), r = d.alignAttr);\n          if (p && 0 <= e.height) this.justifyDataLabel(d, c, r, m, e, g);else if (t(c.crop, !0)) {\n            var _r2 = r,\n              _a22 = _r2.x,\n              _c17 = _r2.y;\n            _a22 += q[0];\n            _c17 += q[1];\n            f = b.isInsidePlot(_a22, _c17, {\n              paneCoordinates: !0,\n              series: this\n            }) && b.isInsidePlot(_a22 + m.width, _c17 + m.height, {\n              paneCoordinates: !0,\n              series: this\n            });\n          }\n          if (c.shape && !n) d[g ? \"attr\" : \"animate\"]({\n            anchorX: h[0],\n            anchorY: h[1]\n          });\n        }\n        g && k && (d.placed = !1);\n        f || k && !p ? d.show() : (d.hide(), d.placed = !1);\n      }\n      function g(a, d) {\n        var b = d.filter;\n        return b ? (d = b.operator, a = a[b.property], b = b.value, \">\" === d && a > b || \"<\" === d && a < b || \">=\" === d && a >= b || \"<=\" === d && a <= b || \"==\" === d && a == b || \"===\" === d && a === b ? !0 : !1) : !0;\n      }\n      function h() {\n        return this.plotGroup(\"dataLabelsGroup\", \"data-labels\", this.hasRendered ? \"inherit\" : \"hidden\", this.options.dataLabels.zIndex || 6);\n      }\n      function F(a) {\n        var b = this.hasRendered || 0,\n          c = this.initDataLabelsGroup().attr({\n            opacity: +b\n          });\n        !b && c && (this.visible && c.show(), this.options.animation ? c.animate({\n          opacity: 1\n        }, a) : c.attr({\n          opacity: 1\n        }));\n        return c;\n      }\n      function d() {\n        var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.points;\n        var b, c;\n        var d = this,\n          e = d.chart,\n          k = d.options,\n          h = e.renderer,\n          _e$options$chart = e.options.chart,\n          l = _e$options$chart.backgroundColor,\n          q = _e$options$chart.plotBackgroundColor,\n          w = e.options.plotOptions,\n          E = h.getContrast(v(q) && q || v(l) && l || \"#000000\");\n        var F = k.dataLabels,\n          A,\n          y;\n        var G = m(F)[0];\n        var H = G.animation;\n        G = G.defer ? x(e, H, d) : {\n          defer: 0,\n          duration: 0\n        };\n        F = r(r(null === (b = null === w || void 0 === w ? void 0 : w.series) || void 0 === b ? void 0 : b.dataLabels, null === (c = null === w || void 0 === w ? void 0 : w[d.type]) || void 0 === c ? void 0 : c.dataLabels), F);\n        B(this, \"drawDataLabels\");\n        if (u(F) || F.enabled || d._hasPointLabels) y = this.initDataLabels(G), a.forEach(function (a) {\n          var b;\n          var c = a.dataLabels || [];\n          A = m(r(F, a.dlOptions || (null === (b = a.options) || void 0 === b ? void 0 : b.dataLabels)));\n          A.forEach(function (b, f) {\n            var l,\n              m = b.enabled && (!a.isNull || a.dataLabelOnNull) && g(a, b);\n            var n = a.connectors ? a.connectors[f] : a.connector,\n              q = b.style || {};\n            var r = {},\n              w = c[f],\n              u = !w;\n            var x = t(b.distance, a.labelDistance);\n            if (m) {\n              var A = t(b[a.formatPrefix + \"Format\"], b.format);\n              var F = a.getLabelConfig();\n              F = z(A) ? C(A, F, e) : (b[a.formatPrefix + \"Formatter\"] || b.formatter).call(F, b);\n              A = b.rotation;\n              e.styledMode || (q.color = t(b.color, q.color, v(d.color) ? d.color : void 0, \"#000000\"), \"contrast\" === q.color ? (a.contrastColor = h.getContrast(a.color || d.color), q.color = !z(x) && b.inside || 0 > (x || 0) || k.stacking ? a.contrastColor : E) : delete a.contrastColor, k.cursor && (q.cursor = k.cursor));\n              r = {\n                r: b.borderRadius || 0,\n                rotation: A,\n                padding: b.padding,\n                zIndex: 1\n              };\n              if (!e.styledMode) {\n                var _c18 = b.backgroundColor,\n                  _d16 = b.borderColor;\n                r.fill = \"auto\" === _c18 ? a.color : _c18;\n                r.stroke = \"auto\" === _d16 ? a.color : _d16;\n                r[\"stroke-width\"] = b.borderWidth;\n              }\n              p(r, function (a, b) {\n                \"undefined\" === typeof a && delete r[b];\n              });\n            }\n            !w || m && z(F) && !!w.div === !!b.useHTML && (w.rotation && b.rotation || w.rotation === b.rotation) || (w = void 0, u = !0, n && a.connector && (a.connector = a.connector.destroy(), a.connectors && (1 === a.connectors.length ? delete a.connectors : delete a.connectors[f])));\n            m && z(F) && (w ? r.text = F : (w = A ? h.text(F, 0, 0, b.useHTML).addClass(\"highcharts-data-label\") : h.label(F, 0, 0, b.shape, void 0, void 0, b.useHTML, void 0, \"data-label\")) && w.addClass(\" highcharts-data-label-color-\" + a.colorIndex + \" \" + (b.className || \"\") + (b.useHTML ? \" highcharts-tracker\" : \"\")), w && (w.options = b, w.attr(r), e.styledMode || w.css(q).shadow(b.shadow), (m = b[a.formatPrefix + \"TextPath\"] || b.textPath) && !b.useHTML && (w.setTextPath((null === (l = a.getDataLabelPath) || void 0 === l ? void 0 : l.call(a, w)) || a.graphic, m), a.dataLabelPath && !m.enabled && (a.dataLabelPath = a.dataLabelPath.destroy())), w.added || w.add(y), d.alignDataLabel(a, w, b, void 0, u), w.isActive = !0, c[f] && c[f] !== w && c[f].destroy(), c[f] = w));\n          });\n          for (b = c.length; b--;) c[b].isActive ? c[b].isActive = !1 : (c[b].destroy(), c.splice(b, 1));\n          a.dataLabel = c[0];\n          a.dataLabels = c;\n        });\n        B(this, \"afterDrawDataLabels\");\n      }\n      function k(a, d, c, e, g, k) {\n        var b = this.chart,\n          f = d.align,\n          h = d.verticalAlign,\n          l = a.box ? 0 : a.padding || 0;\n        var _d$x = d.x,\n          m = _d$x === void 0 ? 0 : _d$x,\n          _d$y = d.y,\n          n = _d$y === void 0 ? 0 : _d$y,\n          p,\n          q;\n        p = (c.x || 0) + l;\n        0 > p && (\"right\" === f && 0 <= m ? (d.align = \"left\", d.inside = !0) : m -= p, q = !0);\n        p = (c.x || 0) + e.width - l;\n        p > b.plotWidth && (\"left\" === f && 0 >= m ? (d.align = \"right\", d.inside = !0) : m += b.plotWidth - p, q = !0);\n        p = c.y + l;\n        0 > p && (\"bottom\" === h && 0 <= n ? (d.verticalAlign = \"top\", d.inside = !0) : n -= p, q = !0);\n        p = (c.y || 0) + e.height - l;\n        p > b.plotHeight && (\"top\" === h && 0 >= n ? (d.verticalAlign = \"bottom\", d.inside = !0) : n += b.plotHeight - p, q = !0);\n        q && (d.x = m, d.y = n, a.placed = !k, a.align(d, void 0, g));\n        return q;\n      }\n      function r(a, d) {\n        var b = [],\n          f;\n        if (u(a) && !u(d)) b = a.map(function (a) {\n          return l(a, d);\n        });else if (u(d) && !u(a)) b = d.map(function (b) {\n          return l(a, b);\n        });else if (!u(a) && !u(d)) b = l(a, d);else if (u(a) && u(d)) for (f = Math.max(a.length, d.length); f--;) b[f] = l(a[f], d[f]);\n        return b;\n      }\n      function q(a, d, c, e, g) {\n        var b = this.chart,\n          f = b.inverted,\n          k = this.xAxis,\n          h = k.reversed,\n          l = f ? d.height / 2 : d.width / 2;\n        a = (a = a.pointWidth) ? a / 2 : 0;\n        d.startXPos = f ? g.x : h ? -l - a : k.width - l + a;\n        d.startYPos = f ? h ? this.yAxis.height - l + a : -l - a : g.y;\n        e ? \"hidden\" === d.visibility && (d.show(), d.attr({\n          opacity: 0\n        }).animate({\n          opacity: 1\n        })) : d.attr({\n          opacity: 1\n        }).animate({\n          opacity: 0\n        }, void 0, d.hide);\n        b.hasRendered && (c && d.attr({\n          x: d.startXPos,\n          y: d.startYPos\n        }), d.placed = !0);\n      }\n      var y = [];\n      a.compose = function (a) {\n        I.pushUnique(y, a) && (a = a.prototype, a.initDataLabelsGroup = h, a.initDataLabels = F, a.alignDataLabel = e, a.drawDataLabels = d, a.justifyDataLabel = k, a.setDataLabelStartPos = q);\n      };\n    })(h || (h = {}));\n    \"\";\n    return h;\n  });\n  M(a, \"Series/Column/ColumnDataLabel.js\", [a[\"Core/Series/DataLabel.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    var x = y.series,\n      C = I.merge,\n      z = I.pick;\n    var H;\n    (function (y) {\n      function u(a, p, t, m, h) {\n        var g = this.chart.inverted;\n        var e = a.series;\n        var l = (e.xAxis ? e.xAxis.len : this.chart.plotSizeX) || 0;\n        e = (e.yAxis ? e.yAxis.len : this.chart.plotSizeY) || 0;\n        var v = a.dlBox || a.shapeArgs;\n        var u = z(a.below, a.plotY > z(this.translatedThreshold, e)),\n          d = z(t.inside, !!this.options.stacking);\n        v && (m = C(v), 0 > m.y && (m.height += m.y, m.y = 0), v = m.y + m.height - e, 0 < v && v < m.height && (m.height -= v), g && (m = {\n          x: e - m.y - m.height,\n          y: l - m.x - m.width,\n          width: m.height,\n          height: m.width\n        }), d || (g ? (m.x += u ? 0 : m.width, m.width = 0) : (m.y += u ? m.height : 0, m.height = 0)));\n        t.align = z(t.align, !g || d ? \"center\" : u ? \"right\" : \"left\");\n        t.verticalAlign = z(t.verticalAlign, g || d ? \"middle\" : u ? \"top\" : \"bottom\");\n        x.prototype.alignDataLabel.call(this, a, p, t, m, h);\n        t.inside && a.contrastColor && p.css({\n          color: a.contrastColor\n        });\n      }\n      var v = [];\n      y.compose = function (l) {\n        a.compose(x);\n        I.pushUnique(v, l) && (l.prototype.alignDataLabel = u);\n      };\n    })(H || (H = {}));\n    return H;\n  });\n  M(a, \"Series/Bar/BarSeries.js\", [a[\"Series/Column/ColumnSeries.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    var x = I.extend,\n      C = I.merge;\n    var z = /*#__PURE__*/function (_a23) {\n      _inherits(z, _a23);\n      function z() {\n        var _this22;\n        _classCallCheck(this, z);\n        _this22 = _possibleConstructorReturn(this, _getPrototypeOf(z).apply(this, arguments));\n        _this22.points = _this22.options = _this22.data = void 0;\n        return _this22;\n      }\n      return z;\n    }(a);\n    z.defaultOptions = C(a.defaultOptions, {});\n    x(z.prototype, {\n      inverted: !0\n    });\n    y.registerSeriesType(\"bar\", z);\n    \"\";\n    return z;\n  });\n  M(a, \"Series/Scatter/ScatterSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> <span style=\\\"font-size: 0.8em\\\"> {series.name}</span><br/>\",\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n      }\n    };\n  });\n  M(a, \"Series/Scatter/ScatterSeries.js\", [a[\"Series/Scatter/ScatterSeriesDefaults.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    var _y$seriesTypes2 = y.seriesTypes,\n      x = _y$seriesTypes2.column,\n      C = _y$seriesTypes2.line,\n      z = I.addEvent,\n      H = I.extend,\n      B = I.merge;\n    var u = /*#__PURE__*/function (_C2) {\n      _inherits(u, _C2);\n      function u() {\n        var _this23;\n        _classCallCheck(this, u);\n        _this23 = _possibleConstructorReturn(this, _getPrototypeOf(u).apply(this, arguments));\n        _this23.points = _this23.options = _this23.data = void 0;\n        return _this23;\n      }\n      _createClass(u, [{\n        key: \"applyJitter\",\n        value: function applyJitter() {\n          var a = this,\n            l = this.options.jitter,\n            p = this.points.length;\n          l && this.points.forEach(function (t, m) {\n            [\"x\", \"y\"].forEach(function (h, g) {\n              var e = \"plot\" + h.toUpperCase(),\n                w,\n                v;\n              if (l[h] && !t.isNull) {\n                var u = a[h + \"Axis\"];\n                v = l[h] * u.transA;\n                u && !u.isLog && (w = Math.max(0, t[e] - v), u = Math.min(u.len, t[e] + v), g = 1E4 * Math.sin(m + g * p), g -= Math.floor(g), t[e] = w + (u - w) * g, \"x\" === h && (t.clientX = t.plotX));\n              }\n            });\n          });\n        }\n      }, {\n        key: \"drawGraph\",\n        value: function drawGraph() {\n          this.options.lineWidth ? _get(_getPrototypeOf(u.prototype), \"drawGraph\", this).call(this) : this.graph && (this.graph = this.graph.destroy());\n        }\n      }]);\n      return u;\n    }(C);\n    u.defaultOptions = B(C.defaultOptions, a);\n    H(u.prototype, {\n      drawTracker: x.prototype.drawTracker,\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1\n    });\n    z(u, \"afterTranslate\", function () {\n      this.applyJitter();\n    });\n    y.registerSeriesType(\"scatter\", u);\n    return u;\n  });\n  M(a, \"Series/CenteredUtilities.js\", [a[\"Core/Globals.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    var x = a.deg2rad,\n      C = I.fireEvent,\n      z = I.isNumber,\n      H = I.pick,\n      B = I.relativeLength;\n    var u;\n    (function (a) {\n      a.getCenter = function () {\n        var a = this.options,\n          p = this.chart;\n        var t = 2 * (a.slicedOffset || 0),\n          m = p.plotWidth - 2 * t,\n          h = p.plotHeight - 2 * t;\n        var g = a.center;\n        var e = Math.min(m, h),\n          w = a.thickness;\n        var v = a.size;\n        var u = a.innerSize || 0;\n        \"string\" === typeof v && (v = parseFloat(v));\n        \"string\" === typeof u && (u = parseFloat(u));\n        a = [H(g[0], \"50%\"), H(g[1], \"50%\"), H(v && 0 > v ? void 0 : a.size, \"100%\"), H(u && 0 > u ? void 0 : a.innerSize || 0, \"0%\")];\n        !p.angular || this instanceof y || (a[3] = 0);\n        for (g = 0; 4 > g; ++g) v = a[g], p = 2 > g || 2 === g && /%$/.test(v), a[g] = B(v, [m, h, e, a[2]][g]) + (p ? t : 0);\n        a[3] > a[2] && (a[3] = a[2]);\n        z(w) && 2 * w < a[2] && 0 < w && (a[3] = a[2] - 2 * w);\n        C(this, \"afterGetCenter\", {\n          positions: a\n        });\n        return a;\n      };\n      a.getStartAndEndRadians = function (a, p) {\n        a = z(a) ? a : 0;\n        p = z(p) && p > a && 360 > p - a ? p : a + 360;\n        return {\n          start: x * (a + -90),\n          end: x * (p + -90)\n        };\n      };\n    })(u || (u = {}));\n    \"\";\n    return u;\n  });\n  M(a, \"Series/Pie/PiePoint.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    var x = a.setAnimation,\n      C = I.addEvent,\n      z = I.defined,\n      H = I.extend,\n      B = I.isNumber,\n      u = I.pick,\n      v = I.relativeLength;\n    var l = /*#__PURE__*/function (_y3) {\n      _inherits(l, _y3);\n      function l() {\n        var _this24;\n        _classCallCheck(this, l);\n        _this24 = _possibleConstructorReturn(this, _getPrototypeOf(l).apply(this, arguments));\n        _this24.series = _this24.options = _this24.labelDistance = void 0;\n        return _this24;\n      }\n      _createClass(l, [{\n        key: \"getConnectorPath\",\n        value: function getConnectorPath() {\n          var a = this.labelPosition,\n            l = this.series.options.dataLabels,\n            m = this.connectorShapes;\n          var h = l.connectorShape;\n          m[h] && (h = m[h]);\n          return h.call(this, {\n            x: a.computed.x,\n            y: a.computed.y,\n            alignment: a.alignment\n          }, a.connectorPosition, l);\n        }\n      }, {\n        key: \"getTranslate\",\n        value: function getTranslate() {\n          return this.sliced ? this.slicedTranslation : {\n            translateX: 0,\n            translateY: 0\n          };\n        }\n      }, {\n        key: \"haloPath\",\n        value: function haloPath(a) {\n          var l = this.shapeArgs;\n          return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(l.x, l.y, l.r + a, l.r + a, {\n            innerR: l.r - 1,\n            start: l.start,\n            end: l.end,\n            borderRadius: l.borderRadius\n          });\n        }\n      }, {\n        key: \"init\",\n        value: function init() {\n          var _this25 = this;\n          _get(_getPrototypeOf(l.prototype), \"init\", this).apply(this, arguments);\n          this.name = u(this.name, \"Slice\");\n          var a = function a(_a24) {\n            _this25.slice(\"select\" === _a24.type);\n          };\n          C(this, \"select\", a);\n          C(this, \"unselect\", a);\n          return this;\n        }\n      }, {\n        key: \"isValid\",\n        value: function isValid() {\n          return B(this.y) && 0 <= this.y;\n        }\n      }, {\n        key: \"setVisible\",\n        value: function setVisible(a, l) {\n          var _this26 = this;\n          var m = this.series,\n            h = m.chart,\n            g = m.options.ignoreHiddenPoint;\n          l = u(l, g);\n          a !== this.visible && (this.visible = this.options.visible = a = \"undefined\" === typeof a ? !this.visible : a, m.options.data[m.data.indexOf(this)] = this.options, [\"graphic\", \"dataLabel\", \"connector\"].forEach(function (e) {\n            if (_this26[e]) _this26[e][a ? \"show\" : \"hide\"](a);\n          }), this.legendItem && h.legend.colorizeItem(this, a), a || \"hover\" !== this.state || this.setState(\"\"), g && (m.isDirty = !0), l && h.redraw());\n        }\n      }, {\n        key: \"slice\",\n        value: function slice(a, l, m) {\n          var h = this.series;\n          x(m, h.chart);\n          u(l, !0);\n          this.sliced = this.options.sliced = z(a) ? a : !this.sliced;\n          h.options.data[h.data.indexOf(this)] = this.options;\n          this.graphic && this.graphic.animate(this.getTranslate());\n        }\n      }]);\n      return l;\n    }(y);\n    H(l.prototype, {\n      connectorShapes: {\n        fixedOffset: function fixedOffset(a, l, m) {\n          var h = l.breakAt;\n          l = l.touchingSliceAt;\n          return [[\"M\", a.x, a.y], m.softConnector ? [\"C\", a.x + (\"left\" === a.alignment ? -5 : 5), a.y, 2 * h.x - l.x, 2 * h.y - l.y, h.x, h.y] : [\"L\", h.x, h.y], [\"L\", l.x, l.y]];\n        },\n        straight: function straight(a, l) {\n          l = l.touchingSliceAt;\n          return [[\"M\", a.x, a.y], [\"L\", l.x, l.y]];\n        },\n        crookedLine: function crookedLine(a, l, m) {\n          var _l2 = l,\n            h = _l2.breakAt,\n            g = _l2.touchingSliceAt;\n          l = this.series;\n          var _l$center = _slicedToArray(l.center, 3),\n            e = _l$center[0],\n            p = _l$center[1],\n            t = _l$center[2],\n            u = t / 2,\n            d = l.chart.plotWidth,\n            k = l.chart.plotLeft;\n          l = \"left\" === a.alignment;\n          var _a25 = a,\n            r = _a25.x,\n            q = _a25.y;\n          m.crookDistance ? (a = v(m.crookDistance, 1), a = l ? e + u + (d + k - e - u) * (1 - a) : k + (e - u) * a) : a = e + (p - q) * Math.tan((this.angle || 0) - Math.PI / 2);\n          m = [[\"M\", r, q]];\n          (l ? a <= r && a >= h.x : a >= r && a <= h.x) && m.push([\"L\", a, q]);\n          m.push([\"L\", h.x, h.y], [\"L\", g.x, g.y]);\n          return m;\n        }\n      }\n    });\n    return l;\n  });\n  M(a, \"Series/Pie/PieSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      borderRadius: 3,\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        connectorPadding: 5,\n        connectorShape: \"crookedLine\",\n        crookDistance: void 0,\n        distance: 30,\n        enabled: !0,\n        formatter: function formatter() {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0\n      },\n      fillColor: void 0,\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      lineWidth: void 0,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    };\n  });\n  M(a, \"Series/Pie/PieSeries.js\", [a[\"Series/CenteredUtilities.js\"], a[\"Series/Column/ColumnSeries.js\"], a[\"Core/Globals.js\"], a[\"Series/Pie/PiePoint.js\"], a[\"Series/Pie/PieSeriesDefaults.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/Symbols.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z, H, B, u) {\n    var v = a.getStartAndEndRadians;\n    var _I2 = I;\n    I = _I2.noop;\n    var l = u.clamp,\n      p = u.extend,\n      t = u.fireEvent,\n      m = u.merge,\n      h = u.pick,\n      g = u.relativeLength;\n    var e = /*#__PURE__*/function (_z) {\n      _inherits(e, _z);\n      function e() {\n        var _this27;\n        _classCallCheck(this, e);\n        _this27 = _possibleConstructorReturn(this, _getPrototypeOf(e).apply(this, arguments));\n        _this27.points = _this27.options = _this27.maxLabelDistance = _this27.data = _this27.center = void 0;\n        return _this27;\n      }\n      _createClass(e, [{\n        key: \"animate\",\n        value: function animate(a) {\n          var e = this,\n            g = e.points,\n            d = e.startAngleRad;\n          a || g.forEach(function (a) {\n            var g = a.graphic,\n              k = a.shapeArgs;\n            g && k && (g.attr({\n              r: h(a.startR, e.center && e.center[3] / 2),\n              start: d,\n              end: d\n            }), g.animate({\n              r: k.r,\n              start: k.start,\n              end: k.end\n            }, e.options.animation));\n          });\n        }\n      }, {\n        key: \"drawEmpty\",\n        value: function drawEmpty() {\n          var a = this.startAngleRad,\n            e = this.endAngleRad,\n            g = this.options;\n          var d, k;\n          0 === this.total && this.center ? (d = this.center[0], k = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(d, k, this.center[1] / 2, 0, a, e).addClass(\"highcharts-empty-series\").add(this.group)), this.graph.attr({\n            d: B.arc(d, k, this.center[2] / 2, 0, {\n              start: a,\n              end: e,\n              innerR: this.center[3] / 2\n            })\n          }), this.chart.styledMode || this.graph.attr({\n            \"stroke-width\": g.borderWidth,\n            fill: g.fillColor || \"none\",\n            stroke: g.color || \"#cccccc\"\n          })) : this.graph && (this.graph = this.graph.destroy());\n        }\n      }, {\n        key: \"drawPoints\",\n        value: function drawPoints() {\n          var a = this.chart.renderer;\n          this.points.forEach(function (e) {\n            e.graphic && e.hasNewShapeType() && (e.graphic = e.graphic.destroy());\n            e.graphic || (e.graphic = a[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0);\n          });\n        }\n      }, {\n        key: \"generatePoints\",\n        value: function generatePoints() {\n          _get(_getPrototypeOf(e.prototype), \"generatePoints\", this).call(this);\n          this.updateTotals();\n        }\n      }, {\n        key: \"getX\",\n        value: function getX(a, e, g) {\n          var d = this.center,\n            k = this.radii ? this.radii[g.index] || 0 : d[2] / 2;\n          a = Math.asin(l((a - d[1]) / (k + g.labelDistance), -1, 1));\n          return d[0] + (e ? -1 : 1) * Math.cos(a) * (k + g.labelDistance) + (0 < g.labelDistance ? (e ? -1 : 1) * this.options.dataLabels.padding : 0);\n        }\n      }, {\n        key: \"hasData\",\n        value: function hasData() {\n          return !!this.processedXData.length;\n        }\n      }, {\n        key: \"redrawPoints\",\n        value: function redrawPoints() {\n          var a = this,\n            e = a.chart;\n          var g, d, k, h;\n          this.drawEmpty();\n          a.group && !e.styledMode && a.group.shadow(a.options.shadow);\n          a.points.forEach(function (l) {\n            var q = {};\n            d = l.graphic;\n            !l.isNull && d ? (h = l.shapeArgs, g = l.getTranslate(), e.styledMode || (k = a.pointAttribs(l, l.selected && \"select\")), l.delayedRendering ? (d.setRadialReference(a.center).attr(h).attr(g), e.styledMode || d.attr(k).attr({\n              \"stroke-linejoin\": \"round\"\n            }), l.delayedRendering = !1) : (d.setRadialReference(a.center), e.styledMode || m(!0, q, k), m(!0, q, h, g), d.animate(q)), d.attr({\n              visibility: l.visible ? \"inherit\" : \"hidden\"\n            }), d.addClass(l.getClassName(), !0)) : d && (l.graphic = d.destroy());\n          });\n        }\n      }, {\n        key: \"sortByAngle\",\n        value: function sortByAngle(a, e) {\n          a.sort(function (a, d) {\n            return \"undefined\" !== typeof a.angle && (d.angle - a.angle) * e;\n          });\n        }\n      }, {\n        key: \"translate\",\n        value: function translate(a) {\n          t(this, \"translate\");\n          this.generatePoints();\n          var e = this.options;\n          var l = e.slicedOffset,\n            d = l + (e.borderWidth || 0);\n          var k = v(e.startAngle, e.endAngle);\n          var m = this.startAngleRad = k.start;\n          k = (this.endAngleRad = k.end) - m;\n          var q = this.points,\n            p = e.dataLabels.distance;\n          e = e.ignoreHiddenPoint;\n          var b = q.length;\n          var f,\n            c,\n            n,\n            w = 0;\n          a || (this.center = a = this.getCenter());\n          for (c = 0; c < b; c++) {\n            n = q[c];\n            var u = m + w * k;\n            !n.isValid() || e && !n.visible || (w += n.percentage / 100);\n            var x = m + w * k;\n            var y = {\n              x: a[0],\n              y: a[1],\n              r: a[2] / 2,\n              innerR: a[3] / 2,\n              start: Math.round(1E3 * u) / 1E3,\n              end: Math.round(1E3 * x) / 1E3\n            };\n            n.shapeType = \"arc\";\n            n.shapeArgs = y;\n            n.labelDistance = h(n.options.dataLabels && n.options.dataLabels.distance, p);\n            n.labelDistance = g(n.labelDistance, y.r);\n            this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, n.labelDistance);\n            x = (x + u) / 2;\n            x > 1.5 * Math.PI ? x -= 2 * Math.PI : x < -Math.PI / 2 && (x += 2 * Math.PI);\n            n.slicedTranslation = {\n              translateX: Math.round(Math.cos(x) * l),\n              translateY: Math.round(Math.sin(x) * l)\n            };\n            y = Math.cos(x) * a[2] / 2;\n            f = Math.sin(x) * a[2] / 2;\n            n.tooltipPos = [a[0] + .7 * y, a[1] + .7 * f];\n            n.half = x < -Math.PI / 2 || x > Math.PI / 2 ? 1 : 0;\n            n.angle = x;\n            u = Math.min(d, n.labelDistance / 5);\n            n.labelPosition = {\n              natural: {\n                x: a[0] + y + Math.cos(x) * n.labelDistance,\n                y: a[1] + f + Math.sin(x) * n.labelDistance\n              },\n              computed: {},\n              alignment: 0 > n.labelDistance ? \"center\" : n.half ? \"right\" : \"left\",\n              connectorPosition: {\n                breakAt: {\n                  x: a[0] + y + Math.cos(x) * u,\n                  y: a[1] + f + Math.sin(x) * u\n                },\n                touchingSliceAt: {\n                  x: a[0] + y,\n                  y: a[1] + f\n                }\n              }\n            };\n          }\n          t(this, \"afterTranslate\");\n        }\n      }, {\n        key: \"updateTotals\",\n        value: function updateTotals() {\n          var a = this.points,\n            e = a.length,\n            g = this.options.ignoreHiddenPoint;\n          var d,\n            k,\n            h = 0;\n          for (d = 0; d < e; d++) k = a[d], !k.isValid() || g && !k.visible || (h += k.y);\n          this.total = h;\n          for (d = 0; d < e; d++) k = a[d], k.percentage = 0 < h && (k.visible || !g) ? k.y / h * 100 : 0, k.total = h;\n        }\n      }]);\n      return e;\n    }(z);\n    e.defaultOptions = m(z.defaultOptions, C);\n    p(e.prototype, {\n      axisTypes: [],\n      directTouch: !0,\n      drawGraph: void 0,\n      drawTracker: y.prototype.drawTracker,\n      getCenter: a.getCenter,\n      getSymbol: I,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointAttribs: y.prototype.pointAttribs,\n      pointClass: L,\n      requireSorting: !1,\n      searchPoint: I,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    H.registerSeriesType(\"pie\", e);\n    return e;\n  });\n  M(a, \"Series/Pie/PieDataLabel.js\", [a[\"Core/Series/DataLabel.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C) {\n    var x = y.noop,\n      H = I.distribute,\n      B = L.series,\n      u = C.arrayMax,\n      v = C.clamp,\n      l = C.defined,\n      p = C.merge,\n      t = C.pick,\n      m = C.relativeLength;\n    var h;\n    (function (g) {\n      function e() {\n        var a = this,\n          d = a.data,\n          e = a.chart,\n          g = a.options.dataLabels || {},\n          b = g.connectorPadding,\n          f = e.plotWidth,\n          c = e.plotHeight,\n          h = e.plotLeft,\n          m = Math.round(e.chartWidth / 3),\n          w = a.center,\n          v = w[2] / 2,\n          x = w[1],\n          y = [[], []],\n          z = [0, 0, 0, 0],\n          F = a.dataLabelPositioners;\n        var C, A, E, I, L, M, J, N, O, S, W, U;\n        a.visible && (g.enabled || a._hasPointLabels) && (d.forEach(function (a) {\n          a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n            width: \"auto\"\n          }).css({\n            width: \"auto\",\n            textOverflow: \"clip\"\n          }), a.dataLabel.shortened = !1);\n        }), B.prototype.drawDataLabels.apply(a), d.forEach(function (a) {\n          a.dataLabel && (a.visible ? (y[a.half].push(a), a.dataLabel._pos = null, !l(g.style.width) && !l(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > m && (a.dataLabel.css({\n            width: Math.round(.7 * m) + \"px\"\n          }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n        }), y.forEach(function (d, k) {\n          var m = d.length,\n            n = [];\n          var q,\n            p = 0;\n          if (m) {\n            a.sortByAngle(d, k - .5);\n            if (0 < a.maxLabelDistance) {\n              var r = Math.max(0, x - v - a.maxLabelDistance);\n              q = Math.min(x + v + a.maxLabelDistance, e.plotHeight);\n              d.forEach(function (a) {\n                0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, x - v - a.labelDistance), a.bottom = Math.min(x + v + a.labelDistance, e.plotHeight), p = a.dataLabel.getBBox().height || 21, a.distributeBox = {\n                  target: a.labelPosition.natural.y - a.top + p / 2,\n                  size: p,\n                  rank: a.y\n                }, n.push(a.distributeBox));\n              });\n              r = q + p - r;\n              H(n, r, r / 5);\n            }\n            for (W = 0; W < m; W++) {\n              C = d[W];\n              M = C.labelPosition;\n              I = C.dataLabel;\n              S = !1 === C.visible ? \"hidden\" : \"inherit\";\n              O = r = M.natural.y;\n              n && l(C.distributeBox) && (\"undefined\" === typeof C.distributeBox.pos ? S = \"hidden\" : (J = C.distributeBox.size, O = F.radialDistributionY(C)));\n              delete C.positionIndex;\n              if (g.justify) N = F.justify(C, v, w);else switch (g.alignTo) {\n                case \"connectors\":\n                  N = F.alignToConnectors(d, k, f, h);\n                  break;\n                case \"plotEdges\":\n                  N = F.alignToPlotEdges(I, k, f, h);\n                  break;\n                default:\n                  N = F.radialDistributionX(a, C, O, r);\n              }\n              I._attr = {\n                visibility: S,\n                align: M.alignment\n              };\n              U = C.options.dataLabels || {};\n              I._pos = {\n                x: N + t(U.x, g.x) + ({\n                  left: b,\n                  right: -b\n                }[M.alignment] || 0),\n                y: O + t(U.y, g.y) - I.getBBox().height / 2\n              };\n              M && (M.computed.x = N, M.computed.y = O);\n              t(g.crop, !0) && (L = I.getBBox().width, r = null, N - L < b && 1 === k ? (r = Math.round(L - N + b), z[3] = Math.max(r, z[3])) : N + L > f - b && 0 === k && (r = Math.round(N + L - f + b), z[1] = Math.max(r, z[1])), 0 > O - J / 2 ? z[0] = Math.max(Math.round(-O + J / 2), z[0]) : O + J / 2 > c && (z[2] = Math.max(Math.round(O + J / 2 - c), z[2])), I.sideOverflow = r);\n            }\n          }\n        }), 0 === u(z) || this.verifyDataLabelOverflow(z)) && (this.placeDataLabels(), this.points.forEach(function (b) {\n          U = p(g, b.options.dataLabels);\n          if (A = t(U.connectorWidth, 1)) {\n            var _c19;\n            E = b.connector;\n            if ((I = b.dataLabel) && I._pos && b.visible && 0 < b.labelDistance) {\n              S = I._attr.visibility;\n              if (_c19 = !E) b.connector = E = e.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + b.colorIndex + (b.className ? \" \" + b.className : \"\")).add(a.dataLabelsGroup), e.styledMode || E.attr({\n                \"stroke-width\": A,\n                stroke: U.connectorColor || b.color || \"#666666\"\n              });\n              E[_c19 ? \"attr\" : \"animate\"]({\n                d: b.getConnectorPath()\n              });\n              E.attr(\"visibility\", S);\n            } else E && (b.connector = E.destroy());\n          }\n        }));\n      }\n      function h() {\n        this.points.forEach(function (a) {\n          var d = a.dataLabel,\n            e;\n          d && a.visible && ((e = d._pos) ? (d.sideOverflow && (d._attr.width = Math.max(d.getBBox().width - d.sideOverflow, 0), d.css({\n            width: d._attr.width + \"px\",\n            textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n          }), d.shortened = !0), d.attr(d._attr), d[d.moved ? \"animate\" : \"attr\"](e), d.moved = !0) : d && d.attr({\n            y: -9999\n          }));\n          delete a.distributeBox;\n        }, this);\n      }\n      function y(a) {\n        var d = this.center,\n          e = this.options,\n          g = e.center,\n          b = e.minSize || 80,\n          f,\n          c = null !== e.size;\n        c || (null !== g[0] ? f = Math.max(d[2] - Math.max(a[1], a[3]), b) : (f = Math.max(d[2] - a[1] - a[3], b), d[0] += (a[3] - a[1]) / 2), null !== g[1] ? f = v(f, b, d[2] - Math.max(a[0], a[2])) : (f = v(f, b, d[2] - a[0] - a[2]), d[1] += (a[0] - a[2]) / 2), f < d[2] ? (d[2] = f, d[3] = Math.min(e.thickness ? Math.max(0, f - 2 * e.thickness) : Math.max(0, m(e.innerSize || 0, f)), f), this.translate(d), this.drawDataLabels && this.drawDataLabels()) : c = !0);\n        return c;\n      }\n      var z = [],\n        d = {\n          radialDistributionY: function radialDistributionY(a) {\n            return a.top + a.distributeBox.pos;\n          },\n          radialDistributionX: function radialDistributionX(a, d, e, g) {\n            return a.getX(e < d.top + 2 || e > d.bottom - 2 ? g : e, d.half, d);\n          },\n          justify: function justify(a, d, e) {\n            return e[0] + (a.half ? -1 : 1) * (d + a.labelDistance);\n          },\n          alignToPlotEdges: function alignToPlotEdges(a, d, e, g) {\n            a = a.getBBox().width;\n            return d ? a + g : e - a - g;\n          },\n          alignToConnectors: function alignToConnectors(a, d, e, g) {\n            var b = 0,\n              f;\n            a.forEach(function (a) {\n              f = a.dataLabel.getBBox().width;\n              f > b && (b = f);\n            });\n            return d ? b + g : e - b - g;\n          }\n        };\n      g.compose = function (g) {\n        a.compose(B);\n        C.pushUnique(z, g) && (g = g.prototype, g.dataLabelPositioners = d, g.alignDataLabel = x, g.drawDataLabels = e, g.placeDataLabels = h, g.verifyDataLabelOverflow = y);\n      };\n    })(h || (h = {}));\n    return h;\n  });\n  M(a, \"Extensions/OverlappingDataLabels.js\", [a[\"Core/Chart/Chart.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    function x(a, l) {\n      var p,\n        t = !1;\n      a && (p = a.newOpacity, a.oldOpacity !== p && (a.alignAttr && a.placed ? (a[p ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), t = !0, a.alignAttr.opacity = p, a[a.isOld ? \"animate\" : \"attr\"](a.alignAttr, null, function () {\n        l.styledMode || a.css({\n          pointerEvents: p ? \"auto\" : \"none\"\n        });\n      }), C(l, \"afterHideOverlappingLabel\")) : a.attr({\n        opacity: p\n      })), a.isOld = !0);\n      return t;\n    }\n    var L = y.addEvent,\n      C = y.fireEvent,\n      z = y.isArray,\n      H = y.isNumber,\n      B = y.objectEach,\n      u = y.pick;\n    L(a, \"render\", function () {\n      var a = this,\n        l = [];\n      (this.labelCollectors || []).forEach(function (a) {\n        l = l.concat(a());\n      });\n      (this.yAxis || []).forEach(function (a) {\n        a.stacking && a.options.stackLabels && !a.options.stackLabels.allowOverlap && B(a.stacking.stacks, function (a) {\n          B(a, function (a) {\n            a.label && l.push(a.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (p) {\n        var t = p.options.dataLabels;\n        p.visible && (!1 !== t.enabled || p._hasPointLabels) && (t = function t(m) {\n          return m.forEach(function (h) {\n            h.visible && (z(h.dataLabels) ? h.dataLabels : h.dataLabel ? [h.dataLabel] : []).forEach(function (g) {\n              var e = g.options;\n              g.labelrank = u(e.labelrank, h.labelrank, h.shapeArgs && h.shapeArgs.height);\n              e.allowOverlap ? (g.oldOpacity = g.opacity, g.newOpacity = 1, x(g, a)) : l.push(g);\n            });\n          });\n        }, t(p.nodes || []), t(p.points));\n      });\n      this.hideOverlappingLabels(l);\n    });\n    a.prototype.hideOverlappingLabels = function (a) {\n      var l = this,\n        p = a.length,\n        t = l.renderer;\n      var m;\n      var h;\n      var g,\n        e,\n        w,\n        u = !1;\n      var v = function v(a) {\n        var d, e;\n        var g;\n        var h = a.box ? 0 : a.padding || 0,\n          b = g = 0,\n          f,\n          c;\n        if (a && (!a.alignAttr || a.placed)) return d = a.alignAttr || {\n          x: a.attr(\"x\"),\n          y: a.attr(\"y\")\n        }, e = a.parentGroup, a.width || (g = a.getBBox(), a.width = g.width, a.height = g.height, g = t.fontMetrics(a.element).h), f = a.width - 2 * h, (c = {\n          left: \"0\",\n          center: \"0.5\",\n          right: \"1\"\n        }[a.alignValue]) ? b = +c * f : H(a.x) && Math.round(a.x) !== a.translateX && (b = a.x - a.translateX), {\n          x: d.x + (e.translateX || 0) + h - (b || 0),\n          y: d.y + (e.translateY || 0) + h - g,\n          width: a.width - 2 * h,\n          height: a.height - 2 * h\n        };\n      };\n      for (h = 0; h < p; h++) if (m = a[h]) m.oldOpacity = m.opacity, m.newOpacity = 1, m.absoluteBox = v(m);\n      a.sort(function (a, e) {\n        return (e.labelrank || 0) - (a.labelrank || 0);\n      });\n      for (h = 0; h < p; h++) for (e = (v = a[h]) && v.absoluteBox, m = h + 1; m < p; ++m) w = (g = a[m]) && g.absoluteBox, !e || !w || v === g || 0 === v.newOpacity || 0 === g.newOpacity || \"hidden\" === v.visibility || \"hidden\" === g.visibility || w.x >= e.x + e.width || w.x + w.width <= e.x || w.y >= e.y + e.height || w.y + w.height <= e.y || ((v.labelrank < g.labelrank ? v : g).newOpacity = 0);\n      a.forEach(function (a) {\n        x(a, l) && (u = !0);\n      });\n      u && C(l, \"afterHideAllOverlappingLabels\");\n    };\n  });\n  M(a, \"Extensions/BorderRadius.js\", [a[\"Core/Defaults.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z) {\n    var _a26 = a,\n      x = _a26.defaultOptions;\n    a = I.seriesTypes;\n    var B = z.addEvent,\n      u = z.extend,\n      v = z.isObject,\n      l = z.merge,\n      p = z.relativeLength,\n      t = {\n        radius: 0,\n        scope: \"stack\",\n        where: void 0\n      },\n      m = function m(a, g) {\n        v(a) || (a = {\n          radius: a || 0\n        });\n        return l(t, g, a);\n      };\n    if (-1 === L.symbolCustomAttribs.indexOf(\"borderRadius\")) {\n      L.symbolCustomAttribs.push(\"borderRadius\", \"brBoxHeight\", \"brBoxY\");\n      var h = C.prototype.symbols.arc;\n      C.prototype.symbols.arc = function (a, g, l, m) {\n        var d = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n        a = h(a, g, l, m, d);\n        var _d17 = d,\n          _d17$innerR = _d17.innerR,\n          e = _d17$innerR === void 0 ? 0 : _d17$innerR,\n          _d17$r = _d17.r,\n          r = _d17$r === void 0 ? l : _d17$r,\n          _d17$start = _d17.start,\n          q = _d17$start === void 0 ? 0 : _d17$start,\n          _d17$end = _d17.end,\n          t = _d17$end === void 0 ? 0 : _d17$end;\n        if (d.open || !d.borderRadius) return a;\n        l = t - q;\n        g = Math.sin(l / 2);\n        d = Math.max(Math.min(p(d.borderRadius || 0, r - e), (r - e) / 2, r * g / (1 + g)), 0);\n        l = Math.min(d, l / Math.PI * 2 * e);\n        for (g = a.length - 1; g--;) {\n          {\n            var _e7 = void 0,\n              _h10 = void 0,\n              k = void 0;\n            m = a;\n            var b = g,\n              f = 1 < g ? l : d,\n              c = m[b],\n              n = m[b + 1];\n            \"Z\" === n[0] && (n = m[0]);\n            \"M\" !== c[0] && \"L\" !== c[0] || \"A\" !== n[0] ? \"A\" !== c[0] || \"M\" !== n[0] && \"L\" !== n[0] || (k = n, _h10 = c) : (k = c, _h10 = n, _e7 = !0);\n            if (k && _h10 && _h10.params) {\n              c = _h10[1];\n              var w = _h10[5];\n              n = _h10.params;\n              var _n7 = n,\n                _a27 = _n7.start,\n                _d18 = _n7.end,\n                _g7 = _n7.cx,\n                _l3 = _n7.cy;\n              var u = w ? c - f : c + f;\n              var _p3 = u ? Math.asin(f / u) : 0;\n              w = w ? _p3 : -_p3;\n              u *= Math.cos(_p3);\n              _e7 ? (n.start = _a27 + w, k[1] = _g7 + u * Math.cos(_a27), k[2] = _l3 + u * Math.sin(_a27), m.splice(b + 1, 0, [\"A\", f, f, 0, 0, 1, _g7 + c * Math.cos(n.start), _l3 + c * Math.sin(n.start)])) : (n.end = _d18 - w, _h10[6] = _g7 + c * Math.cos(n.end), _h10[7] = _l3 + c * Math.sin(n.end), m.splice(b + 1, 0, [\"A\", f, f, 0, 0, 1, _g7 + u * Math.cos(_d18), _l3 + u * Math.sin(_d18)]));\n              _h10[4] = Math.abs(n.end - n.start) < Math.PI ? 0 : 1;\n            }\n          }\n        }\n        return a;\n      };\n      var g = C.prototype.symbols.roundedRect;\n      C.prototype.symbols.roundedRect = function (a, h, l, m) {\n        var d = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n        var e = g(a, h, l, m, d),\n          _d19 = d,\n          _d19$r = _d19.r,\n          p = _d19$r === void 0 ? 0 : _d19$r,\n          _d19$brBoxHeight = _d19.brBoxHeight,\n          q = _d19$brBoxHeight === void 0 ? m : _d19$brBoxHeight,\n          _d19$brBoxY = _d19.brBoxY,\n          t = _d19$brBoxY === void 0 ? h : _d19$brBoxY;\n        var b = h - t,\n          f = t + q - (h + m);\n        d = -.1 < b - p ? 0 : p;\n        var c = -.1 < f - p ? 0 : p;\n        var n = Math.max(d && b, 0);\n        var u = Math.max(c && f, 0);\n        f = [a + d, h];\n        b = [a + l - d, h];\n        var w = [a + l, h + d],\n          v = [a + l, h + m - c],\n          x = [a + l - c, h + m],\n          y = [a + c, h + m],\n          z = [a, h + m - c],\n          B = [a, h + d];\n        if (n) {\n          var _a28 = Math.sqrt(Math.pow(d, 2) - Math.pow(d - n, 2));\n          f[0] -= _a28;\n          b[0] += _a28;\n          w[1] = B[1] = h + d - n;\n        }\n        m < d - n && (n = Math.sqrt(Math.pow(d, 2) - Math.pow(d - n - m, 2)), w[0] = v[0] = a + l - d + n, x[0] = Math.min(w[0], x[0]), y[0] = Math.max(v[0], y[0]), z[0] = B[0] = a + d - n, w[1] = B[1] = h + m);\n        u && (n = Math.sqrt(Math.pow(c, 2) - Math.pow(c - u, 2)), x[0] += n, y[0] -= n, v[1] = z[1] = h + m - c + u);\n        m < c - u && (m = Math.sqrt(Math.pow(c, 2) - Math.pow(c - u - m, 2)), w[0] = v[0] = a + l - c + m, b[0] = Math.min(w[0], b[0]), f[0] = Math.max(v[0], f[0]), z[0] = B[0] = a + c - m, v[1] = z[1] = h);\n        e.length = 0;\n        e.push([\"M\"].concat(_toConsumableArray(f)), [\"L\"].concat(_toConsumableArray(b)), [\"A\", d, d, 0, 0, 1].concat(w), [\"L\"].concat(v), [\"A\", c, c, 0, 0, 1].concat(x), [\"L\"].concat(y), [\"A\", c, c, 0, 0, 1].concat(z), [\"L\"].concat(B), [\"A\", d, d, 0, 0, 1].concat(_toConsumableArray(f)), [\"Z\"]);\n        return e;\n      };\n      B(a.pie, \"afterTranslate\", function () {\n        var a = m(this.options.borderRadius);\n        var _iterator8 = _createForOfIteratorHelper(this.points),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var e = _step8.value;\n            var _g8 = e.shapeArgs;\n            _g8 && (_g8.borderRadius = p(a.radius, (_g8.r || 0) - (_g8.innerR || 0)));\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      });\n      B(y, \"afterColumnTranslate\", function () {\n        var a, g;\n        if (this.options.borderRadius && (!this.chart.is3d || !this.chart.is3d())) {\n          var e = this.options,\n            r = this.yAxis,\n            q = \"percent\" === e.stacking;\n          var h = null === (g = null === (a = x.plotOptions) || void 0 === a ? void 0 : a[this.type]) || void 0 === g ? void 0 : g.borderRadius;\n          a = m(e.borderRadius, v(h) ? h : {});\n          g = r.options.reversed;\n          var _iterator9 = _createForOfIteratorHelper(this.points),\n            _step9;\n          try {\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              var _k9;\n              var k = _step9.value;\n              if ((_k9 = k, h = _k9.shapeArgs, _k9), \"roundedRect\" === k.shapeType && h) {\n                var _h11 = h,\n                  _h11$width = _h11.width,\n                  b = _h11$width === void 0 ? 0 : _h11$width,\n                  _h11$height = _h11.height,\n                  f = _h11$height === void 0 ? 0 : _h11$height,\n                  _h11$y = _h11.y,\n                  c = _h11$y === void 0 ? 0 : _h11$y;\n                var l = c,\n                  d = f;\n                \"stack\" === a.scope && k.stackTotal && (l = r.translate(q ? 100 : k.stackTotal, !1, !0, !1, !0), d = r.translate(e.threshold || 0, !1, !0, !1, !0), d = this.crispCol(0, Math.min(l, d), 0, Math.abs(l - d)), l = d.y, d = d.height);\n                var _m4 = -1 === (k.negative ? -1 : 1) * (g ? -1 : 1);\n                var _t2 = a.where;\n                !_t2 && this.is(\"waterfall\") && Math.abs((k.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (_t2 = \"all\");\n                _t2 || (_t2 = \"end\");\n                var _v = Math.min(p(a.radius, b), b / 2, \"all\" === _t2 ? f / 2 : Infinity) || 0;\n                \"end\" === _t2 && (_m4 && (l -= _v), d += _v);\n                u(h, {\n                  brBoxHeight: d,\n                  brBoxY: l,\n                  r: _v\n                });\n              }\n            }\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n        }\n      }, {\n        order: 9\n      });\n    }\n    y = {\n      optionsToObject: m\n    };\n    \"\";\n    return y;\n  });\n  M(a, \"Core/Responsive.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    var x = a.diffObjects,\n      I = a.extend,\n      L = a.find,\n      C = a.merge,\n      z = a.pick,\n      H = a.uniqueKey;\n    var B;\n    (function (u) {\n      function v(a, l) {\n        var h = a.condition;\n        (h.callback || function () {\n          return this.chartWidth <= z(h.maxWidth, Number.MAX_VALUE) && this.chartHeight <= z(h.maxHeight, Number.MAX_VALUE) && this.chartWidth >= z(h.minWidth, 0) && this.chartHeight >= z(h.minHeight, 0);\n        }).call(this) && l.push(a._id);\n      }\n      function l(a, l) {\n        var _this28 = this;\n        var h = this.options.responsive;\n        var g = this.currentResponsive;\n        var e = [];\n        !l && h && h.rules && h.rules.forEach(function (a) {\n          \"undefined\" === typeof a._id && (a._id = H());\n          _this28.matchResponsiveRule(a, e);\n        }, this);\n        l = C.apply(void 0, _toConsumableArray(e.map(function (a) {\n          return L((h || {}).rules || [], function (e) {\n            return e._id === a;\n          });\n        }).map(function (a) {\n          return a && a.chartOptions;\n        })));\n        l.isResponsiveOptions = !0;\n        e = e.toString() || void 0;\n        e !== (g && g.ruleIds) && (g && this.update(g.undoOptions, a, !0), e ? (g = x(l, this.options, !0, this.collectionsWithUpdate), g.isResponsiveOptions = !0, this.currentResponsive = {\n          ruleIds: e,\n          mergedOptions: l,\n          undoOptions: g\n        }, this.update(l, a, !0)) : this.currentResponsive = void 0);\n      }\n      var p = [];\n      u.compose = function (t) {\n        a.pushUnique(p, t) && I(t.prototype, {\n          matchResponsiveRule: v,\n          setResponsive: l\n        });\n        return t;\n      };\n    })(B || (B = {}));\n    \"\";\n    \"\";\n    return B;\n  });\n  M(a, \"masters/highcharts.src.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"], a[\"Core/Defaults.js\"], a[\"Core/Animation/Fx.js\"], a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Templating.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Renderer/HTML/HTMLElement.js\"], a[\"Core/Renderer/HTML/HTMLRenderer.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Axis/DateTimeAxis.js\"], a[\"Core/Axis/LogarithmicAxis.js\"], a[\"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\"], a[\"Core/Axis/Tick.js\"], a[\"Core/Tooltip.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Pointer.js\"], a[\"Core/Legend/Legend.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Axis/Stacking/StackingAxis.js\"], a[\"Core/Axis/Stacking/StackItem.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Series/Column/ColumnSeries.js\"], a[\"Series/Column/ColumnDataLabel.js\"], a[\"Series/Pie/PieSeries.js\"], a[\"Series/Pie/PieDataLabel.js\"], a[\"Core/Series/DataLabel.js\"], a[\"Core/Responsive.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Time.js\"]], function (a, y, I, L, C, z, H, B, u, v, l, p, t, m, h, g, e, w, E, F, d, k, r, q, G, b, f, c, n, M, D, K, U, T) {\n    a.animate = C.animate;\n    a.animObject = C.animObject;\n    a.getDeferredAnimation = C.getDeferredAnimation;\n    a.setAnimation = C.setAnimation;\n    a.stop = C.stop;\n    a.timers = L.timers;\n    a.AST = z;\n    a.Axis = t;\n    a.Chart = k;\n    a.chart = k.chart;\n    a.Fx = L;\n    a.Legend = d;\n    a.PlotLineOrBand = g;\n    a.Point = E;\n    a.Pointer = F;\n    a.Series = G;\n    a.StackItem = q;\n    a.SVGElement = u;\n    a.SVGRenderer = v;\n    a.Templating = H;\n    a.Tick = e;\n    a.Time = T;\n    a.Tooltip = w;\n    a.Color = U;\n    a.color = U.parse;\n    p.compose(v);\n    l.compose(u);\n    F.compose(k);\n    d.compose(k);\n    a.defaultOptions = I.defaultOptions;\n    a.getOptions = I.getOptions;\n    a.time = I.defaultTime;\n    a.setOptions = I.setOptions;\n    a.dateFormat = H.dateFormat;\n    a.format = H.format;\n    a.numberFormat = H.numberFormat;\n    a.addEvent = y.addEvent;\n    a.arrayMax = y.arrayMax;\n    a.arrayMin = y.arrayMin;\n    a.attr = y.attr;\n    a.clearTimeout = y.clearTimeout;\n    a.correctFloat = y.correctFloat;\n    a.createElement = y.createElement;\n    a.css = y.css;\n    a.defined = y.defined;\n    a.destroyObjectProperties = y.destroyObjectProperties;\n    a.discardElement = y.discardElement;\n    a.distribute = B.distribute;\n    a.erase = y.erase;\n    a.error = y.error;\n    a.extend = y.extend;\n    a.extendClass = y.extendClass;\n    a.find = y.find;\n    a.fireEvent = y.fireEvent;\n    a.getMagnitude = y.getMagnitude;\n    a.getStyle = y.getStyle;\n    a.inArray = y.inArray;\n    a.isArray = y.isArray;\n    a.isClass = y.isClass;\n    a.isDOMElement = y.isDOMElement;\n    a.isFunction = y.isFunction;\n    a.isNumber = y.isNumber;\n    a.isObject = y.isObject;\n    a.isString = y.isString;\n    a.keys = y.keys;\n    a.merge = y.merge;\n    a.normalizeTickInterval = y.normalizeTickInterval;\n    a.objectEach = y.objectEach;\n    a.offset = y.offset;\n    a.pad = y.pad;\n    a.pick = y.pick;\n    a.pInt = y.pInt;\n    a.relativeLength = y.relativeLength;\n    a.removeEvent = y.removeEvent;\n    a.seriesType = b.seriesType;\n    a.splat = y.splat;\n    a.stableSort = y.stableSort;\n    a.syncTimeout = y.syncTimeout;\n    a.timeUnits = y.timeUnits;\n    a.uniqueKey = y.uniqueKey;\n    a.useSerialIds = y.useSerialIds;\n    a.wrap = y.wrap;\n    c.compose(f);\n    D.compose(G);\n    m.compose(t);\n    h.compose(t);\n    M.compose(n);\n    g.compose(t);\n    K.compose(k);\n    r.compose(t, k, G);\n    w.compose(F);\n    return a;\n  });\n  a[\"masters/highcharts.src.js\"]._modules = a;\n  return a[\"masters/highcharts.src.js\"];\n});","map":null,"metadata":{},"sourceType":"script"}